<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>CI Checks: Ensuring Better Code Quality and Faster Deployment | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/ci-checks-ensuring-better-code-quality-and-faster-deployment"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1691493542287/42771240-a91c-40dd-b0a7-ed8449911dd8.png"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">CI Checks: Ensuring Better Code Quality and Faster Deployment</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1663070035311/JaSbIMfve.jpg" class="w-10 h-10 rounded-full" alt="Shad Mirza"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Shad Mirza</div></div><time dateTime="2023-08-10T07:30:09.875Z">August 10, 2023</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for CI Checks: Ensuring Better Code Quality and Faster Deployment" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1691493522714%2F21672c1e-1f26-42a0-8ead-93f87f8211de.png&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>How can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?<br />The solution lies in implementing tests and multiple checks for linting and type errors.</p>
<p>This may seem straightforward, but it requires some adjustments to smooth out the developer experience (DX) flow and maintain developer productivity.</p>
<p>In this article, we'll explore how Hashnode previously managed its development workflow and the improvements it made to ensure better code quality and faster deployment through CI checks.</p>
<h2 id="heading-goal">Goal</h2>
<p>The goal is to establish a rapid feedback loop for developers, allowing them the freedom to experiment and move fast without being burdened by coding guidelines and the like.</p>
<p>Of course, we still aim to enforce coding guidelines and ensure that whatever reaches production is error-free and passes all checks. However, we want to accomplish this without hindering developer productivity and utilize tools at our disposal.</p>
<h2 id="heading-previous-workflow">Previous Workflow</h2>
<p>The previous workflow involved running each check on the developer's machine before they commit using pre-commit hooks. This involved enforcing coding guidelines, format commit messages and a bunch of other checks.</p>
<p>These guidelines were necessary but enforcing them at the pre-commit level was not a great idea. Developers should be allowed to code how they want and this was hurting the productivity.<br />Let's take a look at the different checks we had at the commit level.</p>
<h3 id="heading-type-checks">Type Checks</h3>
<p>We use TypeScript heavily to ensure the data types used in a codebase align with the expected types and catch potential errors or inconsistencies early in the development process. Usually, the IDE takes care of complaining whenever a certain function or component doesn't satisfy the types it was supposed to.</p>
<p>However, it is easy to overlook these warnings for pages that are out of the scope of the feature in development.</p>
<p>For this reason, it is necessary to perform type checks for every commit to guarantee that no issues arise throughout the codebase. This can be accomplished by using:</p>
<pre><code class="lang-bash">tsc --noEmit
</code></pre>
<p>This simple command will execute a type check on the entire codebase and generate an error if any issues are detected.</p>
<h3 id="heading-linting">Linting</h3>
<p>We use ESLint to enforce coding guidelines, ensuring that everything is in order. It also enforces aspects such as import order and accessibility checklists. To run lint checks on the relevant files, use the following command:</p>
<pre><code class="lang-bash">eslint . --fix --ext .js,.jsx,.ts,.tsx
</code></pre>
<p>These are plugins that we use at Hashnode</p>
<pre><code class="lang-json">{
    <span class="hljs-attr">"eslint"</span>: <span class="hljs-string">"^7.24.0"</span>,
    <span class="hljs-attr">"eslint-config-airbnb"</span>: <span class="hljs-string">"^18.2.1"</span>,
    <span class="hljs-attr">"eslint-config-airbnb-base"</span>: <span class="hljs-string">"^14.2.1"</span>,
    <span class="hljs-attr">"eslint-config-next"</span>: <span class="hljs-string">"13.0.5"</span>,
    <span class="hljs-attr">"eslint-config-prettier"</span>: <span class="hljs-string">"^8.3.0"</span>,
    <span class="hljs-attr">"eslint-import-resolver-typescript"</span>: <span class="hljs-string">"^2.4.0"</span>,
    <span class="hljs-attr">"eslint-plugin-cypress"</span>: <span class="hljs-string">"^2.11.3"</span>,
    <span class="hljs-attr">"eslint-plugin-import"</span>: <span class="hljs-string">"^2.22.1"</span>,
    <span class="hljs-attr">"eslint-plugin-jsx-a11y"</span>: <span class="hljs-string">"^6.4.1"</span>,
    <span class="hljs-attr">"eslint-plugin-prettier"</span>: <span class="hljs-string">"^3.4.0"</span>,
    <span class="hljs-attr">"eslint-plugin-react"</span>: <span class="hljs-string">"^7.23.2"</span>,
    <span class="hljs-attr">"eslint-plugin-react-hooks"</span>: <span class="hljs-string">"^4.2.0"</span>,
    <span class="hljs-attr">"@typescript-eslint/eslint-plugin"</span>: <span class="hljs-string">"^5.39.0"</span>,
}
</code></pre>
<h3 id="heading-tests">Tests</h3>
<p>We use React Testing Library to write tests for all critical business flows. These tests run on GitHub Actions and report any issues if something is broken. We also have merge rules in place for pull requests, ensuring that only tested code is allowed to merge and proceed to production.</p>
<h3 id="heading-husky">Husky</h3>
<p><a target="_blank" href="https://typicode.github.io/husky/">Husky</a> is a pre-commit hook that ties everything together. We configured Husky to perform type checks and lint checks on every commit. This ensures that we only commit error-free code and block pushes if something is broken. Since tests take some time to run, we decided to keep tests at the CI level and not run them locally for every commit.</p>
<h2 id="heading-the-problem">The Problem</h2>
<p>All of this is excellent and has been working effectively; however, there was a problem. As the codebase began to expand, running all these checks took between 3 to 6 minutes. This negatively impacted the DX, as developers had to wait for all the checks to pass before they could commit any changes.</p>
<p>Having checks at the commit level also impacted the freedom to experiment without worrying about formatting guidelines or perfect type usage. Ultimately, what gets merged into production is what matters most.</p>
<p>If you're looking for arguments against pre-commit hooks, this serves as a good example.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://www.youtube.com/watch?v=RAelLqnnOp0">https://www.youtube.com/watch?v=RAelLqnnOp0</a></div>
<p> </p>
<p>Hashnode believes in moving fast and iterating rapidly but this was hurting our ability to move fast. We had to do something about it.<br />Let's take a look at how we improved our development workflow.</p>
<h2 id="heading-optimizations-to-speed-up-checks">Optimizations to Speed Up Checks</h2>
<p>We began considering ways to enhance our workflow, and several ideas emerged. One aspect we were certain about was the necessity to stop running these checks locally and transition everything to CI.</p>
<p>We need to take advantage of the tools at our disposal as much as we can and eliminate manual work. Let's talk about the improvements one at a time.</p>
<h3 id="heading-moving-checks-to-ci">Moving Checks to CI</h3>
<p>We already had a GitHub workflow in place for running tests on CI using GitHub actions; we expanded it to include type and lint checks.</p>
<p>We wanted to run these checks concurrently, so we utilized <a target="_blank" href="https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow">jobs within the workflow</a> as a solution. This approach allowed us not to wait for one job to finish before starting another, enabling all three checks to run simultaneously. Let's examine the expanded workflow designed to execute these jobs concurrently.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">PR</span> <span class="hljs-string">Validation</span>

<span class="hljs-attr">on:</span>
  <span class="hljs-attr">pull_request:</span>
    <span class="hljs-attr">types:</span> [<span class="hljs-string">opened</span>, <span class="hljs-string">reopened</span>, <span class="hljs-string">synchronize</span>, <span class="hljs-string">ready_for_review</span>]
    <span class="hljs-attr">branches:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">development</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span>

<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">cypress-run:</span>
    <span class="hljs-attr">if:</span> <span class="hljs-string">github.event.pull_request.draft</span> <span class="hljs-string">==</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">env:</span>
      <span class="hljs-attr">NODE_ENV:</span> <span class="hljs-string">test</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-comment">#...steps</span>
  <span class="hljs-attr">type-check:</span>
      <span class="hljs-comment">#...checkout repo and install dependencies</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Type</span> <span class="hljs-string">checking</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">tsc</span> <span class="hljs-string">--no-Emit</span>
  <span class="hljs-attr">lint-check:</span>
      <span class="hljs-comment">#...checkout repo and install dependencies</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Linting</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">eslint</span> <span class="hljs-string">.</span> <span class="hljs-string">--fix</span> <span class="hljs-string">--ext</span> <span class="hljs-string">.js,.jsx,.ts,.tsx</span>
</code></pre>
<p>Now, we have three jobs running concurrently for tests, lint errors, and type errors.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1691050575992/ffa86ea0-a32e-4c96-8ca9-186ce1101015.png" class="image--center mx-auto" /></p>
<p>You might be wondering, what about catching errors during development to prevent pushing them in the first place?</p>
<p>Our IDEs are intelligent enough to detect these errors as we develop features, so we don't need to constantly check everything. The objective is to allow the merging of code only if it passes all checks in place, which can happen at the CI level.</p>
<p>After moving all the checks to the CI, we removed Husky and developers were allowed to push as they deemed appropriate. We will simply block the merging of pull requests if any issues arise.</p>
<p>This was an improvement over the previous approach, but we still have more work to do.</p>
<p>Machines running workflows are slower than our Macs, so checks performed on the CI are inevitably slower than when we run them locally.</p>
<p>Running all three checks on the CI took between 9 and 12 minutes. This meant that developers had to wait for 9 to 12 minutes before they could merge their pull requests. There is certainly room for improvement in this workflow.</p>
<div data-node-type="callout">
<div data-node-type="callout-emoji">🚀</div>
<div data-node-type="callout-text">These checks happen at every commit as soon as you raise a pull request (which is not in draft). This workflow will run anytime a pull request is opened, reopened, synchronized or marked as ready for review for the development or main branches as base branch.</div>
</div>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1691493604969/6d51d96c-b8bd-44d7-bf5b-155545d01cb1.png" class="image--center mx-auto" /></p>
<h3 id="heading-lint-staged-files-in-github-actions">Lint Staged Files in GitHub Actions</h3>
<p>One quick improvement we could make is to run lint checks only for the files that have been changed, and that's where Lint-staged comes in handy.</p>
<p>Lint-staged typically works in conjunction with a pre-commit hook, such as Husky, to run lint checks on staged files only. However, we can modify it to run within a CI environment and focus solely on the files that have changed between commits. Let's replace the lint step in the workflow with this approach:</p>
<pre><code class="lang-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Linting</span>
   <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">lint-staged</span> <span class="hljs-string">--diff="origin/${GITHUB_BASE_REF}...origin/${GITHUB_HEAD_REF}"</span> <span class="hljs-string">--no-stash</span>
</code></pre>
<p>This command calculates the difference between your branch and the base branch and then runs ESLint on it. This minor adjustment reduced the lint check duration from 30 seconds to 6 seconds.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1691050559924/c6cb39eb-7e47-4167-84f2-a3b3fb4ed947.png" class="image--center mx-auto" /></p>
<h3 id="heading-skipping-library-check-for-typescript">Skipping Library Check for TypeScript</h3>
<p>Type checking, due to its nature, must run on the entire codebase, so there isn't much we can do to optimize it. However, we can skip the library check to make it slightly faster. To do this, replace the type check with the following:</p>
<pre><code class="lang-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Type</span> <span class="hljs-string">checking</span>
   <span class="hljs-attr">run:</span> <span class="hljs-string">tsc</span> <span class="hljs-string">--pretty</span> <span class="hljs-string">--skipLibCheck</span> <span class="hljs-string">--noEmit</span>
</code></pre>
<p>Now that we've improved all the checks individually, it's time to cache whatever we can. Let's see how to cache the installation of dependencies for each job.</p>
<h3 id="heading-caching-node-modules">Caching Node Modules</h3>
<p>Since the three jobs run in parallel, they each need to install dependencies, which can be time-consuming. We've updated the workflow to cache dependencies and modified the "Installing dependency" step to skip when the cache is available. This can be achieved as follows:</p>
<pre><code class="lang-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">yarn</span> <span class="hljs-string">cache</span> <span class="hljs-string">directory</span> <span class="hljs-string">path</span>
    <span class="hljs-attr">id:</span> <span class="hljs-string">yarn-cache-dir-path</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">"dir=$(yarn cache dir)"</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">$GITHUB_OUTPUT</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v3</span>
    <span class="hljs-attr">id:</span> <span class="hljs-string">yarn-cache</span>
    <span class="hljs-attr">with:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">|
            **/node_modules
            **/.eslintcache
            ${{ steps.yarn-cache-dir-path.outputs.dir }}
</span>        <span class="hljs-attr">key:</span> <span class="hljs-string">${{</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">}}-yarn-${{</span> <span class="hljs-string">hashFiles('**/yarn.lock')</span> <span class="hljs-string">}}</span>
        <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|
            ${{ runner.os }}-yarn-
</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>
    <span class="hljs-attr">if:</span> <span class="hljs-string">steps.yarn-cache.outputs.cache-hit</span> <span class="hljs-type">!=</span> <span class="hljs-string">'true'</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">install</span> <span class="hljs-string">--frozen-lockfile</span>
</code></pre>
<p>We include this for all jobs and retrieve <code>node_modules</code> from the cache when available. This significantly improved the time required to complete the entire check.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1691050813498/b16c02d4-f08b-4cfb-b071-4e249bc6a6d6.png" class="image--center mx-auto" /></p>
<p>We are already in good shape, but there is one more improvement we can add.</p>
<h3 id="heading-removing-checks-from-vercel">Removing Checks from Vercel</h3>
<p>Vercel builds typically perform linting and type error checks by default. This causes the entire build process to take approximately 8 minutes.</p>
<p>Since we already perform error checks on our end, there's no need to repeat them during builds. The final step is to bypass these checks in Vercel builds. We implemented this in <code>vercel.config.js</code>:</p>
<pre><code class="lang-javascript">  eslint: {
    <span class="hljs-attr">ignoreDuringBuilds</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">typescript</span>: {
    <span class="hljs-attr">ignoreBuildErrors</span>: <span class="hljs-literal">true</span>,
  },
</code></pre>
<p>You can check <a target="_blank" href="https://nextjs.org/docs/app/api-reference/next-config-js">Vercel Docs</a> for the config specification.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1691050886193/2e1e3ec1-cc4a-4247-9f07-161733b166a0.png" class="image--center mx-auto" /></p>
<div data-node-type="callout">
<div data-node-type="callout-emoji">💻</div>
<div data-node-type="callout-text">Developers have the freedom to set up pre-commit hooks locally if they prefer. If they believe it enhances their workflow, they should be allowed to do so. By shifting checks to the CI, we ensure that we don't impose any opinions on how developers should work, granting them the liberty to proceed as they see fit.</div>
</div>

<h2 id="heading-conclusion">Conclusion</h2>
<p>By adding all the necessary improvements we discussed above, we were able to reduce the time required to merge a pull request from 12 minutes to 5 minutes. This improved both the developer experience and the overall deployment process.</p>
<p>Here's the summary of the improvements we added:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1690953115674/409ed5a5-4266-499a-86a5-f99e663eb941.png" class="image--center mx-auto" /></p>
<p>I hope this article was informative and you learned something new today 😄.</p>
<p>Do you think we can improve it further? Let us know in the comments.</p>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"ci-checks-ensuring-better-code-quality-and-faster-deployment","url":"https://engineering.hashnode.com/ci-checks-ensuring-better-code-quality-and-faster-deployment","brief":"How can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?The solution lies in implementing tests and multiple checks for linting and type errors.\nThis may seem straightforward, but it re...","title":"CI Checks: Ensuring Better Code Quality and Faster Deployment","publishedAt":"2023-08-10T07:30:09.875Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1691493522714/21672c1e-1f26-42a0-8ead-93f87f8211de.png"},"author":{"name":"Shad Mirza","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1663070035311/JaSbIMfve.jpg"},"id":"64d492016f3feecb8702c3b4","content":{"markdown":"How can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?  \nThe solution lies in implementing tests and multiple checks for linting and type errors.\n\nThis may seem straightforward, but it requires some adjustments to smooth out the developer experience (DX) flow and maintain developer productivity.\n\nIn this article, we'll explore how Hashnode previously managed its development workflow and the improvements it made to ensure better code quality and faster deployment through CI checks.\n\n## Goal\n\nThe goal is to establish a rapid feedback loop for developers, allowing them the freedom to experiment and move fast without being burdened by coding guidelines and the like.\n\nOf course, we still aim to enforce coding guidelines and ensure that whatever reaches production is error-free and passes all checks. However, we want to accomplish this without hindering developer productivity and utilize tools at our disposal.\n\n## Previous Workflow\n\nThe previous workflow involved running each check on the developer's machine before they commit using pre-commit hooks. This involved enforcing coding guidelines, format commit messages and a bunch of other checks.\n\nThese guidelines were necessary but enforcing them at the pre-commit level was not a great idea. Developers should be allowed to code how they want and this was hurting the productivity.  \nLet's take a look at the different checks we had at the commit level.\n\n### Type Checks\n\nWe use TypeScript heavily to ensure the data types used in a codebase align with the expected types and catch potential errors or inconsistencies early in the development process. Usually, the IDE takes care of complaining whenever a certain function or component doesn't satisfy the types it was supposed to.\n\nHowever, it is easy to overlook these warnings for pages that are out of the scope of the feature in development.\n\nFor this reason, it is necessary to perform type checks for every commit to guarantee that no issues arise throughout the codebase. This can be accomplished by using:\n\n```bash\ntsc --noEmit\n```\n\nThis simple command will execute a type check on the entire codebase and generate an error if any issues are detected.\n\n### Linting\n\nWe use ESLint to enforce coding guidelines, ensuring that everything is in order. It also enforces aspects such as import order and accessibility checklists. To run lint checks on the relevant files, use the following command:\n\n```bash\neslint . --fix --ext .js,.jsx,.ts,.tsx\n```\n\nThese are plugins that we use at Hashnode\n\n```json\n{\n    \"eslint\": \"^7.24.0\",\n    \"eslint-config-airbnb\": \"^18.2.1\",\n    \"eslint-config-airbnb-base\": \"^14.2.1\",\n    \"eslint-config-next\": \"13.0.5\",\n    \"eslint-config-prettier\": \"^8.3.0\",\n    \"eslint-import-resolver-typescript\": \"^2.4.0\",\n    \"eslint-plugin-cypress\": \"^2.11.3\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"eslint-plugin-jsx-a11y\": \"^6.4.1\",\n    \"eslint-plugin-prettier\": \"^3.4.0\",\n    \"eslint-plugin-react\": \"^7.23.2\",\n    \"eslint-plugin-react-hooks\": \"^4.2.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.39.0\",\n}\n```\n\n### Tests\n\nWe use React Testing Library to write tests for all critical business flows. These tests run on GitHub Actions and report any issues if something is broken. We also have merge rules in place for pull requests, ensuring that only tested code is allowed to merge and proceed to production.\n\n### Husky\n\n[Husky](https://typicode.github.io/husky/) is a pre-commit hook that ties everything together. We configured Husky to perform type checks and lint checks on every commit. This ensures that we only commit error-free code and block pushes if something is broken. Since tests take some time to run, we decided to keep tests at the CI level and not run them locally for every commit.\n\n## The Problem\n\nAll of this is excellent and has been working effectively; however, there was a problem. As the codebase began to expand, running all these checks took between 3 to 6 minutes. This negatively impacted the DX, as developers had to wait for all the checks to pass before they could commit any changes.\n\nHaving checks at the commit level also impacted the freedom to experiment without worrying about formatting guidelines or perfect type usage. Ultimately, what gets merged into production is what matters most.\n\nIf you're looking for arguments against pre-commit hooks, this serves as a good example.\n\n%[https://www.youtube.com/watch?v=RAelLqnnOp0] \n\nHashnode believes in moving fast and iterating rapidly but this was hurting our ability to move fast. We had to do something about it.  \nLet's take a look at how we improved our development workflow.\n\n## Optimizations to Speed Up Checks\n\nWe began considering ways to enhance our workflow, and several ideas emerged. One aspect we were certain about was the necessity to stop running these checks locally and transition everything to CI.\n\nWe need to take advantage of the tools at our disposal as much as we can and eliminate manual work. Let's talk about the improvements one at a time.\n\n### Moving Checks to CI\n\nWe already had a GitHub workflow in place for running tests on CI using GitHub actions; we expanded it to include type and lint checks.\n\nWe wanted to run these checks concurrently, so we utilized [jobs within the workflow](https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow) as a solution. This approach allowed us not to wait for one job to finish before starting another, enabling all three checks to run simultaneously. Let's examine the expanded workflow designed to execute these jobs concurrently.\n\n```yaml\nname: PR Validation\n\non:\n  pull_request:\n    types: [opened, reopened, synchronize, ready_for_review]\n    branches:\n      - development\n      - main\n\njobs:\n  cypress-run:\n    if: github.event.pull_request.draft == false\n    runs-on: ubuntu-latest\n    env:\n      NODE_ENV: test\n    steps:\n      #...steps\n  type-check:\n      #...checkout repo and install dependencies\n      - name: Type checking\n        run: tsc --no-Emit\n  lint-check:\n      #...checkout repo and install dependencies\n      - name: Linting\n        run: eslint . --fix --ext .js,.jsx,.ts,.tsx\n```\n\nNow, we have three jobs running concurrently for tests, lint errors, and type errors.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050575992/ffa86ea0-a32e-4c96-8ca9-186ce1101015.png align=\"center\")\n\nYou might be wondering, what about catching errors during development to prevent pushing them in the first place?\n\nOur IDEs are intelligent enough to detect these errors as we develop features, so we don't need to constantly check everything. The objective is to allow the merging of code only if it passes all checks in place, which can happen at the CI level.\n\nAfter moving all the checks to the CI, we removed Husky and developers were allowed to push as they deemed appropriate. We will simply block the merging of pull requests if any issues arise.\n\nThis was an improvement over the previous approach, but we still have more work to do.\n\nMachines running workflows are slower than our Macs, so checks performed on the CI are inevitably slower than when we run them locally.\n\nRunning all three checks on the CI took between 9 and 12 minutes. This meant that developers had to wait for 9 to 12 minutes before they could merge their pull requests. There is certainly room for improvement in this workflow.\n\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e🚀\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003eThese checks happen at every commit as soon as you raise a pull request (which is not in draft). This workflow will run anytime a pull request is opened, reopened, synchronized or marked as ready for review for the development or main branches as base branch.\u003c/div\u003e\n\u003c/div\u003e\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691493604969/6d51d96c-b8bd-44d7-bf5b-155545d01cb1.png align=\"center\")\n\n### Lint Staged Files in GitHub Actions\n\nOne quick improvement we could make is to run lint checks only for the files that have been changed, and that's where Lint-staged comes in handy.\n\nLint-staged typically works in conjunction with a pre-commit hook, such as Husky, to run lint checks on staged files only. However, we can modify it to run within a CI environment and focus solely on the files that have changed between commits. Let's replace the lint step in the workflow with this approach:\n\n```yaml\n- name: Linting\n   run: yarn lint-staged --diff=\"origin/${GITHUB_BASE_REF}...origin/${GITHUB_HEAD_REF}\" --no-stash\n```\n\nThis command calculates the difference between your branch and the base branch and then runs ESLint on it. This minor adjustment reduced the lint check duration from 30 seconds to 6 seconds.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050559924/c6cb39eb-7e47-4167-84f2-a3b3fb4ed947.png align=\"center\")\n\n### Skipping Library Check for TypeScript\n\nType checking, due to its nature, must run on the entire codebase, so there isn't much we can do to optimize it. However, we can skip the library check to make it slightly faster. To do this, replace the type check with the following:\n\n```yaml\n- name: Type checking\n   run: tsc --pretty --skipLibCheck --noEmit\n```\n\nNow that we've improved all the checks individually, it's time to cache whatever we can. Let's see how to cache the installation of dependencies for each job.\n\n### Caching Node Modules\n\nSince the three jobs run in parallel, they each need to install dependencies, which can be time-consuming. We've updated the workflow to cache dependencies and modified the \"Installing dependency\" step to skip when the cache is available. This can be achieved as follows:\n\n```yaml\n- name: Get yarn cache directory path\n    id: yarn-cache-dir-path\n    run: echo \"dir=$(yarn cache dir)\" \u003e\u003e $GITHUB_OUTPUT\n- uses: actions/cache@v3\n    id: yarn-cache\n    with:\n        path: |\n            **/node_modules\n            **/.eslintcache\n            ${{ steps.yarn-cache-dir-path.outputs.dir }}\n        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n        restore-keys: |\n            ${{ runner.os }}-yarn-\n- name: Install dependencies\n    if: steps.yarn-cache.outputs.cache-hit != 'true'\n    run: yarn install --frozen-lockfile\n```\n\nWe include this for all jobs and retrieve `node_modules` from the cache when available. This significantly improved the time required to complete the entire check.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050813498/b16c02d4-f08b-4cfb-b071-4e249bc6a6d6.png align=\"center\")\n\nWe are already in good shape, but there is one more improvement we can add.\n\n### Removing Checks from Vercel\n\nVercel builds typically perform linting and type error checks by default. This causes the entire build process to take approximately 8 minutes.\n\nSince we already perform error checks on our end, there's no need to repeat them during builds. The final step is to bypass these checks in Vercel builds. We implemented this in `vercel.config.js`:\n\n```javascript\n  eslint: {\n    ignoreDuringBuilds: true,\n  },\n  typescript: {\n    ignoreBuildErrors: true,\n  },\n```\n\nYou can check [Vercel Docs](https://nextjs.org/docs/app/api-reference/next-config-js) for the config specification.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050886193/2e1e3ec1-cc4a-4247-9f07-161733b166a0.png align=\"center\")\n\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e💻\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003eDevelopers have the freedom to set up pre-commit hooks locally if they prefer. If they believe it enhances their workflow, they should be allowed to do so. By shifting checks to the CI, we ensure that we don't impose any opinions on how developers should work, granting them the liberty to proceed as they see fit.\u003c/div\u003e\n\u003c/div\u003e\n\n## Conclusion\n\nBy adding all the necessary improvements we discussed above, we were able to reduce the time required to merge a pull request from 12 minutes to 5 minutes. This improved both the developer experience and the overall deployment process.\n\nHere's the summary of the improvements we added:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1690953115674/409ed5a5-4266-499a-86a5-f99e663eb941.png align=\"center\")\n\nI hope this article was informative and you learned something new today 😄.\n\nDo you think we can improve it further? Let us know in the comments.","html":"\u003cp\u003eHow can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?\u003cbr /\u003eThe solution lies in implementing tests and multiple checks for linting and type errors.\u003c/p\u003e\n\u003cp\u003eThis may seem straightforward, but it requires some adjustments to smooth out the developer experience (DX) flow and maintain developer productivity.\u003c/p\u003e\n\u003cp\u003eIn this article, we'll explore how Hashnode previously managed its development workflow and the improvements it made to ensure better code quality and faster deployment through CI checks.\u003c/p\u003e\n\u003ch2 id=\"heading-goal\"\u003eGoal\u003c/h2\u003e\n\u003cp\u003eThe goal is to establish a rapid feedback loop for developers, allowing them the freedom to experiment and move fast without being burdened by coding guidelines and the like.\u003c/p\u003e\n\u003cp\u003eOf course, we still aim to enforce coding guidelines and ensure that whatever reaches production is error-free and passes all checks. However, we want to accomplish this without hindering developer productivity and utilize tools at our disposal.\u003c/p\u003e\n\u003ch2 id=\"heading-previous-workflow\"\u003ePrevious Workflow\u003c/h2\u003e\n\u003cp\u003eThe previous workflow involved running each check on the developer's machine before they commit using pre-commit hooks. This involved enforcing coding guidelines, format commit messages and a bunch of other checks.\u003c/p\u003e\n\u003cp\u003eThese guidelines were necessary but enforcing them at the pre-commit level was not a great idea. Developers should be allowed to code how they want and this was hurting the productivity.\u003cbr /\u003eLet's take a look at the different checks we had at the commit level.\u003c/p\u003e\n\u003ch3 id=\"heading-type-checks\"\u003eType Checks\u003c/h3\u003e\n\u003cp\u003eWe use TypeScript heavily to ensure the data types used in a codebase align with the expected types and catch potential errors or inconsistencies early in the development process. Usually, the IDE takes care of complaining whenever a certain function or component doesn't satisfy the types it was supposed to.\u003c/p\u003e\n\u003cp\u003eHowever, it is easy to overlook these warnings for pages that are out of the scope of the feature in development.\u003c/p\u003e\n\u003cp\u003eFor this reason, it is necessary to perform type checks for every commit to guarantee that no issues arise throughout the codebase. This can be accomplished by using:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-bash\"\u003etsc --noEmit\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis simple command will execute a type check on the entire codebase and generate an error if any issues are detected.\u003c/p\u003e\n\u003ch3 id=\"heading-linting\"\u003eLinting\u003c/h3\u003e\n\u003cp\u003eWe use ESLint to enforce coding guidelines, ensuring that everything is in order. It also enforces aspects such as import order and accessibility checklists. To run lint checks on the relevant files, use the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-bash\"\u003eeslint . --fix --ext .js,.jsx,.ts,.tsx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese are plugins that we use at Hashnode\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-json\"\u003e{\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^7.24.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-config-airbnb\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^18.2.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-config-airbnb-base\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^14.2.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-config-next\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"13.0.5\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-config-prettier\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^8.3.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-import-resolver-typescript\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^2.4.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-plugin-cypress\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^2.11.3\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-plugin-import\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^2.22.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-plugin-jsx-a11y\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^6.4.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-plugin-prettier\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^3.4.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-plugin-react\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^7.23.2\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"eslint-plugin-react-hooks\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^4.2.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"@typescript-eslint/eslint-plugin\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^5.39.0\"\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"heading-tests\"\u003eTests\u003c/h3\u003e\n\u003cp\u003eWe use React Testing Library to write tests for all critical business flows. These tests run on GitHub Actions and report any issues if something is broken. We also have merge rules in place for pull requests, ensuring that only tested code is allowed to merge and proceed to production.\u003c/p\u003e\n\u003ch3 id=\"heading-husky\"\u003eHusky\u003c/h3\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://typicode.github.io/husky/\"\u003eHusky\u003c/a\u003e is a pre-commit hook that ties everything together. We configured Husky to perform type checks and lint checks on every commit. This ensures that we only commit error-free code and block pushes if something is broken. Since tests take some time to run, we decided to keep tests at the CI level and not run them locally for every commit.\u003c/p\u003e\n\u003ch2 id=\"heading-the-problem\"\u003eThe Problem\u003c/h2\u003e\n\u003cp\u003eAll of this is excellent and has been working effectively; however, there was a problem. As the codebase began to expand, running all these checks took between 3 to 6 minutes. This negatively impacted the DX, as developers had to wait for all the checks to pass before they could commit any changes.\u003c/p\u003e\n\u003cp\u003eHaving checks at the commit level also impacted the freedom to experiment without worrying about formatting guidelines or perfect type usage. Ultimately, what gets merged into production is what matters most.\u003c/p\u003e\n\u003cp\u003eIf you're looking for arguments against pre-commit hooks, this serves as a good example.\u003c/p\u003e\n\u003cdiv class=\"embed-wrapper\"\u003e\u003cdiv class=\"embed-loading\"\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\"embed-card\" href=\"https://www.youtube.com/watch?v=RAelLqnnOp0\"\u003ehttps://www.youtube.com/watch?v=RAelLqnnOp0\u003c/a\u003e\u003c/div\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003eHashnode believes in moving fast and iterating rapidly but this was hurting our ability to move fast. We had to do something about it.\u003cbr /\u003eLet's take a look at how we improved our development workflow.\u003c/p\u003e\n\u003ch2 id=\"heading-optimizations-to-speed-up-checks\"\u003eOptimizations to Speed Up Checks\u003c/h2\u003e\n\u003cp\u003eWe began considering ways to enhance our workflow, and several ideas emerged. One aspect we were certain about was the necessity to stop running these checks locally and transition everything to CI.\u003c/p\u003e\n\u003cp\u003eWe need to take advantage of the tools at our disposal as much as we can and eliminate manual work. Let's talk about the improvements one at a time.\u003c/p\u003e\n\u003ch3 id=\"heading-moving-checks-to-ci\"\u003eMoving Checks to CI\u003c/h3\u003e\n\u003cp\u003eWe already had a GitHub workflow in place for running tests on CI using GitHub actions; we expanded it to include type and lint checks.\u003c/p\u003e\n\u003cp\u003eWe wanted to run these checks concurrently, so we utilized \u003ca target=\"_blank\" href=\"https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow\"\u003ejobs within the workflow\u003c/a\u003e as a solution. This approach allowed us not to wait for one job to finish before starting another, enabling all three checks to run simultaneously. Let's examine the expanded workflow designed to execute these jobs concurrently.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ePR\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eValidation\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eon:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003epull_request:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etypes:\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003eopened\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003ereopened\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003esynchronize\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003eready_for_review\u003c/span\u003e]\n    \u003cspan class=\"hljs-attr\"\u003ebranches:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edevelopment\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emain\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003ejobs:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecypress-run:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eif:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egithub.event.pull_request.draft\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e==\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eruns-on:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu-latest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eenv:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eNODE_ENV:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etest\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003esteps:\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e#...steps\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etype-check:\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e#...checkout repo and install dependencies\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eType\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003echecking\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etsc\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--no-Emit\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003elint-check:\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e#...checkout repo and install dependencies\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eLinting\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eeslint\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--fix\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--ext\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.js,.jsx,.ts,.tsx\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we have three jobs running concurrently for tests, lint errors, and type errors.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050575992/ffa86ea0-a32e-4c96-8ca9-186ce1101015.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eYou might be wondering, what about catching errors during development to prevent pushing them in the first place?\u003c/p\u003e\n\u003cp\u003eOur IDEs are intelligent enough to detect these errors as we develop features, so we don't need to constantly check everything. The objective is to allow the merging of code only if it passes all checks in place, which can happen at the CI level.\u003c/p\u003e\n\u003cp\u003eAfter moving all the checks to the CI, we removed Husky and developers were allowed to push as they deemed appropriate. We will simply block the merging of pull requests if any issues arise.\u003c/p\u003e\n\u003cp\u003eThis was an improvement over the previous approach, but we still have more work to do.\u003c/p\u003e\n\u003cp\u003eMachines running workflows are slower than our Macs, so checks performed on the CI are inevitably slower than when we run them locally.\u003c/p\u003e\n\u003cp\u003eRunning all three checks on the CI took between 9 and 12 minutes. This meant that developers had to wait for 9 to 12 minutes before they could merge their pull requests. There is certainly room for improvement in this workflow.\u003c/p\u003e\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e🚀\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003eThese checks happen at every commit as soon as you raise a pull request (which is not in draft). This workflow will run anytime a pull request is opened, reopened, synchronized or marked as ready for review for the development or main branches as base branch.\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691493604969/6d51d96c-b8bd-44d7-bf5b-155545d01cb1.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-lint-staged-files-in-github-actions\"\u003eLint Staged Files in GitHub Actions\u003c/h3\u003e\n\u003cp\u003eOne quick improvement we could make is to run lint checks only for the files that have been changed, and that's where Lint-staged comes in handy.\u003c/p\u003e\n\u003cp\u003eLint-staged typically works in conjunction with a pre-commit hook, such as Husky, to run lint checks on staged files only. However, we can modify it to run within a CI environment and focus solely on the files that have changed between commits. Let's replace the lint step in the workflow with this approach:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-yaml\"\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eLinting\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyarn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elint-staged\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--diff=\"origin/${GITHUB_BASE_REF}...origin/${GITHUB_HEAD_REF}\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--no-stash\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis command calculates the difference between your branch and the base branch and then runs ESLint on it. This minor adjustment reduced the lint check duration from 30 seconds to 6 seconds.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050559924/c6cb39eb-7e47-4167-84f2-a3b3fb4ed947.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-skipping-library-check-for-typescript\"\u003eSkipping Library Check for TypeScript\u003c/h3\u003e\n\u003cp\u003eType checking, due to its nature, must run on the entire codebase, so there isn't much we can do to optimize it. However, we can skip the library check to make it slightly faster. To do this, replace the type check with the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-yaml\"\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eType\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003echecking\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etsc\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--pretty\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--skipLibCheck\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--noEmit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we've improved all the checks individually, it's time to cache whatever we can. Let's see how to cache the installation of dependencies for each job.\u003c/p\u003e\n\u003ch3 id=\"heading-caching-node-modules\"\u003eCaching Node Modules\u003c/h3\u003e\n\u003cp\u003eSince the three jobs run in parallel, they each need to install dependencies, which can be time-consuming. We've updated the workflow to cache dependencies and modified the \"Installing dependency\" step to skip when the cache is available. This can be achieved as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-yaml\"\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eGet\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyarn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecache\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edirectory\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epath\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyarn-cache-dir-path\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"dir=$(yarn cache dir)\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e$GITHUB_OUTPUT\u003c/span\u003e\n\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euses:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eactions/cache@v3\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyarn-cache\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ewith:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003epath:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e|\n            **/node_modules\n            **/.eslintcache\n            ${{ steps.yarn-cache-dir-path.outputs.dir }}\n\u003c/span\u003e        \u003cspan class=\"hljs-attr\"\u003ekey:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e${{\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003erunner.os\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e}}-yarn-${{\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehashFiles('**/yarn.lock')\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e}}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erestore-keys:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e|\n            ${{ runner.os }}-yarn-\n\u003c/span\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eInstall\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edependencies\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eif:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esteps.yarn-cache.outputs.cache-hit\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003e!=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003erun:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyarn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003einstall\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--frozen-lockfile\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe include this for all jobs and retrieve \u003ccode\u003enode_modules\u003c/code\u003e from the cache when available. This significantly improved the time required to complete the entire check.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050813498/b16c02d4-f08b-4cfb-b071-4e249bc6a6d6.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eWe are already in good shape, but there is one more improvement we can add.\u003c/p\u003e\n\u003ch3 id=\"heading-removing-checks-from-vercel\"\u003eRemoving Checks from Vercel\u003c/h3\u003e\n\u003cp\u003eVercel builds typically perform linting and type error checks by default. This causes the entire build process to take approximately 8 minutes.\u003c/p\u003e\n\u003cp\u003eSince we already perform error checks on our end, there's no need to repeat them during builds. The final step is to bypass these checks in Vercel builds. We implemented this in \u003ccode\u003evercel.config.js\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-javascript\"\u003e  eslint: {\n    \u003cspan class=\"hljs-attr\"\u003eignoreDuringBuilds\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n  \u003cspan class=\"hljs-attr\"\u003etypescript\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eignoreBuildErrors\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can check \u003ca target=\"_blank\" href=\"https://nextjs.org/docs/app/api-reference/next-config-js\"\u003eVercel Docs\u003c/a\u003e for the config specification.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050886193/2e1e3ec1-cc4a-4247-9f07-161733b166a0.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e💻\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003eDevelopers have the freedom to set up pre-commit hooks locally if they prefer. If they believe it enhances their workflow, they should be allowed to do so. By shifting checks to the CI, we ensure that we don't impose any opinions on how developers should work, granting them the liberty to proceed as they see fit.\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"heading-conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eBy adding all the necessary improvements we discussed above, we were able to reduce the time required to merge a pull request from 12 minutes to 5 minutes. This improved both the developer experience and the overall deployment process.\u003c/p\u003e\n\u003cp\u003eHere's the summary of the improvements we added:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1690953115674/409ed5a5-4266-499a-86a5-f99e663eb941.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eI hope this article was informative and you learned something new today 😄.\u003c/p\u003e\n\u003cp\u003eDo you think we can improve it further? Let us know in the comments.\u003c/p\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1691493542287/42771240-a91c-40dd-b0a7-ed8449911dd8.png"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"ci-checks-ensuring-better-code-quality-and-faster-deployment"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>