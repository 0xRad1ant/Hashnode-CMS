{"pageProps":{"post":{"slug":"understanding-graphql-error-codes-with-stellate-aws-lambda-api-gateway-and-apollo","url":"https://engineering.hashnode.com/understanding-graphql-error-codes-with-stellate-aws-lambda-api-gateway-and-apollo","brief":"GraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like\n\n200 OK\n\n400 Bad Request\n\n500 Server Error\n\n\nIt often happens that an error happened even if we received a 200 status code.\nThis blog pos...","title":"From Chaos to Clarity: Understanding GraphQL Error Codes with Stellate, AWS Lambda, API Gateway, and Apollo","publishedAt":"2023-02-21T06:58:35.770Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1676964092528/216d132a-88bd-44b8-a263-9001cb3fdc4b.png"},"author":{"name":"Sandro Volpicella","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg"},"id":"63f46b9b4cd7a287eab5c0c7","content":{"markdown":"GraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like\n\n* **200** OK\n    \n* **400** Bad Request\n    \n* **500** Server Error\n    \n\nIt often happens that an error happened even if we received a 200 status code.\n\nThis blog post is about **the internals of how Hashnode** uses error codes for debugging and understanding the system. This is also for you my fellow Hashnode colleagues ü§ó\n\nThis post is **not a complete guide** to GraphQL error metrics. Each framework handles it a bit differently and I am not considering myself an expert in each of them.\n\n## Hashnode's Architecture - Stellate, API Gateway, Lambda, Apollo\n\nTo be able to understand how everything interacts I first give you an introduction to our internal Hashnode Architecture.\n\n![Hashnode's API Infrastructure](https://cdn.hashnode.com/res/hashnode/image/upload/v1676451250250/bee89246-4aa7-482b-a731-776d3b96b89f.png align=\"center\")\n\nWe have a serverless-first mindset. That means everywhere where it makes sense we use serverless services. We don't want to build & manage infrastructure ourselves.\n\nOur API consists of the following services:\n\n* **API Gateway** with AWS Lambda as the main API\n    \n* **Apollo Server** as the GraphQL server\n    \n* [**Stellate**](https://stellate.co) **CDN** as an Edge Cache, Analytics, and Error Software\n    \n\nTo cache our responses on the edge we use [Stellate](http://stellate.co). Stellate gives your GraphQL API superpowers! Automatic alerts, analytics, rate limits, and much more.\n\nIn between sits an **HTTP API Gateway**. API Gateway integrates with Lambda. It forwards each request and sends it to the Lambda function. Lambda creates the Apollo Handler on each invocation (for new containers) and fulfills the request.\n\nAPI Gateway and Lambda have both **status codes**. This is where it gets interesting.\n\n* **API Gateway Status Code:** This is the status code of the receiver of this API (i.e. Stellate) that receives\n    \n* **Lambda Integration Status Code**: This is the status code API Gateway receives\n    \n\nThis is not necessarily the same status code! There is even a third response status code, which is the response code **by Stellate**. Most of the time (almost always) this mirrors the status code of the API Gateway.\n\nBy using Stellate we were now also aware of all the different error codes our API consumers received.\n\n![Different Status Codes by Stellate](https://cdn.hashnode.com/res/hashnode/image/upload/v1675431258965/7d951c8f-0c81-4819-9cc4-f797e5e6bf70.png align=\"center\")\n\nThat's the reason for this blog post. Let's dive a bit deeper into the errors GraphQL returns to you.\n\n## An Overview of HTTP Status Codes\n\nGraphQL is still a typical REST call. You make a POST call to an endpoint and you will receive an HTTP response. This response can have several status codes.\n\nLet's first look over the status codes **briefly**, then focus on some detailed examples and see how Stellate, API Gateway, and Lambda react.\n\n### 200 - OK, or Is It? ü§î\n\n200 in HTTP means the request was **successful**. This is one of the **confusing codes** in GraphQL.\n\n200 doesn't tell that no error happened. It only means that the request was successful. You still need to check your actual response to see if an error was returned. If an error in your GraphQL API happened it will be visible by having an `GRAPHQL_ERROR_CODE` in the response body.\n\n### 400 - Bad Request\n\nGraphQL APIs are based on a schema. Our schema for a publication for example is the following:\n\n```graphql\n  type Publication implements Node {\n    id: ID!\n    title: String!\n    ...\n}\n```\n\nIf you want to access a field that is not implemented in this schema you get an error code 400 - `GRAPHQL_VALIDATION_FAILED`. 400 in general are validation errors.\n\n### 500 - Server Error\n\n500 still means server errors. 500 are still **bad errors**. That means you need to check them. They should not happen. But be aware. Understanding where the error actually appeared can be quite a challenge in the beginning.\n\n500 is a **server error** but what is our server in the architecture? Is it the lambda handler? The Apollo Handler, or anything in between?\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1675433481488/6d7b62a8-c1f5-4a5c-bf75-e2c0e25dd263.png align=\"center\")\n\nThe Lambda function has two components:\n\n1. **Lambda Function**: This is everything that happens **before** the Apollo server starts, e.g. connecting to the DB, fetching secrets, etc.\n    \n2. **Apollo Handler**: This is the Apollo server handling requests.\n    \n\n500 **in our architecture** means there is something wrong with the **Lambda function** itself. This doesn't mean something is wrong with the **Apollo Handler** but with the **Lambda Function**. We will see both examples in the example section.\n\n## Real Scenarios - Let's see some Examples\n\nOkay, so far the theory. I hope you are still with me. Let's now dig a bit deeper and understand some example scenarios.\n\n### Successful Request - The Happy Path ü§ó\n\nA user sends a correct query, for example, this one:\n\n```graphql\nquery {\n    publication(host:\"jannikwempe.hashnode.net\") {\n        id\n        author {\n            name\n        }\n    }\n}\n```\n\nStellate receives this query, and forwards it to API Gateway, API Gateway creates the event and invokes the Lambda function. Lambda queries the database and sends the response back to API Gateway. This is how everything comes together.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1675433832056/18008a34-cca8-4a08-9d4b-31d12cd72c4d.png align=\"center\")\n\nAll states are 200 and everything is fine.\n\nLet's see the example in Postman:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676452245755/1f25e958-80f4-43b8-b51a-5f8245e31802.png align=\"center\")\n\nWe receive the response we expect with the status code we expect üëçüèΩ\n\n### Error in Apollo Handler - 200 NOT OK ‚ùå\n\nNow let's see an example of the mysterious 200 response with an error.\n\nWe mock an error by throwing an error from **the Apollo Handler**. Remember, Apollo Handler != Lambda Handler necessarily.\n\nIn the Lambda Handler function we create the Apollo Handler like that:\n\n```typescript\nconst serverHandler: Handler<any, any> = (...args) => {\n...\n  return server.createHandler()\n...\n};\n```\n\nEverything that happens within the `server` will be an error **within the handler.** To mock this behavior I've added a `throw new Error()` somewhere in querying a publication.\n\nThe result looks like that:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1675433894562/98f1d799-6b8d-4a85-870a-c4b414d6d85f.png align=\"center\")\n\nIf we are now calling the same query we see the following result:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676452532352/e31f41da-641a-40ba-afe7-bdaa4e94cb18.png align=\"center\")\n\nFor us, this was new. Even for an **undefined** error and a clear **server error,** the API responds with a 200 response code. The actual error code is in the response and maps on the error code `INTERNAL_SERVER_ERROR`. You can define this behavior of course.\n\nThat is where Stellate is doing a great Job. Without the need of creating any extra logic, Stellate shows us the error in their Error Dashboard:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676452754438/87919f94-7b20-478f-b84b-c23eb6102a78.png align=\"center\")\n\n**Learning from this scenario:** You need to have alerts on 200 response codes like `INTERNAL_SERVER_ERRORS` as well.\n\n### Server Error, for Real -&gt; 500\n\nThe next scenario we look at is a proper server error. This time not the Apollo Handler but the **Lambda Function itself** throws an undefined error.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453590617/d9d8f0eb-6e51-4eae-b2ed-600717bcf222.png align=\"center\")\n\nThe Lambda function is defined as everything that happens **before** the Apollo server is created. In our scenario, this is mainly connecting to our database and caching the connection in the Lambda context. We are doing this by using the amazing [middy middleware library](https://middy.js.org/).\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453319426/a0176449-4ad3-49d4-bf5c-1b6ef4c78dbf.png align=\"center\")\n\nI introduced an error by throwing an undefined error in the middleware that connects to the DB.\n\nLet's see what it looks like in Postman:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453490262/0f6b1e64-5758-4baf-94da-0f153f712c29.png align=\"center\")\n\nAh, this time we get a proper 500 error code! Which makes sense of course. No GraphQL server started so there is no way to parse errors in a different way than a normal REST API.\n\nIn Stellate it looks like that:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453669536/f3c5d744-ed8f-4499-9bc8-ba2e22f5471e.png align=\"center\")\n\n**Learning from this scenario:** A 500 error means there is something wrong with the underlying \"infrastructure\" which is your Lambda function. This makes debugging a whole lot easier.\n\n### GET Request on Stellate vs. directly on API Gateway\n\nGraphQL only uses the HTTP Method **POST** for serving data. As a company with our scale, we see many people trying out our internal APIs as well and trying to come through üïµüèΩ\n\nSince we'd like to understand how our system behaves in different scenarios we also looked at that one.\n\nIf you send a GET request to the Stellate endpoint you will get the following response: 204 - No Content\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676454196106/01a6de93-a381-48fe-b2fc-688b4ed62f99.png align=\"center\")\n\nInterestingly enough, if you send the same request **directly to the API Gateway** you will get a 400 response code.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676454225263/42cdda69-97de-4adc-be3d-b587b3c9501d.png align=\"center\")\n\nThe main important thing. Requests like that shouldn't even be able to enter your API.\n\n**Learning from this scenario:** Understand that some response codes behave differently on Stellate and on API GW.\n\n### Validation Errors\n\nNow we will look at some validation errors, i.e. 400 error codes. A validation error means that there is something wrong with your query or mutation. While you get 400 as a response code you will also get a GraphQL error code in your response.\n\n#### Access Invalid Field\n\nLet's start by trying to access a field that doesn't exist.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676454571665/62ddeb0d-3327-40b1-b4b4-dec4b559f510.png align=\"center\")\n\nI try to send the following query to our API:\n\n```graphql\n{\n   publication(host:\"jannikwempe.hashnode.net\") {\n       id\n       bla\n   }\n}\n```\n\nThis will result in a response code 400 -&gt; validation failing.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676465439853/f42eea63-4e8f-4197-b92b-ed06be943c8c.png align=\"center\")\n\nWe receive the error `GRAPHQL_VALIDATION_FAILED`. So far so good.\n\n#### Type Check Fails\n\nSomething similar happens if you provide the wrong type. Instead of passing the `username` as a string, I've added the `username` as a number here.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676465586589/88cc6908-bf70-4d28-9179-04978ba314d3.png align=\"center\")\n\nThis will also result in the following response\n\n```json\n{\n    \"errors\": [\n        {\n            \"message\": \"String cannot represent a non string value: 123\",\n            \"extensions\": {\n                \"code\": \"GRAPHQL_VALIDATION_FAILED\",\n            }\n        }\n    ]\n}\n```\n\n#### 400 but a server error\n\nOne error that took some while for us to understand was the following one:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676465758320/d59330d4-2a2f-456e-ac2a-d3a7974f7856.png align=\"center\")\n\nIn Stellate we received lots of error messages with the response code 400. But the actual GraphQL error code was `INTERNAL_SERVER_ERROR`.\n\nSo what now? Validation error because of the response code 400? Or an internal server error? But why isn't that a 200 error then like in the first examples?\n\nBy taking a closer look we saw that none of these exceptions had a query attached. By trying to reproduce it we saw that some people are trying out to send empty queries to our API. This results in a server error with the response code 400.\n\nCases like these can be adjusted manually in Apollo. But by default, it behaves like that.\n\n**Learning from this scenario:** Understand that the GraphQL error code is the most important piece to understand. In this case, `INTERNAL_SERVER_ERROR` is an expected code and nothing is wrong with your server.\n\n### Playground deactivated - 403 vs. 400\n\nOne last error we faced a lot at times is a 403 error from Stellate:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676466176458/4281a5e9-abbe-42da-98a7-4cae155225c7.png align=\"center\")\n\nThis error indicates that somebody is doing a `GET` request on our API. But when I tried to reproduce that I got a `204 - No Content` like seen above. It took some time to understand that this error message results if somebody tries to access a disabled GraphQL playground. When I try to access the **Stellate Playground** I get a 403 Forbidden error.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676466433979/2249a5b1-5b88-43dd-8888-ffb16e4a4ffb.png align=\"center\")\n\n**But** if I try to access the GraphQL Playground directly in Apollo and it is deactivated I get a 400 error.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676466476500/83e0ad24-9a4a-4dbe-b440-9f337fa79c8c.png align=\"center\")\n\nThis is nothing major. It is still important for us to understand the differences. With that, we are able to act on real 403 issues.\n\n## Summary\n\nIn summary, it is really important to understand the ins and outs of your API. Stellate makes our lives much easier by automatically parsing GraphQL error codes and showing the resulting response codes. In the end, everything is dependent on the implementation of your GraphQL server.\n\nTo be able to act quickly on incidents or abnormal behavior it is critical to understand what each error code and error message actually means. Many errors are expected. Especially in cases like:\n\n* Unauthenticated access\n    \n* Validation Errors\n    \n\nBut there are also many cases where they are not expected.\n\nWe have created several alarms and in special cases also an automated generation of Incidents (üëãüèΩ Better Uptime) so that we are able to act quickly on all upcoming incidents.\n\nThanks for sticking with me, see you soon üëãüèΩ","html":"<p>GraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like</p>\n<ul>\n<li><p><strong>200</strong> OK</p>\n</li>\n<li><p><strong>400</strong> Bad Request</p>\n</li>\n<li><p><strong>500</strong> Server Error</p>\n</li>\n</ul>\n<p>It often happens that an error happened even if we received a 200 status code.</p>\n<p>This blog post is about <strong>the internals of how Hashnode</strong> uses error codes for debugging and understanding the system. This is also for you my fellow Hashnode colleagues ü§ó</p>\n<p>This post is <strong>not a complete guide</strong> to GraphQL error metrics. Each framework handles it a bit differently and I am not considering myself an expert in each of them.</p>\n<h2 id=\"heading-hashnodes-architecture-stellate-api-gateway-lambda-apollo\">Hashnode's Architecture - Stellate, API Gateway, Lambda, Apollo</h2>\n<p>To be able to understand how everything interacts I first give you an introduction to our internal Hashnode Architecture.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676451250250/bee89246-4aa7-482b-a731-776d3b96b89f.png\" alt=\"Hashnode's API Infrastructure\" class=\"image--center mx-auto\" /></p>\n<p>We have a serverless-first mindset. That means everywhere where it makes sense we use serverless services. We don't want to build &amp; manage infrastructure ourselves.</p>\n<p>Our API consists of the following services:</p>\n<ul>\n<li><p><strong>API Gateway</strong> with AWS Lambda as the main API</p>\n</li>\n<li><p><strong>Apollo Server</strong> as the GraphQL server</p>\n</li>\n<li><p><a target=\"_blank\" href=\"https://stellate.co\"><strong>Stellate</strong></a> <strong>CDN</strong> as an Edge Cache, Analytics, and Error Software</p>\n</li>\n</ul>\n<p>To cache our responses on the edge we use <a target=\"_blank\" href=\"http://stellate.co\">Stellate</a>. Stellate gives your GraphQL API superpowers! Automatic alerts, analytics, rate limits, and much more.</p>\n<p>In between sits an <strong>HTTP API Gateway</strong>. API Gateway integrates with Lambda. It forwards each request and sends it to the Lambda function. Lambda creates the Apollo Handler on each invocation (for new containers) and fulfills the request.</p>\n<p>API Gateway and Lambda have both <strong>status codes</strong>. This is where it gets interesting.</p>\n<ul>\n<li><p><strong>API Gateway Status Code:</strong> This is the status code of the receiver of this API (i.e. Stellate) that receives</p>\n</li>\n<li><p><strong>Lambda Integration Status Code</strong>: This is the status code API Gateway receives</p>\n</li>\n</ul>\n<p>This is not necessarily the same status code! There is even a third response status code, which is the response code <strong>by Stellate</strong>. Most of the time (almost always) this mirrors the status code of the API Gateway.</p>\n<p>By using Stellate we were now also aware of all the different error codes our API consumers received.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675431258965/7d951c8f-0c81-4819-9cc4-f797e5e6bf70.png\" alt=\"Different Status Codes by Stellate\" class=\"image--center mx-auto\" /></p>\n<p>That's the reason for this blog post. Let's dive a bit deeper into the errors GraphQL returns to you.</p>\n<h2 id=\"heading-an-overview-of-http-status-codes\">An Overview of HTTP Status Codes</h2>\n<p>GraphQL is still a typical REST call. You make a POST call to an endpoint and you will receive an HTTP response. This response can have several status codes.</p>\n<p>Let's first look over the status codes <strong>briefly</strong>, then focus on some detailed examples and see how Stellate, API Gateway, and Lambda react.</p>\n<h3 id=\"heading-200-ok-or-is-it\">200 - OK, or Is It? ü§î</h3>\n<p>200 in HTTP means the request was <strong>successful</strong>. This is one of the <strong>confusing codes</strong> in GraphQL.</p>\n<p>200 doesn't tell that no error happened. It only means that the request was successful. You still need to check your actual response to see if an error was returned. If an error in your GraphQL API happened it will be visible by having an <code>GRAPHQL_ERROR_CODE</code> in the response body.</p>\n<h3 id=\"heading-400-bad-request\">400 - Bad Request</h3>\n<p>GraphQL APIs are based on a schema. Our schema for a publication for example is the following:</p>\n<pre><code class=\"lang-graphql\">  <span class=\"hljs-keyword\">type</span> Publication <span class=\"hljs-keyword\">implements</span> Node {\n    <span class=\"hljs-symbol\">id:</span> ID!\n    <span class=\"hljs-symbol\">title:</span> String!\n    <span class=\"hljs-punctuation\">...\n</span>}\n</code></pre>\n<p>If you want to access a field that is not implemented in this schema you get an error code 400 - <code>GRAPHQL_VALIDATION_FAILED</code>. 400 in general are validation errors.</p>\n<h3 id=\"heading-500-server-error\">500 - Server Error</h3>\n<p>500 still means server errors. 500 are still <strong>bad errors</strong>. That means you need to check them. They should not happen. But be aware. Understanding where the error actually appeared can be quite a challenge in the beginning.</p>\n<p>500 is a <strong>server error</strong> but what is our server in the architecture? Is it the lambda handler? The Apollo Handler, or anything in between?</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675433481488/6d7b62a8-c1f5-4a5c-bf75-e2c0e25dd263.png\" alt class=\"image--center mx-auto\" /></p>\n<p>The Lambda function has two components:</p>\n<ol>\n<li><p><strong>Lambda Function</strong>: This is everything that happens <strong>before</strong> the Apollo server starts, e.g. connecting to the DB, fetching secrets, etc.</p>\n</li>\n<li><p><strong>Apollo Handler</strong>: This is the Apollo server handling requests.</p>\n</li>\n</ol>\n<p>500 <strong>in our architecture</strong> means there is something wrong with the <strong>Lambda function</strong> itself. This doesn't mean something is wrong with the <strong>Apollo Handler</strong> but with the <strong>Lambda Function</strong>. We will see both examples in the example section.</p>\n<h2 id=\"heading-real-scenarios-lets-see-some-examples\">Real Scenarios - Let's see some Examples</h2>\n<p>Okay, so far the theory. I hope you are still with me. Let's now dig a bit deeper and understand some example scenarios.</p>\n<h3 id=\"heading-successful-request-the-happy-path\">Successful Request - The Happy Path ü§ó</h3>\n<p>A user sends a correct query, for example, this one:</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">query</span> {\n    publication(<span class=\"hljs-symbol\">host:</span><span class=\"hljs-string\">\"jannikwempe.hashnode.net\"</span>) {\n        id\n        author {\n            name\n        }\n    }\n}\n</code></pre>\n<p>Stellate receives this query, and forwards it to API Gateway, API Gateway creates the event and invokes the Lambda function. Lambda queries the database and sends the response back to API Gateway. This is how everything comes together.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675433832056/18008a34-cca8-4a08-9d4b-31d12cd72c4d.png\" alt class=\"image--center mx-auto\" /></p>\n<p>All states are 200 and everything is fine.</p>\n<p>Let's see the example in Postman:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676452245755/1f25e958-80f4-43b8-b51a-5f8245e31802.png\" alt class=\"image--center mx-auto\" /></p>\n<p>We receive the response we expect with the status code we expect üëçüèΩ</p>\n<h3 id=\"heading-error-in-apollo-handler-200-not-ok\">Error in Apollo Handler - 200 NOT OK ‚ùå</h3>\n<p>Now let's see an example of the mysterious 200 response with an error.</p>\n<p>We mock an error by throwing an error from <strong>the Apollo Handler</strong>. Remember, Apollo Handler != Lambda Handler necessarily.</p>\n<p>In the Lambda Handler function we create the Apollo Handler like that:</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> serverHandler: Handler&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> {\n...\n  <span class=\"hljs-keyword\">return</span> server.createHandler()\n...\n};\n</code></pre>\n<p>Everything that happens within the <code>server</code> will be an error <strong>within the handler.</strong> To mock this behavior I've added a <code>throw new Error()</code> somewhere in querying a publication.</p>\n<p>The result looks like that:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675433894562/98f1d799-6b8d-4a85-870a-c4b414d6d85f.png\" alt class=\"image--center mx-auto\" /></p>\n<p>If we are now calling the same query we see the following result:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676452532352/e31f41da-641a-40ba-afe7-bdaa4e94cb18.png\" alt class=\"image--center mx-auto\" /></p>\n<p>For us, this was new. Even for an <strong>undefined</strong> error and a clear <strong>server error,</strong> the API responds with a 200 response code. The actual error code is in the response and maps on the error code <code>INTERNAL_SERVER_ERROR</code>. You can define this behavior of course.</p>\n<p>That is where Stellate is doing a great Job. Without the need of creating any extra logic, Stellate shows us the error in their Error Dashboard:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676452754438/87919f94-7b20-478f-b84b-c23eb6102a78.png\" alt class=\"image--center mx-auto\" /></p>\n<p><strong>Learning from this scenario:</strong> You need to have alerts on 200 response codes like <code>INTERNAL_SERVER_ERRORS</code> as well.</p>\n<h3 id=\"heading-server-error-for-real-andgt-500\">Server Error, for Real -&gt; 500</h3>\n<p>The next scenario we look at is a proper server error. This time not the Apollo Handler but the <strong>Lambda Function itself</strong> throws an undefined error.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453590617/d9d8f0eb-6e51-4eae-b2ed-600717bcf222.png\" alt class=\"image--center mx-auto\" /></p>\n<p>The Lambda function is defined as everything that happens <strong>before</strong> the Apollo server is created. In our scenario, this is mainly connecting to our database and caching the connection in the Lambda context. We are doing this by using the amazing <a target=\"_blank\" href=\"https://middy.js.org/\">middy middleware library</a>.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453319426/a0176449-4ad3-49d4-bf5c-1b6ef4c78dbf.png\" alt class=\"image--center mx-auto\" /></p>\n<p>I introduced an error by throwing an undefined error in the middleware that connects to the DB.</p>\n<p>Let's see what it looks like in Postman:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453490262/0f6b1e64-5758-4baf-94da-0f153f712c29.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Ah, this time we get a proper 500 error code! Which makes sense of course. No GraphQL server started so there is no way to parse errors in a different way than a normal REST API.</p>\n<p>In Stellate it looks like that:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453669536/f3c5d744-ed8f-4499-9bc8-ba2e22f5471e.png\" alt class=\"image--center mx-auto\" /></p>\n<p><strong>Learning from this scenario:</strong> A 500 error means there is something wrong with the underlying \"infrastructure\" which is your Lambda function. This makes debugging a whole lot easier.</p>\n<h3 id=\"heading-get-request-on-stellate-vs-directly-on-api-gateway\">GET Request on Stellate vs. directly on API Gateway</h3>\n<p>GraphQL only uses the HTTP Method <strong>POST</strong> for serving data. As a company with our scale, we see many people trying out our internal APIs as well and trying to come through üïµüèΩ</p>\n<p>Since we'd like to understand how our system behaves in different scenarios we also looked at that one.</p>\n<p>If you send a GET request to the Stellate endpoint you will get the following response: 204 - No Content</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676454196106/01a6de93-a381-48fe-b2fc-688b4ed62f99.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Interestingly enough, if you send the same request <strong>directly to the API Gateway</strong> you will get a 400 response code.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676454225263/42cdda69-97de-4adc-be3d-b587b3c9501d.png\" alt class=\"image--center mx-auto\" /></p>\n<p>The main important thing. Requests like that shouldn't even be able to enter your API.</p>\n<p><strong>Learning from this scenario:</strong> Understand that some response codes behave differently on Stellate and on API GW.</p>\n<h3 id=\"heading-validation-errors\">Validation Errors</h3>\n<p>Now we will look at some validation errors, i.e. 400 error codes. A validation error means that there is something wrong with your query or mutation. While you get 400 as a response code you will also get a GraphQL error code in your response.</p>\n<h4 id=\"heading-access-invalid-field\">Access Invalid Field</h4>\n<p>Let's start by trying to access a field that doesn't exist.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676454571665/62ddeb0d-3327-40b1-b4b4-dec4b559f510.png\" alt class=\"image--center mx-auto\" /></p>\n<p>I try to send the following query to our API:</p>\n<pre><code class=\"lang-graphql\">{\n   publication(<span class=\"hljs-symbol\">host:</span><span class=\"hljs-string\">\"jannikwempe.hashnode.net\"</span>) {\n       id\n       bla\n   }\n}\n</code></pre>\n<p>This will result in a response code 400 -&gt; validation failing.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676465439853/f42eea63-4e8f-4197-b92b-ed06be943c8c.png\" alt class=\"image--center mx-auto\" /></p>\n<p>We receive the error <code>GRAPHQL_VALIDATION_FAILED</code>. So far so good.</p>\n<h4 id=\"heading-type-check-fails\">Type Check Fails</h4>\n<p>Something similar happens if you provide the wrong type. Instead of passing the <code>username</code> as a string, I've added the <code>username</code> as a number here.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676465586589/88cc6908-bf70-4d28-9179-04978ba314d3.png\" alt class=\"image--center mx-auto\" /></p>\n<p>This will also result in the following response</p>\n<pre><code class=\"lang-json\">{\n    <span class=\"hljs-attr\">\"errors\"</span>: [\n        {\n            <span class=\"hljs-attr\">\"message\"</span>: <span class=\"hljs-string\">\"String cannot represent a non string value: 123\"</span>,\n            <span class=\"hljs-attr\">\"extensions\"</span>: {\n                <span class=\"hljs-attr\">\"code\"</span>: <span class=\"hljs-string\">\"GRAPHQL_VALIDATION_FAILED\"</span>,\n            }\n        }\n    ]\n}\n</code></pre>\n<h4 id=\"heading-400-but-a-server-error\">400 but a server error</h4>\n<p>One error that took some while for us to understand was the following one:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676465758320/d59330d4-2a2f-456e-ac2a-d3a7974f7856.png\" alt class=\"image--center mx-auto\" /></p>\n<p>In Stellate we received lots of error messages with the response code 400. But the actual GraphQL error code was <code>INTERNAL_SERVER_ERROR</code>.</p>\n<p>So what now? Validation error because of the response code 400? Or an internal server error? But why isn't that a 200 error then like in the first examples?</p>\n<p>By taking a closer look we saw that none of these exceptions had a query attached. By trying to reproduce it we saw that some people are trying out to send empty queries to our API. This results in a server error with the response code 400.</p>\n<p>Cases like these can be adjusted manually in Apollo. But by default, it behaves like that.</p>\n<p><strong>Learning from this scenario:</strong> Understand that the GraphQL error code is the most important piece to understand. In this case, <code>INTERNAL_SERVER_ERROR</code> is an expected code and nothing is wrong with your server.</p>\n<h3 id=\"heading-playground-deactivated-403-vs-400\">Playground deactivated - 403 vs. 400</h3>\n<p>One last error we faced a lot at times is a 403 error from Stellate:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676466176458/4281a5e9-abbe-42da-98a7-4cae155225c7.png\" alt class=\"image--center mx-auto\" /></p>\n<p>This error indicates that somebody is doing a <code>GET</code> request on our API. But when I tried to reproduce that I got a <code>204 - No Content</code> like seen above. It took some time to understand that this error message results if somebody tries to access a disabled GraphQL playground. When I try to access the <strong>Stellate Playground</strong> I get a 403 Forbidden error.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676466433979/2249a5b1-5b88-43dd-8888-ffb16e4a4ffb.png\" alt class=\"image--center mx-auto\" /></p>\n<p><strong>But</strong> if I try to access the GraphQL Playground directly in Apollo and it is deactivated I get a 400 error.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676466476500/83e0ad24-9a4a-4dbe-b440-9f337fa79c8c.png\" alt class=\"image--center mx-auto\" /></p>\n<p>This is nothing major. It is still important for us to understand the differences. With that, we are able to act on real 403 issues.</p>\n<h2 id=\"heading-summary\">Summary</h2>\n<p>In summary, it is really important to understand the ins and outs of your API. Stellate makes our lives much easier by automatically parsing GraphQL error codes and showing the resulting response codes. In the end, everything is dependent on the implementation of your GraphQL server.</p>\n<p>To be able to act quickly on incidents or abnormal behavior it is critical to understand what each error code and error message actually means. Many errors are expected. Especially in cases like:</p>\n<ul>\n<li><p>Unauthenticated access</p>\n</li>\n<li><p>Validation Errors</p>\n</li>\n</ul>\n<p>But there are also many cases where they are not expected.</p>\n<p>We have created several alarms and in special cases also an automated generation of Incidents (üëãüèΩ Better Uptime) so that we are able to act quickly on all upcoming incidents.</p>\n<p>Thanks for sticking with me, see you soon üëãüèΩ</p>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1676972950688/8f04a52c-e667-49e3-92d4-480f990013f6.png"}}},"__N_SSG":true}