{"pageProps":{"post":{"slug":"how-hashnode-is-using-rate-limits-on-stellate","url":"https://engineering.hashnode.com/how-hashnode-is-using-rate-limits-on-stellate","brief":"Rate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.\nImplementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazo...","title":"How Hashnode is using Rate Limits on Stellate","publishedAt":"2023-05-10T15:00:34.500Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683620384065/c2fc7e7d-8803-43b5-8fe9-fb80adb13552.png"},"author":{"name":"Sandro Volpicella","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg"},"id":"645bb1927c65daa656f54d96","content":{"markdown":"Rate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.\n\nImplementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazon WAF. But limiting requests based on other user identifiers such as user IDs in JWTs or authorization headers can get quite tricky.\n\nThat is where Stellate comes to the rescue ü¶∏üèΩ\n\n## Our Architecture\n\nA small primer to our architecture and all involved parts:\n\n![Overall Architecture of Hashnode](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692856042/5d6a29e2-7910-4898-ba13-e5c376865343.png align=\"center\")\n\nWe have two methods of accessing our API: either through **client calls** or via **server-side-rendered** calls from Vercel. Both pass through Stellate's Edge Cache and now also utilize their rate-limiting feature. Following this, we make calls to the API Gateway on AWS.\n\n## Why not only IP?\n\nThe first question we mostly got about rate limits is: **Why don't you only rate limit on IP?**\n\nWhile it makes sense to rate limit on the IP address it often is a misleading identifier. Due to the shortage of IPs, many mobile carriers or internet providers share the IP across several zones. Also, universities, dorms, and companies are often using the same IP. If we would rate limit this one IP the whole university couldn't access Hashnode anymore. This is not what we want.\n\n## Why Rate Limits?\n\nThere are mainly two reasons why we need rate limits.\n\n### Impact on the Database\n\nFirst of all, we want to secure our database. You don't want people to be able to hit your database constantly. This will incur costs and can lead to downtime.\n\nYes, caching is the number one thing to consider here. Stellate & Vercel are helping us with that already. But rate limits also help by ensuring that nobody bombards your API. Everything that isn't cached (e.g. `Mutations` ) hits the DB directly. We want to avoid that.\n\n### Impact on your Business\n\nThe second reason is, you simply don't want that your product gets abused. We don't want an automatic generation of posts running in a script.\n\nWe need rate limits to ensure that nobody abuses our API and impacts the database.\n\n## Stellate Rate Limiting\n\n[Stellate](https://hshno.de/FEuPQqw) is a CDN for GraphQL. It mainly offers the functionality of:\n\n1. Caching GQL Requests on the Edge\n    \n2. Analytics and errors about your API\n    \n3. **Rate Limiting**\n    \n\nThe rate-limiting feature is currently in its public beta phase. Check out their [docs](https://stellate.co/docs/graphql-rate-limiting) for more information.\n\nTo enable rate limits you can simply add the `rateLimits` field to your Stellate config file (with TypeScript support! üòâ):\n\n```typescript\nimport { Config } from 'stellate'\n\nconst config: Config = {\n  config: {\n    rateLimits: [\n      {\n        name: 'IP limit',\n        groupBy: 'ip',\n        state: 'dryRun',\n        limit: {\n          type: 'RequestCount',\n          window: '1m',\n          budget: 50,\n        },\n      },\n    ],\n  },\n}\nexport default config\n```\n\nThe code above creates a rate limit of 50 requests for every minute. The state `dryRun` means that this rate limit is not really available. Your dashboard will only show you which requests **would be blocked** but they won't be blocked.\n\n### Dry Run\n\nThe dry run mode in Stellate is an excellent feature for gaining a better understanding of the appropriate rate limit. Once you've activated it you can head over to your Stellate Dashboard, check the rate limiting dashboard, and see how many requests and customers would have been blocked. But no request will be blocked.\n\n![Dashboard for rate limits in Stellate](https://cdn.hashnode.com/res/hashnode/image/upload/v1683730304530/43f124fa-0c60-45cd-ad65-349c519b54c1.png align=\"center\")\n\nYou can also send requests from the Stellate playground or from the API Client of your choice (cURL, Postman, Insomnia) and check the remaining budget.\n\nIn this example, I query my blog. In the result window on the right, I can see that the rule \"Unatuehtnicated IP Limit - Request Count\" was applied. I have 1998 of 2000 requests remaining.\n\n![a screenshot of a computer screen with a code on it](https://cdn.hashnode.com/res/hashnode/image/upload/v1683730422729/8174681d-0f43-4ab7-84bd-8718c7c40f7d.png align=\"center\")\n\n## Rate Limits\n\nSo far the introduction. But how do we use rate limits at Hashnode? We distinguish mainly from two different limits:\n\n1. Authenticated access\n    \n2. Unauthenticated access\n    \n\n### Authenticated Access\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692491128/f9e5c284-f05a-4b31-b94b-b7864fef5352.png align=\"center\")\n\nAuthenticated access is everything where a token in a cookie or header is present. If this token is present we create a limit of 500 requests per minute.\n\n```typescript\n{\n  name: 'Authenticated User Limit - Request Count',\n  groupBy: req.headers['token'],\n  state: 'enabled',\n  limit: {\n    type: 'RequestCount',\n    budget: 500,\n    window: '1m'\n  }\n}\n```\n\nThis defines that each header `token` will have a limit of 500 requests per minute. To test this out you can also make use of Stellate's dashboard.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682686423313/c4a810dd-7ca7-4708-94e2-e0ff09c4588e.png align=\"center\")\n\nHere we query my personal blog and access the `title`. At the bottom of the result, we can see the remaining limit. In this case, we have 499 of 500 requests left.\n\n### Unauthenticated Access\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692472212/9ce5d2c0-7b0b-4f76-a9d2-3859d67978bf.png align=\"center\")\n\nUnauthenticated access, on the other hand, is everything without an authentication token. In this case we group by the IP address of the user. This limit has 2000 requests per minute.\n\n**Why is this limit larger?**\n\nFirst of all, unauthenticated requests are typically *cheaper* in terms of computational costs. Querying a blog vs. creating a blog is a huge difference.\n\nThe second reason is the reason of IP sharing. We saw a lot of cases in that IPs are shared. If this is the case we don't want to have a too tight budget. This is why we allow quite a bit more room for unauthenticated access.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682686578720/b13b1d39-bc37-444e-92a1-2247ef026486.png align=\"center\")\n\n## Rate Limits & Server-Side Rendering\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692505588/6c5f97dd-f5b1-44af-ae8a-487ac4da319a.png align=\"center\")\n\nHashnode makes heavy usage of Vercel and Server-Side Rendering (SSR). The problem with SSR & Rate limiting is that many customers can visit blogs that will be server-side rendered from the same server. This will then come from the same IP address.\n\nThere are separate solutions to take care of that:\n\n1. Ignore SSR for rate limits\n    \n2. Forward the public IP & authorization header (if present) to Stellate.\n    \n3. (New) With [Vercel Secure Compute](https://hshno.de/jRSvsUN) assign a fixed IP to Vercel and whitelist this one\n    \n\nWe opted for the first solution, ignoring all SSR calls. We primarily chose this option because we wanted to address rate limiting for the API. This is also a preparatory step for making our API publicly available. It is not specifically intended to rate limit the client's usage.\n\nYou can do that by defining a secret between Vercel & Stellate. This secret can for example be a header you'll forward to each API Requests.\n\n> ‚ö†Ô∏è Be aware that this header needs to be treated as a secret. You can only send it from the server side **not** from the client side.\n\nIn Stellate you can then define the following:\n\n```typescript\n      if (\n        req.headers['ssr-call'] &&\n        req.headers['ssr-call'] === \"123\"\n      ) {\n        return [];\n      }\n```\n\nThis will return no rate limit in case the call is coming from Vercel.\n\n## Block IPs\n\nOne more remarkable feature is the ability to block individual IP addresses. Unfortunately, we face attacks quite frequently. Often, these attacks originate from a single IP address. Blocking such an IP address using rate limits is incredibly simple:\n\n```typescript\n      if (ipListToBlock.includes(req.ip)) {\n        return [\n          {\n            name: 'Blocked IP limit',\n            groupBy: 'ip',\n            state: 'enabled',\n            limit: {\n              type: 'RequestCount',\n              budget: 0,\n              window: '1m'\n            }\n          }\n        ];\n      }\n```\n\n## That's it üéâ\n\nThat is all about rate limits.\n\nIt already saved us from a huge abusive spike in traffic to our API and it is super easy to implement!","html":"<p>Rate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.</p>\n<p>Implementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazon WAF. But limiting requests based on other user identifiers such as user IDs in JWTs or authorization headers can get quite tricky.</p>\n<p>That is where Stellate comes to the rescue ü¶∏üèΩ</p>\n<h2 id=\"heading-our-architecture\">Our Architecture</h2>\n<p>A small primer to our architecture and all involved parts:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692856042/5d6a29e2-7910-4898-ba13-e5c376865343.png\" alt=\"Overall Architecture of Hashnode\" class=\"image--center mx-auto\" /></p>\n<p>We have two methods of accessing our API: either through <strong>client calls</strong> or via <strong>server-side-rendered</strong> calls from Vercel. Both pass through Stellate's Edge Cache and now also utilize their rate-limiting feature. Following this, we make calls to the API Gateway on AWS.</p>\n<h2 id=\"heading-why-not-only-ip\">Why not only IP?</h2>\n<p>The first question we mostly got about rate limits is: <strong>Why don't you only rate limit on IP?</strong></p>\n<p>While it makes sense to rate limit on the IP address it often is a misleading identifier. Due to the shortage of IPs, many mobile carriers or internet providers share the IP across several zones. Also, universities, dorms, and companies are often using the same IP. If we would rate limit this one IP the whole university couldn't access Hashnode anymore. This is not what we want.</p>\n<h2 id=\"heading-why-rate-limits\">Why Rate Limits?</h2>\n<p>There are mainly two reasons why we need rate limits.</p>\n<h3 id=\"heading-impact-on-the-database\">Impact on the Database</h3>\n<p>First of all, we want to secure our database. You don't want people to be able to hit your database constantly. This will incur costs and can lead to downtime.</p>\n<p>Yes, caching is the number one thing to consider here. Stellate &amp; Vercel are helping us with that already. But rate limits also help by ensuring that nobody bombards your API. Everything that isn't cached (e.g. <code>Mutations</code> ) hits the DB directly. We want to avoid that.</p>\n<h3 id=\"heading-impact-on-your-business\">Impact on your Business</h3>\n<p>The second reason is, you simply don't want that your product gets abused. We don't want an automatic generation of posts running in a script.</p>\n<p>We need rate limits to ensure that nobody abuses our API and impacts the database.</p>\n<h2 id=\"heading-stellate-rate-limiting\">Stellate Rate Limiting</h2>\n<p><a target=\"_blank\" href=\"https://hshno.de/FEuPQqw\">Stellate</a> is a CDN for GraphQL. It mainly offers the functionality of:</p>\n<ol>\n<li><p>Caching GQL Requests on the Edge</p>\n</li>\n<li><p>Analytics and errors about your API</p>\n</li>\n<li><p><strong>Rate Limiting</strong></p>\n</li>\n</ol>\n<p>The rate-limiting feature is currently in its public beta phase. Check out their <a target=\"_blank\" href=\"https://stellate.co/docs/graphql-rate-limiting\">docs</a> for more information.</p>\n<p>To enable rate limits you can simply add the <code>rateLimits</code> field to your Stellate config file (with TypeScript support! üòâ):</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">import</span> { Config } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'stellate'</span>\n\n<span class=\"hljs-keyword\">const</span> config: Config = {\n  config: {\n    rateLimits: [\n      {\n        name: <span class=\"hljs-string\">'IP limit'</span>,\n        groupBy: <span class=\"hljs-string\">'ip'</span>,\n        state: <span class=\"hljs-string\">'dryRun'</span>,\n        limit: {\n          <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'RequestCount'</span>,\n          <span class=\"hljs-built_in\">window</span>: <span class=\"hljs-string\">'1m'</span>,\n          budget: <span class=\"hljs-number\">50</span>,\n        },\n      },\n    ],\n  },\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> config\n</code></pre>\n<p>The code above creates a rate limit of 50 requests for every minute. The state <code>dryRun</code> means that this rate limit is not really available. Your dashboard will only show you which requests <strong>would be blocked</strong> but they won't be blocked.</p>\n<h3 id=\"heading-dry-run\">Dry Run</h3>\n<p>The dry run mode in Stellate is an excellent feature for gaining a better understanding of the appropriate rate limit. Once you've activated it you can head over to your Stellate Dashboard, check the rate limiting dashboard, and see how many requests and customers would have been blocked. But no request will be blocked.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683730304530/43f124fa-0c60-45cd-ad65-349c519b54c1.png\" alt=\"Dashboard for rate limits in Stellate\" class=\"image--center mx-auto\" /></p>\n<p>You can also send requests from the Stellate playground or from the API Client of your choice (cURL, Postman, Insomnia) and check the remaining budget.</p>\n<p>In this example, I query my blog. In the result window on the right, I can see that the rule \"Unatuehtnicated IP Limit - Request Count\" was applied. I have 1998 of 2000 requests remaining.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683730422729/8174681d-0f43-4ab7-84bd-8718c7c40f7d.png\" alt=\"a screenshot of a computer screen with a code on it\" class=\"image--center mx-auto\" /></p>\n<h2 id=\"heading-rate-limits\">Rate Limits</h2>\n<p>So far the introduction. But how do we use rate limits at Hashnode? We distinguish mainly from two different limits:</p>\n<ol>\n<li><p>Authenticated access</p>\n</li>\n<li><p>Unauthenticated access</p>\n</li>\n</ol>\n<h3 id=\"heading-authenticated-access\">Authenticated Access</h3>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692491128/f9e5c284-f05a-4b31-b94b-b7864fef5352.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Authenticated access is everything where a token in a cookie or header is present. If this token is present we create a limit of 500 requests per minute.</p>\n<pre><code class=\"lang-typescript\">{\n  name: <span class=\"hljs-string\">'Authenticated User Limit - Request Count'</span>,\n  groupBy: req.headers[<span class=\"hljs-string\">'token'</span>],\n  state: <span class=\"hljs-string\">'enabled'</span>,\n  limit: {\n    <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'RequestCount'</span>,\n    budget: <span class=\"hljs-number\">500</span>,\n    <span class=\"hljs-built_in\">window</span>: <span class=\"hljs-string\">'1m'</span>\n  }\n}\n</code></pre>\n<p>This defines that each header <code>token</code> will have a limit of 500 requests per minute. To test this out you can also make use of Stellate's dashboard.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682686423313/c4a810dd-7ca7-4708-94e2-e0ff09c4588e.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Here we query my personal blog and access the <code>title</code>. At the bottom of the result, we can see the remaining limit. In this case, we have 499 of 500 requests left.</p>\n<h3 id=\"heading-unauthenticated-access\">Unauthenticated Access</h3>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692472212/9ce5d2c0-7b0b-4f76-a9d2-3859d67978bf.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Unauthenticated access, on the other hand, is everything without an authentication token. In this case we group by the IP address of the user. This limit has 2000 requests per minute.</p>\n<p><strong>Why is this limit larger?</strong></p>\n<p>First of all, unauthenticated requests are typically <em>cheaper</em> in terms of computational costs. Querying a blog vs. creating a blog is a huge difference.</p>\n<p>The second reason is the reason of IP sharing. We saw a lot of cases in that IPs are shared. If this is the case we don't want to have a too tight budget. This is why we allow quite a bit more room for unauthenticated access.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682686578720/b13b1d39-bc37-444e-92a1-2247ef026486.png\" alt class=\"image--center mx-auto\" /></p>\n<h2 id=\"heading-rate-limits-andamp-server-side-rendering\">Rate Limits &amp; Server-Side Rendering</h2>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692505588/6c5f97dd-f5b1-44af-ae8a-487ac4da319a.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Hashnode makes heavy usage of Vercel and Server-Side Rendering (SSR). The problem with SSR &amp; Rate limiting is that many customers can visit blogs that will be server-side rendered from the same server. This will then come from the same IP address.</p>\n<p>There are separate solutions to take care of that:</p>\n<ol>\n<li><p>Ignore SSR for rate limits</p>\n</li>\n<li><p>Forward the public IP &amp; authorization header (if present) to Stellate.</p>\n</li>\n<li><p>(New) With <a target=\"_blank\" href=\"https://hshno.de/jRSvsUN\">Vercel Secure Compute</a> assign a fixed IP to Vercel and whitelist this one</p>\n</li>\n</ol>\n<p>We opted for the first solution, ignoring all SSR calls. We primarily chose this option because we wanted to address rate limiting for the API. This is also a preparatory step for making our API publicly available. It is not specifically intended to rate limit the client's usage.</p>\n<p>You can do that by defining a secret between Vercel &amp; Stellate. This secret can for example be a header you'll forward to each API Requests.</p>\n<blockquote>\n<p>‚ö†Ô∏è Be aware that this header needs to be treated as a secret. You can only send it from the server side <strong>not</strong> from the client side.</p>\n</blockquote>\n<p>In Stellate you can then define the following:</p>\n<pre><code class=\"lang-typescript\">      <span class=\"hljs-keyword\">if</span> (\n        req.headers[<span class=\"hljs-string\">'ssr-call'</span>] &amp;&amp;\n        req.headers[<span class=\"hljs-string\">'ssr-call'</span>] === <span class=\"hljs-string\">\"123\"</span>\n      ) {\n        <span class=\"hljs-keyword\">return</span> [];\n      }\n</code></pre>\n<p>This will return no rate limit in case the call is coming from Vercel.</p>\n<h2 id=\"heading-block-ips\">Block IPs</h2>\n<p>One more remarkable feature is the ability to block individual IP addresses. Unfortunately, we face attacks quite frequently. Often, these attacks originate from a single IP address. Blocking such an IP address using rate limits is incredibly simple:</p>\n<pre><code class=\"lang-typescript\">      <span class=\"hljs-keyword\">if</span> (ipListToBlock.includes(req.ip)) {\n        <span class=\"hljs-keyword\">return</span> [\n          {\n            name: <span class=\"hljs-string\">'Blocked IP limit'</span>,\n            groupBy: <span class=\"hljs-string\">'ip'</span>,\n            state: <span class=\"hljs-string\">'enabled'</span>,\n            limit: {\n              <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-string\">'RequestCount'</span>,\n              budget: <span class=\"hljs-number\">0</span>,\n              <span class=\"hljs-built_in\">window</span>: <span class=\"hljs-string\">'1m'</span>\n            }\n          }\n        ];\n      }\n</code></pre>\n<h2 id=\"heading-thats-it\">That's it üéâ</h2>\n<p>That is all about rate limits.</p>\n<p>It already saved us from a huge abusive spike in traffic to our API and it is super easy to implement!</p>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683620389317/7a63a71e-63ea-4afe-afbf-44e7258996e6.png"}}},"__N_SSG":true}