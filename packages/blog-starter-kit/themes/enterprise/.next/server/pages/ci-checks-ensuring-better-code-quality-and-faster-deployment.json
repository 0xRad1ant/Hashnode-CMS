{"pageProps":{"post":{"slug":"ci-checks-ensuring-better-code-quality-and-faster-deployment","url":"https://engineering.hashnode.com/ci-checks-ensuring-better-code-quality-and-faster-deployment","brief":"How can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?The solution lies in implementing tests and multiple checks for linting and type errors.\nThis may seem straightforward, but it re...","title":"CI Checks: Ensuring Better Code Quality and Faster Deployment","publishedAt":"2023-08-10T07:30:09.875Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1691493522714/21672c1e-1f26-42a0-8ead-93f87f8211de.png"},"author":{"name":"Shad Mirza","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1663070035311/JaSbIMfve.jpg"},"id":"64d492016f3feecb8702c3b4","content":{"markdown":"How can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?  \nThe solution lies in implementing tests and multiple checks for linting and type errors.\n\nThis may seem straightforward, but it requires some adjustments to smooth out the developer experience (DX) flow and maintain developer productivity.\n\nIn this article, we'll explore how Hashnode previously managed its development workflow and the improvements it made to ensure better code quality and faster deployment through CI checks.\n\n## Goal\n\nThe goal is to establish a rapid feedback loop for developers, allowing them the freedom to experiment and move fast without being burdened by coding guidelines and the like.\n\nOf course, we still aim to enforce coding guidelines and ensure that whatever reaches production is error-free and passes all checks. However, we want to accomplish this without hindering developer productivity and utilize tools at our disposal.\n\n## Previous Workflow\n\nThe previous workflow involved running each check on the developer's machine before they commit using pre-commit hooks. This involved enforcing coding guidelines, format commit messages and a bunch of other checks.\n\nThese guidelines were necessary but enforcing them at the pre-commit level was not a great idea. Developers should be allowed to code how they want and this was hurting the productivity.  \nLet's take a look at the different checks we had at the commit level.\n\n### Type Checks\n\nWe use TypeScript heavily to ensure the data types used in a codebase align with the expected types and catch potential errors or inconsistencies early in the development process. Usually, the IDE takes care of complaining whenever a certain function or component doesn't satisfy the types it was supposed to.\n\nHowever, it is easy to overlook these warnings for pages that are out of the scope of the feature in development.\n\nFor this reason, it is necessary to perform type checks for every commit to guarantee that no issues arise throughout the codebase. This can be accomplished by using:\n\n```bash\ntsc --noEmit\n```\n\nThis simple command will execute a type check on the entire codebase and generate an error if any issues are detected.\n\n### Linting\n\nWe use ESLint to enforce coding guidelines, ensuring that everything is in order. It also enforces aspects such as import order and accessibility checklists. To run lint checks on the relevant files, use the following command:\n\n```bash\neslint . --fix --ext .js,.jsx,.ts,.tsx\n```\n\nThese are plugins that we use at Hashnode\n\n```json\n{\n    \"eslint\": \"^7.24.0\",\n    \"eslint-config-airbnb\": \"^18.2.1\",\n    \"eslint-config-airbnb-base\": \"^14.2.1\",\n    \"eslint-config-next\": \"13.0.5\",\n    \"eslint-config-prettier\": \"^8.3.0\",\n    \"eslint-import-resolver-typescript\": \"^2.4.0\",\n    \"eslint-plugin-cypress\": \"^2.11.3\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"eslint-plugin-jsx-a11y\": \"^6.4.1\",\n    \"eslint-plugin-prettier\": \"^3.4.0\",\n    \"eslint-plugin-react\": \"^7.23.2\",\n    \"eslint-plugin-react-hooks\": \"^4.2.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.39.0\",\n}\n```\n\n### Tests\n\nWe use React Testing Library to write tests for all critical business flows. These tests run on GitHub Actions and report any issues if something is broken. We also have merge rules in place for pull requests, ensuring that only tested code is allowed to merge and proceed to production.\n\n### Husky\n\n[Husky](https://typicode.github.io/husky/) is a pre-commit hook that ties everything together. We configured Husky to perform type checks and lint checks on every commit. This ensures that we only commit error-free code and block pushes if something is broken. Since tests take some time to run, we decided to keep tests at the CI level and not run them locally for every commit.\n\n## The Problem\n\nAll of this is excellent and has been working effectively; however, there was a problem. As the codebase began to expand, running all these checks took between 3 to 6 minutes. This negatively impacted the DX, as developers had to wait for all the checks to pass before they could commit any changes.\n\nHaving checks at the commit level also impacted the freedom to experiment without worrying about formatting guidelines or perfect type usage. Ultimately, what gets merged into production is what matters most.\n\nIf you're looking for arguments against pre-commit hooks, this serves as a good example.\n\n%[https://www.youtube.com/watch?v=RAelLqnnOp0] \n\nHashnode believes in moving fast and iterating rapidly but this was hurting our ability to move fast. We had to do something about it.  \nLet's take a look at how we improved our development workflow.\n\n## Optimizations to Speed Up Checks\n\nWe began considering ways to enhance our workflow, and several ideas emerged. One aspect we were certain about was the necessity to stop running these checks locally and transition everything to CI.\n\nWe need to take advantage of the tools at our disposal as much as we can and eliminate manual work. Let's talk about the improvements one at a time.\n\n### Moving Checks to CI\n\nWe already had a GitHub workflow in place for running tests on CI using GitHub actions; we expanded it to include type and lint checks.\n\nWe wanted to run these checks concurrently, so we utilized [jobs within the workflow](https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow) as a solution. This approach allowed us not to wait for one job to finish before starting another, enabling all three checks to run simultaneously. Let's examine the expanded workflow designed to execute these jobs concurrently.\n\n```yaml\nname: PR Validation\n\non:\n  pull_request:\n    types: [opened, reopened, synchronize, ready_for_review]\n    branches:\n      - development\n      - main\n\njobs:\n  cypress-run:\n    if: github.event.pull_request.draft == false\n    runs-on: ubuntu-latest\n    env:\n      NODE_ENV: test\n    steps:\n      #...steps\n  type-check:\n      #...checkout repo and install dependencies\n      - name: Type checking\n        run: tsc --no-Emit\n  lint-check:\n      #...checkout repo and install dependencies\n      - name: Linting\n        run: eslint . --fix --ext .js,.jsx,.ts,.tsx\n```\n\nNow, we have three jobs running concurrently for tests, lint errors, and type errors.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050575992/ffa86ea0-a32e-4c96-8ca9-186ce1101015.png align=\"center\")\n\nYou might be wondering, what about catching errors during development to prevent pushing them in the first place?\n\nOur IDEs are intelligent enough to detect these errors as we develop features, so we don't need to constantly check everything. The objective is to allow the merging of code only if it passes all checks in place, which can happen at the CI level.\n\nAfter moving all the checks to the CI, we removed Husky and developers were allowed to push as they deemed appropriate. We will simply block the merging of pull requests if any issues arise.\n\nThis was an improvement over the previous approach, but we still have more work to do.\n\nMachines running workflows are slower than our Macs, so checks performed on the CI are inevitably slower than when we run them locally.\n\nRunning all three checks on the CI took between 9 and 12 minutes. This meant that developers had to wait for 9 to 12 minutes before they could merge their pull requests. There is certainly room for improvement in this workflow.\n\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">ðŸš€</div>\n<div data-node-type=\"callout-text\">These checks happen at every commit as soon as you raise a pull request (which is not in draft). This workflow will run anytime a pull request is opened, reopened, synchronized or marked as ready for review for the development or main branches as base branch.</div>\n</div>\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691493604969/6d51d96c-b8bd-44d7-bf5b-155545d01cb1.png align=\"center\")\n\n### Lint Staged Files in GitHub Actions\n\nOne quick improvement we could make is to run lint checks only for the files that have been changed, and that's where Lint-staged comes in handy.\n\nLint-staged typically works in conjunction with a pre-commit hook, such as Husky, to run lint checks on staged files only. However, we can modify it to run within a CI environment and focus solely on the files that have changed between commits. Let's replace the lint step in the workflow with this approach:\n\n```yaml\n- name: Linting\n   run: yarn lint-staged --diff=\"origin/${GITHUB_BASE_REF}...origin/${GITHUB_HEAD_REF}\" --no-stash\n```\n\nThis command calculates the difference between your branch and the base branch and then runs ESLint on it. This minor adjustment reduced the lint check duration from 30 seconds to 6 seconds.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050559924/c6cb39eb-7e47-4167-84f2-a3b3fb4ed947.png align=\"center\")\n\n### Skipping Library Check for TypeScript\n\nType checking, due to its nature, must run on the entire codebase, so there isn't much we can do to optimize it. However, we can skip the library check to make it slightly faster. To do this, replace the type check with the following:\n\n```yaml\n- name: Type checking\n   run: tsc --pretty --skipLibCheck --noEmit\n```\n\nNow that we've improved all the checks individually, it's time to cache whatever we can. Let's see how to cache the installation of dependencies for each job.\n\n### Caching Node Modules\n\nSince the three jobs run in parallel, they each need to install dependencies, which can be time-consuming. We've updated the workflow to cache dependencies and modified the \"Installing dependency\" step to skip when the cache is available. This can be achieved as follows:\n\n```yaml\n- name: Get yarn cache directory path\n    id: yarn-cache-dir-path\n    run: echo \"dir=$(yarn cache dir)\" >> $GITHUB_OUTPUT\n- uses: actions/cache@v3\n    id: yarn-cache\n    with:\n        path: |\n            **/node_modules\n            **/.eslintcache\n            ${{ steps.yarn-cache-dir-path.outputs.dir }}\n        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}\n        restore-keys: |\n            ${{ runner.os }}-yarn-\n- name: Install dependencies\n    if: steps.yarn-cache.outputs.cache-hit != 'true'\n    run: yarn install --frozen-lockfile\n```\n\nWe include this for all jobs and retrieve `node_modules` from the cache when available. This significantly improved the time required to complete the entire check.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050813498/b16c02d4-f08b-4cfb-b071-4e249bc6a6d6.png align=\"center\")\n\nWe are already in good shape, but there is one more improvement we can add.\n\n### Removing Checks from Vercel\n\nVercel builds typically perform linting and type error checks by default. This causes the entire build process to take approximately 8 minutes.\n\nSince we already perform error checks on our end, there's no need to repeat them during builds. The final step is to bypass these checks in Vercel builds. We implemented this in `vercel.config.js`:\n\n```javascript\n  eslint: {\n    ignoreDuringBuilds: true,\n  },\n  typescript: {\n    ignoreBuildErrors: true,\n  },\n```\n\nYou can check [Vercel Docs](https://nextjs.org/docs/app/api-reference/next-config-js) for the config specification.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1691050886193/2e1e3ec1-cc4a-4247-9f07-161733b166a0.png align=\"center\")\n\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">ðŸ’»</div>\n<div data-node-type=\"callout-text\">Developers have the freedom to set up pre-commit hooks locally if they prefer. If they believe it enhances their workflow, they should be allowed to do so. By shifting checks to the CI, we ensure that we don't impose any opinions on how developers should work, granting them the liberty to proceed as they see fit.</div>\n</div>\n\n## Conclusion\n\nBy adding all the necessary improvements we discussed above, we were able to reduce the time required to merge a pull request from 12 minutes to 5 minutes. This improved both the developer experience and the overall deployment process.\n\nHere's the summary of the improvements we added:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1690953115674/409ed5a5-4266-499a-86a5-f99e663eb941.png align=\"center\")\n\nI hope this article was informative and you learned something new today ðŸ˜„.\n\nDo you think we can improve it further? Let us know in the comments.","html":"<p>How can you consistently deliver high-quality code that adheres to established coding guidelines and is free from errors?<br />The solution lies in implementing tests and multiple checks for linting and type errors.</p>\n<p>This may seem straightforward, but it requires some adjustments to smooth out the developer experience (DX) flow and maintain developer productivity.</p>\n<p>In this article, we'll explore how Hashnode previously managed its development workflow and the improvements it made to ensure better code quality and faster deployment through CI checks.</p>\n<h2 id=\"heading-goal\">Goal</h2>\n<p>The goal is to establish a rapid feedback loop for developers, allowing them the freedom to experiment and move fast without being burdened by coding guidelines and the like.</p>\n<p>Of course, we still aim to enforce coding guidelines and ensure that whatever reaches production is error-free and passes all checks. However, we want to accomplish this without hindering developer productivity and utilize tools at our disposal.</p>\n<h2 id=\"heading-previous-workflow\">Previous Workflow</h2>\n<p>The previous workflow involved running each check on the developer's machine before they commit using pre-commit hooks. This involved enforcing coding guidelines, format commit messages and a bunch of other checks.</p>\n<p>These guidelines were necessary but enforcing them at the pre-commit level was not a great idea. Developers should be allowed to code how they want and this was hurting the productivity.<br />Let's take a look at the different checks we had at the commit level.</p>\n<h3 id=\"heading-type-checks\">Type Checks</h3>\n<p>We use TypeScript heavily to ensure the data types used in a codebase align with the expected types and catch potential errors or inconsistencies early in the development process. Usually, the IDE takes care of complaining whenever a certain function or component doesn't satisfy the types it was supposed to.</p>\n<p>However, it is easy to overlook these warnings for pages that are out of the scope of the feature in development.</p>\n<p>For this reason, it is necessary to perform type checks for every commit to guarantee that no issues arise throughout the codebase. This can be accomplished by using:</p>\n<pre><code class=\"lang-bash\">tsc --noEmit\n</code></pre>\n<p>This simple command will execute a type check on the entire codebase and generate an error if any issues are detected.</p>\n<h3 id=\"heading-linting\">Linting</h3>\n<p>We use ESLint to enforce coding guidelines, ensuring that everything is in order. It also enforces aspects such as import order and accessibility checklists. To run lint checks on the relevant files, use the following command:</p>\n<pre><code class=\"lang-bash\">eslint . --fix --ext .js,.jsx,.ts,.tsx\n</code></pre>\n<p>These are plugins that we use at Hashnode</p>\n<pre><code class=\"lang-json\">{\n    <span class=\"hljs-attr\">\"eslint\"</span>: <span class=\"hljs-string\">\"^7.24.0\"</span>,\n    <span class=\"hljs-attr\">\"eslint-config-airbnb\"</span>: <span class=\"hljs-string\">\"^18.2.1\"</span>,\n    <span class=\"hljs-attr\">\"eslint-config-airbnb-base\"</span>: <span class=\"hljs-string\">\"^14.2.1\"</span>,\n    <span class=\"hljs-attr\">\"eslint-config-next\"</span>: <span class=\"hljs-string\">\"13.0.5\"</span>,\n    <span class=\"hljs-attr\">\"eslint-config-prettier\"</span>: <span class=\"hljs-string\">\"^8.3.0\"</span>,\n    <span class=\"hljs-attr\">\"eslint-import-resolver-typescript\"</span>: <span class=\"hljs-string\">\"^2.4.0\"</span>,\n    <span class=\"hljs-attr\">\"eslint-plugin-cypress\"</span>: <span class=\"hljs-string\">\"^2.11.3\"</span>,\n    <span class=\"hljs-attr\">\"eslint-plugin-import\"</span>: <span class=\"hljs-string\">\"^2.22.1\"</span>,\n    <span class=\"hljs-attr\">\"eslint-plugin-jsx-a11y\"</span>: <span class=\"hljs-string\">\"^6.4.1\"</span>,\n    <span class=\"hljs-attr\">\"eslint-plugin-prettier\"</span>: <span class=\"hljs-string\">\"^3.4.0\"</span>,\n    <span class=\"hljs-attr\">\"eslint-plugin-react\"</span>: <span class=\"hljs-string\">\"^7.23.2\"</span>,\n    <span class=\"hljs-attr\">\"eslint-plugin-react-hooks\"</span>: <span class=\"hljs-string\">\"^4.2.0\"</span>,\n    <span class=\"hljs-attr\">\"@typescript-eslint/eslint-plugin\"</span>: <span class=\"hljs-string\">\"^5.39.0\"</span>,\n}\n</code></pre>\n<h3 id=\"heading-tests\">Tests</h3>\n<p>We use React Testing Library to write tests for all critical business flows. These tests run on GitHub Actions and report any issues if something is broken. We also have merge rules in place for pull requests, ensuring that only tested code is allowed to merge and proceed to production.</p>\n<h3 id=\"heading-husky\">Husky</h3>\n<p><a target=\"_blank\" href=\"https://typicode.github.io/husky/\">Husky</a> is a pre-commit hook that ties everything together. We configured Husky to perform type checks and lint checks on every commit. This ensures that we only commit error-free code and block pushes if something is broken. Since tests take some time to run, we decided to keep tests at the CI level and not run them locally for every commit.</p>\n<h2 id=\"heading-the-problem\">The Problem</h2>\n<p>All of this is excellent and has been working effectively; however, there was a problem. As the codebase began to expand, running all these checks took between 3 to 6 minutes. This negatively impacted the DX, as developers had to wait for all the checks to pass before they could commit any changes.</p>\n<p>Having checks at the commit level also impacted the freedom to experiment without worrying about formatting guidelines or perfect type usage. Ultimately, what gets merged into production is what matters most.</p>\n<p>If you're looking for arguments against pre-commit hooks, this serves as a good example.</p>\n<div class=\"embed-wrapper\"><div class=\"embed-loading\"><div class=\"loadingRow\"></div><div class=\"loadingRow\"></div></div><a class=\"embed-card\" href=\"https://www.youtube.com/watch?v=RAelLqnnOp0\">https://www.youtube.com/watch?v=RAelLqnnOp0</a></div>\n<p> </p>\n<p>Hashnode believes in moving fast and iterating rapidly but this was hurting our ability to move fast. We had to do something about it.<br />Let's take a look at how we improved our development workflow.</p>\n<h2 id=\"heading-optimizations-to-speed-up-checks\">Optimizations to Speed Up Checks</h2>\n<p>We began considering ways to enhance our workflow, and several ideas emerged. One aspect we were certain about was the necessity to stop running these checks locally and transition everything to CI.</p>\n<p>We need to take advantage of the tools at our disposal as much as we can and eliminate manual work. Let's talk about the improvements one at a time.</p>\n<h3 id=\"heading-moving-checks-to-ci\">Moving Checks to CI</h3>\n<p>We already had a GitHub workflow in place for running tests on CI using GitHub actions; we expanded it to include type and lint checks.</p>\n<p>We wanted to run these checks concurrently, so we utilized <a target=\"_blank\" href=\"https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow\">jobs within the workflow</a> as a solution. This approach allowed us not to wait for one job to finish before starting another, enabling all three checks to run simultaneously. Let's examine the expanded workflow designed to execute these jobs concurrently.</p>\n<pre><code class=\"lang-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">PR</span> <span class=\"hljs-string\">Validation</span>\n\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">pull_request:</span>\n    <span class=\"hljs-attr\">types:</span> [<span class=\"hljs-string\">opened</span>, <span class=\"hljs-string\">reopened</span>, <span class=\"hljs-string\">synchronize</span>, <span class=\"hljs-string\">ready_for_review</span>]\n    <span class=\"hljs-attr\">branches:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">development</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">main</span>\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">cypress-run:</span>\n    <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">github.event.pull_request.draft</span> <span class=\"hljs-string\">==</span> <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n    <span class=\"hljs-attr\">env:</span>\n      <span class=\"hljs-attr\">NODE_ENV:</span> <span class=\"hljs-string\">test</span>\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-comment\">#...steps</span>\n  <span class=\"hljs-attr\">type-check:</span>\n      <span class=\"hljs-comment\">#...checkout repo and install dependencies</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Type</span> <span class=\"hljs-string\">checking</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">tsc</span> <span class=\"hljs-string\">--no-Emit</span>\n  <span class=\"hljs-attr\">lint-check:</span>\n      <span class=\"hljs-comment\">#...checkout repo and install dependencies</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Linting</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">eslint</span> <span class=\"hljs-string\">.</span> <span class=\"hljs-string\">--fix</span> <span class=\"hljs-string\">--ext</span> <span class=\"hljs-string\">.js,.jsx,.ts,.tsx</span>\n</code></pre>\n<p>Now, we have three jobs running concurrently for tests, lint errors, and type errors.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050575992/ffa86ea0-a32e-4c96-8ca9-186ce1101015.png\" alt class=\"image--center mx-auto\" /></p>\n<p>You might be wondering, what about catching errors during development to prevent pushing them in the first place?</p>\n<p>Our IDEs are intelligent enough to detect these errors as we develop features, so we don't need to constantly check everything. The objective is to allow the merging of code only if it passes all checks in place, which can happen at the CI level.</p>\n<p>After moving all the checks to the CI, we removed Husky and developers were allowed to push as they deemed appropriate. We will simply block the merging of pull requests if any issues arise.</p>\n<p>This was an improvement over the previous approach, but we still have more work to do.</p>\n<p>Machines running workflows are slower than our Macs, so checks performed on the CI are inevitably slower than when we run them locally.</p>\n<p>Running all three checks on the CI took between 9 and 12 minutes. This meant that developers had to wait for 9 to 12 minutes before they could merge their pull requests. There is certainly room for improvement in this workflow.</p>\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">ðŸš€</div>\n<div data-node-type=\"callout-text\">These checks happen at every commit as soon as you raise a pull request (which is not in draft). This workflow will run anytime a pull request is opened, reopened, synchronized or marked as ready for review for the development or main branches as base branch.</div>\n</div>\n\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691493604969/6d51d96c-b8bd-44d7-bf5b-155545d01cb1.png\" alt class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-lint-staged-files-in-github-actions\">Lint Staged Files in GitHub Actions</h3>\n<p>One quick improvement we could make is to run lint checks only for the files that have been changed, and that's where Lint-staged comes in handy.</p>\n<p>Lint-staged typically works in conjunction with a pre-commit hook, such as Husky, to run lint checks on staged files only. However, we can modify it to run within a CI environment and focus solely on the files that have changed between commits. Let's replace the lint step in the workflow with this approach:</p>\n<pre><code class=\"lang-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Linting</span>\n   <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">yarn</span> <span class=\"hljs-string\">lint-staged</span> <span class=\"hljs-string\">--diff=\"origin/${GITHUB_BASE_REF}...origin/${GITHUB_HEAD_REF}\"</span> <span class=\"hljs-string\">--no-stash</span>\n</code></pre>\n<p>This command calculates the difference between your branch and the base branch and then runs ESLint on it. This minor adjustment reduced the lint check duration from 30 seconds to 6 seconds.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050559924/c6cb39eb-7e47-4167-84f2-a3b3fb4ed947.png\" alt class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-skipping-library-check-for-typescript\">Skipping Library Check for TypeScript</h3>\n<p>Type checking, due to its nature, must run on the entire codebase, so there isn't much we can do to optimize it. However, we can skip the library check to make it slightly faster. To do this, replace the type check with the following:</p>\n<pre><code class=\"lang-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Type</span> <span class=\"hljs-string\">checking</span>\n   <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">tsc</span> <span class=\"hljs-string\">--pretty</span> <span class=\"hljs-string\">--skipLibCheck</span> <span class=\"hljs-string\">--noEmit</span>\n</code></pre>\n<p>Now that we've improved all the checks individually, it's time to cache whatever we can. Let's see how to cache the installation of dependencies for each job.</p>\n<h3 id=\"heading-caching-node-modules\">Caching Node Modules</h3>\n<p>Since the three jobs run in parallel, they each need to install dependencies, which can be time-consuming. We've updated the workflow to cache dependencies and modified the \"Installing dependency\" step to skip when the cache is available. This can be achieved as follows:</p>\n<pre><code class=\"lang-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Get</span> <span class=\"hljs-string\">yarn</span> <span class=\"hljs-string\">cache</span> <span class=\"hljs-string\">directory</span> <span class=\"hljs-string\">path</span>\n    <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">yarn-cache-dir-path</span>\n    <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">\"dir=$(yarn cache dir)\"</span> <span class=\"hljs-string\">&gt;&gt;</span> <span class=\"hljs-string\">$GITHUB_OUTPUT</span>\n<span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/cache@v3</span>\n    <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">yarn-cache</span>\n    <span class=\"hljs-attr\">with:</span>\n        <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">|\n            **/node_modules\n            **/.eslintcache\n            ${{ steps.yarn-cache-dir-path.outputs.dir }}\n</span>        <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">runner.os</span> <span class=\"hljs-string\">}}-yarn-${{</span> <span class=\"hljs-string\">hashFiles('**/yarn.lock')</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">restore-keys:</span> <span class=\"hljs-string\">|\n            ${{ runner.os }}-yarn-\n</span><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">dependencies</span>\n    <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">steps.yarn-cache.outputs.cache-hit</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-string\">'true'</span>\n    <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">yarn</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">--frozen-lockfile</span>\n</code></pre>\n<p>We include this for all jobs and retrieve <code>node_modules</code> from the cache when available. This significantly improved the time required to complete the entire check.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050813498/b16c02d4-f08b-4cfb-b071-4e249bc6a6d6.png\" alt class=\"image--center mx-auto\" /></p>\n<p>We are already in good shape, but there is one more improvement we can add.</p>\n<h3 id=\"heading-removing-checks-from-vercel\">Removing Checks from Vercel</h3>\n<p>Vercel builds typically perform linting and type error checks by default. This causes the entire build process to take approximately 8 minutes.</p>\n<p>Since we already perform error checks on our end, there's no need to repeat them during builds. The final step is to bypass these checks in Vercel builds. We implemented this in <code>vercel.config.js</code>:</p>\n<pre><code class=\"lang-javascript\">  eslint: {\n    <span class=\"hljs-attr\">ignoreDuringBuilds</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">typescript</span>: {\n    <span class=\"hljs-attr\">ignoreBuildErrors</span>: <span class=\"hljs-literal\">true</span>,\n  },\n</code></pre>\n<p>You can check <a target=\"_blank\" href=\"https://nextjs.org/docs/app/api-reference/next-config-js\">Vercel Docs</a> for the config specification.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1691050886193/2e1e3ec1-cc4a-4247-9f07-161733b166a0.png\" alt class=\"image--center mx-auto\" /></p>\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">ðŸ’»</div>\n<div data-node-type=\"callout-text\">Developers have the freedom to set up pre-commit hooks locally if they prefer. If they believe it enhances their workflow, they should be allowed to do so. By shifting checks to the CI, we ensure that we don't impose any opinions on how developers should work, granting them the liberty to proceed as they see fit.</div>\n</div>\n\n<h2 id=\"heading-conclusion\">Conclusion</h2>\n<p>By adding all the necessary improvements we discussed above, we were able to reduce the time required to merge a pull request from 12 minutes to 5 minutes. This improved both the developer experience and the overall deployment process.</p>\n<p>Here's the summary of the improvements we added:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1690953115674/409ed5a5-4266-499a-86a5-f99e663eb941.png\" alt class=\"image--center mx-auto\" /></p>\n<p>I hope this article was informative and you learned something new today ðŸ˜„.</p>\n<p>Do you think we can improve it further? Let us know in the comments.</p>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1691493542287/42771240-a91c-40dd-b0a7-ed8449911dd8.png"}}},"__N_SSG":true}