{"pageProps":{"post":{"slug":"aws-eventbridge-intro","url":"https://engineering.hashnode.com/aws-eventbridge-intro","brief":"This is part 3 of our series: How we build EDA at Hashnode on AWS.\nIn part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.\nWhat is EventBri...","title":"Introducing Amazon EventBridge: Building Serverless Event-Driven Architectures with AWS","publishedAt":"2022-12-14T10:31:48.085Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1671013477321/squQtugN5.png"},"author":{"name":"Sandro Volpicella","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg"},"id":"6399a61430a84696a5937a5a","content":{"markdown":"This is part 3 of our series: **How we build EDA at Hashnode on AWS.**\n\nIn part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.\n\n## What is EventBridge\n\nAmazon EventBridge is a service to build serverless event-driven architectures. It was launched in 2019. Formerly it was part of the CloudWatch Service and was called CloudWatch Events.\n\nEventBridge allows you to build EDA and integrate it with many AWS services. Each AWS Account has a default event bus. This event bus receives all events from internal AWS Services like ECS, EC2, or Lambda.\n\nAdditionally, EventBridge partners with many third-party SaaS tools such as MongoDB, Zendesk, or Shopify. This makes the integration even easier.\n\n## Components\n\nAmazon EventBridge has several components. Let's go through the components one by one and see what their functionality is.\n\n![Amazon EventBridge Components](https://cdn.hashnode.com/res/hashnode/image/upload/v1662711481911/-07JByTwJ.png align=\"center\")\n\n### Event Bus\n\nOne of the main components of EventBridge is an event bus. You send all events from your event producer to an event bus.\n\nEach AWS account has a default event bus. This default event bus receives events from within AWS.\n\nExamples of these events are:\n\n*   EC2 instance was created\n    \n*   ECS task state changed\n    \n*   EventBridge schema changed\n    \n\nYou can also create a custom event bus. You can send any kind of event you want to the custom event bus.\n\nPartner events (Auth0, MongoDB, etc.) are creating their own custom event bus.\n\n### Rule\n\nThe second component is the event rule.\n\nEventBridge allows you to create rules. A rule belongs to an event bus. The rule defines in which cases the event will be sent to the consumers.\n\nThe rule has an event pattern. This is one of the core functionalities and strengths of EventBridge. The rule matches **the whole message body**.\n\nAn incoming event is a JSON object. You can match any key-value pair in this JSON object.\n\nIf a rule matches the event will be forwarded to a **target**.\n\nHere are some examples of things you can match:\n\n*   Value is null: `\"data\":[null]`\n    \n*   Value is empty: `\"data\":[\"\"]`\n    \n*   Value equals something `\"name\": [\"Sandro\"]`\n    \n\nThere are many more operators [available](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).\n\nFor our example above, the rule is the following:\n\n```json\n{\n  \"detail-type\": [\"postPublished\"],\n  \"source\": [\"hashnode.api\"],\n  \"detail\": {\n    \"data\": {\n      \"publication\": {\n        \"audioBlogEnabled\": [ true ]\n      }\n    }\n  }\n}\n```\n\nOnly events that look like that will be matched by the rule:\n\n```JSON\n{\n    \"detail-type\": \"postPublished\",\n    \"source\": \"hashnode.api\",\n    \"detail\": {\n        \"data\": {\n            \"publication\": {\n                \"audioBlogEnabled\": true\n            }\n        }\n    }\n}\n```\n\nIf `audioBlogEnabled` is `false` or missing the rule won't match and therefore, no target will be called.\n\nWhat happens if a rule matches? The event will be pushed to its **targets**.\n\n### Target\n\nA target is the subscriber of an event rule. There are many target types available in EventBridge. Some of the most important ones are:\n\n*   Lambda\n    \n*   SNS Topic\n    \n*   SQS Queue\n    \n*   Step Functions\n    \n*   API Destinations\n    \n\nYou can see a list of all supported targets [here](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html).\n\nOnce the rule matches the target will be invoked and the rule will be sent to this target.\n\n## Cron Jobs\n\nCron jobs are regularly executed scripts. EventBridge allows you to run jobs at regular intervals. A cron job can either be defined by a schedule like `run every minute` or by the cron syntax, for example, `0 10 * * ? *`.\n\nEventBridge calls the target in this interval. Cron jobs live on the default event bus.\n\n## Archive & Replay\n\n![Archive and Replay in EventBridge](https://cdn.hashnode.com/res/hashnode/image/upload/v1666603891263/ZnT3GmvGl.png align=\"left\")\n\nA really nice feature that was already mentioned in the last post is **Archive & Replay**.\n\nIf you enable the archive functionality, EventBridge will create an archive of **all events that are sent to this event bus**. This comes in super handy when you introduced a bug and want to run all events again.\n\nAlso, this is pretty useful for using production workloads in a development environment.\n\nWith the replay functionality, you can define a start and end time from when the events should be replayed and on which event bus.\n\n## Schema Bindings\n\nEventBridge allows you to activate a schema discovery. The schema discovery can then go ahead and create type bindings **automatically for you**. For example, you can activate schema discovery for your event bus. Then send events to this bus and finally, generate TypeScript types.\n\nWhile this idea is really nice it has some drawbacks so we cannot use it right now at Hashnode. For example, it is not really possible to use optional fields.\n\nThis is why I won't dive deeper into this topic.\n\n## Target Lambda\n\nThere are many ways to execute your business logic in a target attached to an EventBridge rule. We chose Lambda as the main target for all of our targets.\n\nOne alternative was the usage of SQS between EventBridge and Lambda. While the SQS & Lambda approach can be useful for tasks that require a more complicated retry logic, for our case a simple lambda function with Destinations is much easier to implement.\n\nLambda functions which are called asynchronously also have an SQS in the background. AWS takes care of that.\n\nFailed messages can still be sent to a custom DLQ.\n\nWe will show you in one of the next posts how we handle retries and failures in detail.\n\n## Final Words\n\nThis is our introduction to EventBridge and the last one of our basic posts.\n\nNow we will dive deeper into the actual implementation and some nitty-gritty of this architecture.\n\nPosts that will follow soon are:\n\n*   Failures & Retries with EventBridge, Lambda, and Destinations\n    \n*   How to validate incoming events with Middy & ZOD\n    \n*   Integration tests with EventBridge\n    \n\nStay tuned ðŸ¤˜","html":"<p>This is part 3 of our series: <strong>How we build EDA at Hashnode on AWS.</strong></p>\n<p>In part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.</p>\n<h2 id=\"heading-what-is-eventbridge\">What is EventBridge</h2>\n<p>Amazon EventBridge is a service to build serverless event-driven architectures. It was launched in 2019. Formerly it was part of the CloudWatch Service and was called CloudWatch Events.</p>\n<p>EventBridge allows you to build EDA and integrate it with many AWS services. Each AWS Account has a default event bus. This event bus receives all events from internal AWS Services like ECS, EC2, or Lambda.</p>\n<p>Additionally, EventBridge partners with many third-party SaaS tools such as MongoDB, Zendesk, or Shopify. This makes the integration even easier.</p>\n<h2 id=\"heading-components\">Components</h2>\n<p>Amazon EventBridge has several components. Let's go through the components one by one and see what their functionality is.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1662711481911/-07JByTwJ.png\" alt=\"Amazon EventBridge Components\" class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-event-bus\">Event Bus</h3>\n<p>One of the main components of EventBridge is an event bus. You send all events from your event producer to an event bus.</p>\n<p>Each AWS account has a default event bus. This default event bus receives events from within AWS.</p>\n<p>Examples of these events are:</p>\n<ul>\n<li><p>EC2 instance was created</p>\n</li>\n<li><p>ECS task state changed</p>\n</li>\n<li><p>EventBridge schema changed</p>\n</li>\n</ul>\n<p>You can also create a custom event bus. You can send any kind of event you want to the custom event bus.</p>\n<p>Partner events (Auth0, MongoDB, etc.) are creating their own custom event bus.</p>\n<h3 id=\"heading-rule\">Rule</h3>\n<p>The second component is the event rule.</p>\n<p>EventBridge allows you to create rules. A rule belongs to an event bus. The rule defines in which cases the event will be sent to the consumers.</p>\n<p>The rule has an event pattern. This is one of the core functionalities and strengths of EventBridge. The rule matches <strong>the whole message body</strong>.</p>\n<p>An incoming event is a JSON object. You can match any key-value pair in this JSON object.</p>\n<p>If a rule matches the event will be forwarded to a <strong>target</strong>.</p>\n<p>Here are some examples of things you can match:</p>\n<ul>\n<li><p>Value is null: <code>\"data\":[null]</code></p>\n</li>\n<li><p>Value is empty: <code>\"data\":[\"\"]</code></p>\n</li>\n<li><p>Value equals something <code>\"name\": [\"Sandro\"]</code></p>\n</li>\n</ul>\n<p>There are many more operators <a target=\"_blank\" href=\"https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html\">available</a>.</p>\n<p>For our example above, the rule is the following:</p>\n<pre><code class=\"lang-json\">{\n  <span class=\"hljs-attr\">\"detail-type\"</span>: [<span class=\"hljs-string\">\"postPublished\"</span>],\n  <span class=\"hljs-attr\">\"source\"</span>: [<span class=\"hljs-string\">\"hashnode.api\"</span>],\n  <span class=\"hljs-attr\">\"detail\"</span>: {\n    <span class=\"hljs-attr\">\"data\"</span>: {\n      <span class=\"hljs-attr\">\"publication\"</span>: {\n        <span class=\"hljs-attr\">\"audioBlogEnabled\"</span>: [ <span class=\"hljs-literal\">true</span> ]\n      }\n    }\n  }\n}\n</code></pre>\n<p>Only events that look like that will be matched by the rule:</p>\n<pre><code class=\"lang-JSON\">{\n    <span class=\"hljs-attr\">\"detail-type\"</span>: <span class=\"hljs-string\">\"postPublished\"</span>,\n    <span class=\"hljs-attr\">\"source\"</span>: <span class=\"hljs-string\">\"hashnode.api\"</span>,\n    <span class=\"hljs-attr\">\"detail\"</span>: {\n        <span class=\"hljs-attr\">\"data\"</span>: {\n            <span class=\"hljs-attr\">\"publication\"</span>: {\n                <span class=\"hljs-attr\">\"audioBlogEnabled\"</span>: <span class=\"hljs-literal\">true</span>\n            }\n        }\n    }\n}\n</code></pre>\n<p>If <code>audioBlogEnabled</code> is <code>false</code> or missing the rule won't match and therefore, no target will be called.</p>\n<p>What happens if a rule matches? The event will be pushed to its <strong>targets</strong>.</p>\n<h3 id=\"heading-target\">Target</h3>\n<p>A target is the subscriber of an event rule. There are many target types available in EventBridge. Some of the most important ones are:</p>\n<ul>\n<li><p>Lambda</p>\n</li>\n<li><p>SNS Topic</p>\n</li>\n<li><p>SQS Queue</p>\n</li>\n<li><p>Step Functions</p>\n</li>\n<li><p>API Destinations</p>\n</li>\n</ul>\n<p>You can see a list of all supported targets <a target=\"_blank\" href=\"https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html\">here</a>.</p>\n<p>Once the rule matches the target will be invoked and the rule will be sent to this target.</p>\n<h2 id=\"heading-cron-jobs\">Cron Jobs</h2>\n<p>Cron jobs are regularly executed scripts. EventBridge allows you to run jobs at regular intervals. A cron job can either be defined by a schedule like <code>run every minute</code> or by the cron syntax, for example, <code>0 10 * * ? *</code>.</p>\n<p>EventBridge calls the target in this interval. Cron jobs live on the default event bus.</p>\n<h2 id=\"heading-archive-amp-replay\">Archive &amp; Replay</h2>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1666603891263/ZnT3GmvGl.png\" alt=\"Archive and Replay in EventBridge\" /></p>\n<p>A really nice feature that was already mentioned in the last post is <strong>Archive &amp; Replay</strong>.</p>\n<p>If you enable the archive functionality, EventBridge will create an archive of <strong>all events that are sent to this event bus</strong>. This comes in super handy when you introduced a bug and want to run all events again.</p>\n<p>Also, this is pretty useful for using production workloads in a development environment.</p>\n<p>With the replay functionality, you can define a start and end time from when the events should be replayed and on which event bus.</p>\n<h2 id=\"heading-schema-bindings\">Schema Bindings</h2>\n<p>EventBridge allows you to activate a schema discovery. The schema discovery can then go ahead and create type bindings <strong>automatically for you</strong>. For example, you can activate schema discovery for your event bus. Then send events to this bus and finally, generate TypeScript types.</p>\n<p>While this idea is really nice it has some drawbacks so we cannot use it right now at Hashnode. For example, it is not really possible to use optional fields.</p>\n<p>This is why I won't dive deeper into this topic.</p>\n<h2 id=\"heading-target-lambda\">Target Lambda</h2>\n<p>There are many ways to execute your business logic in a target attached to an EventBridge rule. We chose Lambda as the main target for all of our targets.</p>\n<p>One alternative was the usage of SQS between EventBridge and Lambda. While the SQS &amp; Lambda approach can be useful for tasks that require a more complicated retry logic, for our case a simple lambda function with Destinations is much easier to implement.</p>\n<p>Lambda functions which are called asynchronously also have an SQS in the background. AWS takes care of that.</p>\n<p>Failed messages can still be sent to a custom DLQ.</p>\n<p>We will show you in one of the next posts how we handle retries and failures in detail.</p>\n<h2 id=\"heading-final-words\">Final Words</h2>\n<p>This is our introduction to EventBridge and the last one of our basic posts.</p>\n<p>Now we will dive deeper into the actual implementation and some nitty-gritty of this architecture.</p>\n<p>Posts that will follow soon are:</p>\n<ul>\n<li><p>Failures &amp; Retries with EventBridge, Lambda, and Destinations</p>\n</li>\n<li><p>How to validate incoming events with Middy &amp; ZOD</p>\n</li>\n<li><p>Integration tests with EventBridge</p>\n</li>\n</ul>\n<p>Stay tuned ðŸ¤˜</p>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1671013503443/INGnCMjJb.png"}}},"__N_SSG":true}