<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>The art of feed curating: Our approach to generating personalized feeds that match users&#x27; interests | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/the-art-of-feed-curating-our-approach-to-generating-personalized-feeds-that-match-users-interests"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1693400623549/fb200935-78c6-42d1-bb7f-96b3bac6a128.jpeg"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">The art of feed curating: Our approach to generating personalized feeds that match users&#x27; interests</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1675085454170/766f4dd9-9fba-4aa7-b141-ff62bba7eafe.jpeg" class="w-10 h-10 rounded-full" alt="Florian Fuchs"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Florian Fuchs</div></div><time dateTime="2023-09-05T12:53:57.776Z">September 5, 2023</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for The art of feed curating: Our approach to generating personalized feeds that match users&#x27; interests" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1693400608045%2F24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>Feeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on <a target="_blank" href="https://saturncloud.io/blog/how-are-reddit-and-hacker-news-ranking-algorithms-used/#how-hot-ranking-works">hot ranking algorithms.</a> Over time, we noticed that users struggle to find the content they are genuinely interested in on our platform. This is why we have decided to power up our feed game with personalized feeds 🎉</p>
<h3 id="heading-why-are-personalized-feeds-such-a-big-deal">Why are personalized feeds such a big deal? 🤔</h3>
<p>When you visit a community platform, you want to see content that speaks to you. That's where personalized feeds come in! Instead of a generic feed, personalized feeds focus on what the user finds interesting and valuable. They do this by looking at your past interactions, interests, and other factors to serve up content that's right up your alley 🎯</p>
<div data-node-type="callout">
<div data-node-type="callout-emoji">💡</div>
<div data-node-type="callout-text">Personalized feeds at Hashnode focus on what YOU find interesting!</div>
</div>

<p>As a result, users get an enjoyable and engaging experience. Personalized feeds help to keep users happy and active by catering to their preferences and interests.</p>
<p>Let's explore how we implemented personalized feeds at Hashnode 🚀</p>
<h2 id="heading-personalized-feeds-for-different-users-lets-see-the-result">Personalized feeds for different users – let’s see the result</h2>
<p>Let's examine the concept of personalization. From a user's standpoint, assuming that the feed will differ for each individual is reasonable. When we query our feed endpoint for two distinct users, we obtain the following results:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1693294681441/869135e2-d7db-4ed0-b81c-faaa6fb54f22.gif" alt="Comparing Feeds - Result for a User" class="image--center mx-auto" /></p>
<hr />
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1693294707867/3593c39f-2463-4067-98d0-79a61dfeb390.gif" alt="Comparing Feeds - Result for a User" class="image--center mx-auto" /></p>
<p>The users follow different tags and engage with Hashnode in unique ways. The outcome? A feed that is tailored to each user.<br />If you want to see this in action, visit <a target="_blank" href="https://hashnode.com/">our Homepage</a>.</p>
<p>Let's see how we have built this experience from an engineering perspective 👀</p>
<h2 id="heading-how-to-generate-personalized-feeds-without-machine-learning">How to generate personalized feeds without machine learning?</h2>
<p>For most platforms, machine learning is the go-to approach to calculate and personalize stuff. These techniques and algorithms have existed for a long time and are rooted in the early e-commerce systems to recommend other stuff that you may find interesting.<br />Platforms like Facebook, Twitter, and Instagram have shown machine learning models can be effective when trained with enough and correct data.</p>
<p><img src="https://images.unsplash.com/photo-1620712943543-bcc4688e7485?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" alt="a robot sitting on top of a wooden bench" /></p>
<p>At Hashnode, we decided initially not to go the machine learning route for our personalized feeds. Although incorporating machine learning into our platform is a long-term objective, we have opted for an alternative approach in the interim.</p>
<p>Starting with an ML approach is challenging. You need to have some knowledge about creating machine learning models and pipelines. You need to integrate ML into your existing platform. Multiple options are available: either go with self-hosting and self-creating/training your models or use a service where you can train models by feeding them data. The one point that stuck out was that you must understand your data and what you want to achieve with the model.</p>
<p>We decided to go with a ranking-based approach, as we wanted to verify assumptions we already had about our content and get out a better algorithm as fast as possible. To generate personalized feeds without machine learning, we have developed our own unique recipe for feed generation. This method considers various aspects and user behavior patterns that we believe will be most beneficial in ranking posts for each user. By carefully considering multiple factors, we can curate a feed that caters to our users' specific interests and needs.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1692887045099/9eca6989-c052-43bb-846b-a64b06fabbed.png" alt="a diagram of algorithm with different inputs to generate personalized feeds" class="image--center mx-auto" /></p>
<p>Going with this route gives us the leverage to understand the influence different weights and data points have on the quality of our feed. It enables us to provide a more customized experience for our community members and continually refine and improve our feed generation process. Resulting in a faster delivery of even more relevant and captivating content as we gather more data and insights on user preferences and behavior.</p>
<p>In conclusion, while machine learning and AI algorithms are powerful tools for generating personalized feeds, traditional techniques can still be employed to create a tailored content experience.</p>
<p>Let's look at what we use to develop a personalized feed for a user 🫣</p>
<h2 id="heading-which-data-is-relevant-for-feed-calculation">Which data is relevant for feed calculation?</h2>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1692886298254/fe479a1d-0835-458b-b399-14b1cb9acb65.png" alt="different inputs that are considered while calculating a personalized feed for a user " class="image--center mx-auto" /></p>
<p>To effectively personalize feeds and generate accurate content rankings for each user, it is crucial to consider several pieces of data that can provide valuable insights into their preferences and behavior. These data points include:</p>
<p><strong>User-specific:</strong></p>
<ul>
<li><p>Followed Tags: The tags a user follows indicate their topics of interest. Content with matching tags should be prioritized higher.</p>
</li>
<li><p>Following the Author/Blog: A user who follows an author or blog will likely enjoy that content source. Content from followed authors/blogs should be weighted more heavily.</p>
</li>
<li><p>Reading History: What articles a user has read in the past shows their preferred content types and subjects. Similar new content should be ranked higher.</p>
</li>
</ul>
<p><strong>Community-specific</strong>:</p>
<ul>
<li><p>Likes: If an article has received many likes from the community, it is likely high quality and relevant to some users.</p>
</li>
<li><p>Comments: More engagement in comments also indicates relevance and popularity.</p>
</li>
<li><p>Views: Higher-viewed content is generally more relevant to more users.</p>
</li>
<li><p>Featured: Featured articles are chosen for their relevance and quality.</p>
</li>
<li><p>Recency: Newer content is likely fresher and more timely. Furthermore, this boosts newly published content and freshens up the feed.</p>
</li>
</ul>
<p><strong>Blog-specific</strong>:</p>
<ul>
<li><p>Pro Account: Pro on a blog can indicate that the authors use Hashnode on a more sophisticated level and leverage features such as Hashnode AI, which allows them to generate even more high-quality content.</p>
</li>
<li><p>Custom Domain: Custom domains indicate authors leveraging Hashnode to build their brand and publish high-quality content.</p>
</li>
</ul>
<div data-node-type="callout">
<div data-node-type="callout-emoji">💡</div>
<div data-node-type="callout-text">The above list shows roughly the importance of the weights in a declining order. The main focus lies on the User-specific weights, whereas the following categories have less and less influence on the score.</div>
</div>

<h2 id="heading-ranking-posts-to-generate-personalized-feeds">Ranking posts to generate personalized feeds</h2>
<p>Now, it's time to look at how weights are calculated and how they influence the score of a post within a user's feed. 🧑‍💻</p>
<p>The User-specific weights are rather straightforward. We can check if the user is following the Author/Blog, the following tags added to the post, and if the article is from an author in the reading history of the user:</p>
<pre><code class="lang-typescript">  <span class="hljs-keyword">const</span> followingScore = usersUserIsFollowing.includes(
    post.author
  )
   ? FOLLOW_WEIGHT
   : <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> readingHistoryScore = postsAuthorsUserHasViewed.includes(
     post.author
   )
    ? READING_HISTORY_WEIGHT
    : <span class="hljs-number">0</span>;

   <span class="hljs-keyword">const</span> tagScore = calculateTagWeights(
     tagsUserIsFollowing,
     post.tags
   );

   <span class="hljs-keyword">const</span> userSpecificScore = followingScore 
                              + readingHistoryScore
                              + tagScore;
</code></pre>
<p>For the Community-specific weights, this is a little bit more difficult. We could go with a straightforward approach by deciding a weight for a single like and multiplying this with the likes this post has received, but the chance to over-boost a post becomes very high when going this route. Furthermore, this would not only result in potential over-boosts and decrease the relevance for the user, but it would also result in a non-uniform distribution of likes. Let's take a look at an example. Assuming two posts and a weight of 2 for each, like:</p>
<p>$$10(likes) * 2 = 20$$</p><p>and</p>
<p>$$100(likes) * 2 = 200$$</p><p>➡️ There is no way to compare these two as the values are too far apart.</p>
<p>The solution we came up with is twofold:</p>
<ul>
<li><p>Normalize likes, views, and comments</p>
</li>
<li><p>Treat the weight for these parameters as the maximum a post can receive. For this, we need to update how we calculate the weight.</p>
</li>
</ul>
<p>The formula can then look relatively easy. Let's retake a look at the likes for a post:</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// Baseline value, everything over 1000 likes will recive the</span>
<span class="hljs-comment">// full score for the likes weight. Everything below will be fracitonal</span>
<span class="hljs-comment">// For 1000 as basline this will be 3</span>
<span class="hljs-keyword">const</span> MAX_LIKE = <span class="hljs-built_in">Math</span>.log10(<span class="hljs-number">1000</span>);

<span class="hljs-comment">// For 10 likes this will be 1</span>
<span class="hljs-comment">// For 100 likes this will be 2</span>
<span class="hljs-keyword">const</span> postLikes = <span class="hljs-built_in">Math</span>.log10(post.likes)

<span class="hljs-comment">// Assuming 10 likes will result in: 1 * 2 / 3 = 0.66</span>
<span class="hljs-comment">// Assuming 100 likes will result in: 2 * 2 /3 = 1.33</span>
<span class="hljs-keyword">const</span> scoreForLikes = (post.likes * LIKES_WEIGHT) / MAX_LIKE;

<span class="hljs-comment">// Check if the score is greater than the LIKES_WEIGHT</span>
<span class="hljs-comment">// Yes -&gt; use LIKES_WEIGHT</span>
<span class="hljs-comment">// No -&gt; use the calculated score </span>
<span class="hljs-keyword">const</span> actualLikeScore = scoreForLikes &gt; LIKES_WEIGHT ? LIKES_WEIGHT : scoreForLikes
</code></pre>
<p>As we can see in the above snippet, this way of calculating the scores will ensure that:</p>
<ul>
<li><p>An article with many likes is not over-boosted</p>
</li>
<li><p>The score does not exceed the weight we set as a maximum</p>
</li>
<li><p>The values are more evenly distributed, comparing <code>20</code> to <code>200</code> (<code>10</code> times) vs. <code>0.66</code> to <code>1.33</code> (roughly <code>2</code> times)</p>
</li>
</ul>
<p>This is done for all the Community-specific weights except the featured flag, which can be easily added by checking if the post is featured on Hashnode.</p>
<p>On the other hand, Recency also needs a specific logic to give us a desired score so we do not overboost newly published articles.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> getDateFactorForFeed = <span class="hljs-function">(<span class="hljs-params">date: <span class="hljs-built_in">Date</span></span>) =&gt;</span> {
  <span class="hljs-comment">// Consider the last 30 days in hours</span>
  <span class="hljs-keyword">const</span> recentTimeFrame = <span class="hljs-number">720</span>;

<span class="hljs-comment">// Divide the recent weight by the time frime to get the points </span>
<span class="hljs-comment">// each hour will recive</span>
<span class="hljs-comment">// e.g. 5 / 720 = 0.0069444444</span>
  <span class="hljs-keyword">const</span> pointsPerHour = RECENT_WEIGHT / recentTimeFrame;

<span class="hljs-comment">// Calculate the difference in hours between now and the publish date</span>
<span class="hljs-comment">// of the article </span>
  <span class="hljs-keyword">const</span> difference = dayjs().diff(dayjs(date), <span class="hljs-string">'hours'</span>);

<span class="hljs-comment">// The weight should not be negative. </span>
  <span class="hljs-keyword">const</span> weight = <span class="hljs-built_in">Math</span>.max(recentTimeFrame - difference, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Multiple the resulting weight with the points for each hour</span>
<span class="hljs-comment">// weight = 0 =&gt; 0 * 0.0069444444 = 0</span>
<span class="hljs-comment">// weight = 720 =&gt; 720 * 0.0069444444 = 5</span>
  <span class="hljs-keyword">return</span> weight * pointsPerHour;
};
</code></pre>
<p>With this calculation, the maximum value recency can receive will always be <code>RECENT_WEIGHT</code>.</p>
<p>Lastly, the Write-specific weights are calculated similarly to User-specific weights by checking if the Blog has connected a custom domain or is subscribed to Hashnode Pro.</p>
<p>The overall score calculation for the specific post adds up all our values, and we have a score for the post 🚀</p>
<h2 id="heading-how-we-keep-your-feed-fresh-all-the-time">How we keep your feed fresh all the time</h2>
<p>After the initial testing, we noticed that the feed displays more relevant content but does not refresh as frequently as we would like.</p>
<p><strong>How to make the feed highly dynamic and present fresh content on every visit?🤔</strong></p>
<p>There are multiple possible solutions to do this, but we decided to explore damping. We don't want to harshly penalize articles by removing them from feeds. With damping, posts receive a slight reduction in their score if they have already been presented to the user. Moreover, this allows them to reappear in the feed and be noticed by the user. To ensure fair treatment for all articles, we have decided on the following rules:</p>
<ul>
<li><p>The damping is based on the page an article is presented on</p>
</li>
<li><p>As the number of pages increases, the damping of articles on those pages decreases.</p>
</li>
<li><p>We will only implement damping for the first five pages, ensuring we do not inadvertently exclude any articles beyond that point.</p>
</li>
</ul>
<p>After 24 hours, we remove all damping effects from a user's feed, allowing each post to potentially resurface in the upper positions.</p>
<p>In combination with the score calculation algorithm, this has a very nice effect:</p>
<div>
  <iframe src="https://veed.io/embed/530d4a96-da87-4436-9a34-9cf2ec1b0efc" width="100%" height="504">
</iframe></div>

<h2 id="heading-next-plans-for-the-personalized-feeds-on-hashnode">Next plans for the personalized feeds on hashnode</h2>
<p>Now that we have created an algorithm and prepared the groundwork, what comes next for our new personalized feed?</p>
<p>I assume you guessed it right:</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif">https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif</a></div>
<p> </p>
<p>Initially, we only wanted to verify our assumptions about content and how to create a feed that engages users and shows high-quality and highly relevant articles from our Platform.</p>
<p>As you can imagine, the calculation is expensive from a computational point of view. We need to gather the latest posts from our platform, collect data for the user, and calculate the scores for each post before we can serve them. It is also not as straightforward as it would be with a following feed. There, we could cache everything and append new posts on the top of the cache to be served on a request to the feed.</p>
<p>In the case of a personalized feed, we need to have the user metadata at hand to correctly assign a score to the article for the user based on the algorithm.</p>
<p>Guess what? We've developed a nice solution that I'll dive into in another article! But here's a little sneak peek: We're pre-calculating the personalized feed for all our active users on the platform! This way, we can slash peak loads on our service and serve the feed at lightning-fast speeds! 🚀💥🏎️</p>
<p>Until the next one,</p>
<p>Cheers 🙌</p>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"the-art-of-feed-curating-our-approach-to-generating-personalized-feeds-that-match-users-interests","url":"https://engineering.hashnode.com/the-art-of-feed-curating-our-approach-to-generating-personalized-feeds-that-match-users-interests","brief":"Feeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on hot ranking algorithms. Over time, we noticed that users struggle to ...","title":"The art of feed curating: Our approach to generating personalized feeds that match users' interests","publishedAt":"2023-09-05T12:53:57.776Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1693400608045/24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg"},"author":{"name":"Florian Fuchs","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1675085454170/766f4dd9-9fba-4aa7-b141-ff62bba7eafe.jpeg"},"id":"64f724e54ae4dfa2e3d4d440","content":{"markdown":"Feeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on [hot ranking algorithms.](https://saturncloud.io/blog/how-are-reddit-and-hacker-news-ranking-algorithms-used/#how-hot-ranking-works) Over time, we noticed that users struggle to find the content they are genuinely interested in on our platform. This is why we have decided to power up our feed game with personalized feeds 🎉\n\n### Why are personalized feeds such a big deal? 🤔\n\nWhen you visit a community platform, you want to see content that speaks to you. That's where personalized feeds come in! Instead of a generic feed, personalized feeds focus on what the user finds interesting and valuable. They do this by looking at your past interactions, interests, and other factors to serve up content that's right up your alley 🎯\n\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e💡\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003ePersonalized feeds at Hashnode focus on what YOU find interesting!\u003c/div\u003e\n\u003c/div\u003e\n\nAs a result, users get an enjoyable and engaging experience. Personalized feeds help to keep users happy and active by catering to their preferences and interests.\n\nLet's explore how we implemented personalized feeds at Hashnode 🚀\n\n## Personalized feeds for different users – let’s see the result\n\nLet's examine the concept of personalization. From a user's standpoint, assuming that the feed will differ for each individual is reasonable. When we query our feed endpoint for two distinct users, we obtain the following results:\n\n![Comparing Feeds - Result for a User](https://cdn.hashnode.com/res/hashnode/image/upload/v1693294681441/869135e2-d7db-4ed0-b81c-faaa6fb54f22.gif align=\"center\")\n\n---\n\n![Comparing Feeds - Result for a User](https://cdn.hashnode.com/res/hashnode/image/upload/v1693294707867/3593c39f-2463-4067-98d0-79a61dfeb390.gif align=\"center\")\n\nThe users follow different tags and engage with Hashnode in unique ways. The outcome? A feed that is tailored to each user.  \nIf you want to see this in action, visit [our Homepage](https://hashnode.com/).\n\nLet's see how we have built this experience from an engineering perspective 👀\n\n## How to generate personalized feeds without machine learning?\n\nFor most platforms, machine learning is the go-to approach to calculate and personalize stuff. These techniques and algorithms have existed for a long time and are rooted in the early e-commerce systems to recommend other stuff that you may find interesting.  \nPlatforms like Facebook, Twitter, and Instagram have shown machine learning models can be effective when trained with enough and correct data.\n\n![a robot sitting on top of a wooden bench](https://images.unsplash.com/photo-1620712943543-bcc4688e7485?ixlib=rb-4.0.3\u0026ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\u0026auto=format\u0026fit=crop\u0026w=1000\u0026q=80 align=\"left\")\n\nAt Hashnode, we decided initially not to go the machine learning route for our personalized feeds. Although incorporating machine learning into our platform is a long-term objective, we have opted for an alternative approach in the interim.\n\nStarting with an ML approach is challenging. You need to have some knowledge about creating machine learning models and pipelines. You need to integrate ML into your existing platform. Multiple options are available: either go with self-hosting and self-creating/training your models or use a service where you can train models by feeding them data. The one point that stuck out was that you must understand your data and what you want to achieve with the model.\n\nWe decided to go with a ranking-based approach, as we wanted to verify assumptions we already had about our content and get out a better algorithm as fast as possible. To generate personalized feeds without machine learning, we have developed our own unique recipe for feed generation. This method considers various aspects and user behavior patterns that we believe will be most beneficial in ranking posts for each user. By carefully considering multiple factors, we can curate a feed that caters to our users' specific interests and needs.\n\n![a diagram of algorithm with different inputs to generate personalized feeds](https://cdn.hashnode.com/res/hashnode/image/upload/v1692887045099/9eca6989-c052-43bb-846b-a64b06fabbed.png align=\"center\")\n\nGoing with this route gives us the leverage to understand the influence different weights and data points have on the quality of our feed. It enables us to provide a more customized experience for our community members and continually refine and improve our feed generation process. Resulting in a faster delivery of even more relevant and captivating content as we gather more data and insights on user preferences and behavior.\n\nIn conclusion, while machine learning and AI algorithms are powerful tools for generating personalized feeds, traditional techniques can still be employed to create a tailored content experience.\n\nLet's look at what we use to develop a personalized feed for a user 🫣\n\n## Which data is relevant for feed calculation?\n\n![different inputs that are considered while calculating a personalized feed for a user ](https://cdn.hashnode.com/res/hashnode/image/upload/v1692886298254/fe479a1d-0835-458b-b399-14b1cb9acb65.png align=\"center\")\n\nTo effectively personalize feeds and generate accurate content rankings for each user, it is crucial to consider several pieces of data that can provide valuable insights into their preferences and behavior. These data points include:\n\n**User-specific:**\n\n* Followed Tags: The tags a user follows indicate their topics of interest. Content with matching tags should be prioritized higher.\n    \n* Following the Author/Blog: A user who follows an author or blog will likely enjoy that content source. Content from followed authors/blogs should be weighted more heavily.\n    \n* Reading History: What articles a user has read in the past shows their preferred content types and subjects. Similar new content should be ranked higher.\n    \n\n**Community-specific**:\n\n* Likes: If an article has received many likes from the community, it is likely high quality and relevant to some users.\n    \n* Comments: More engagement in comments also indicates relevance and popularity.\n    \n* Views: Higher-viewed content is generally more relevant to more users.\n    \n* Featured: Featured articles are chosen for their relevance and quality.\n    \n* Recency: Newer content is likely fresher and more timely. Furthermore, this boosts newly published content and freshens up the feed.\n    \n\n**Blog-specific**:\n\n* Pro Account: Pro on a blog can indicate that the authors use Hashnode on a more sophisticated level and leverage features such as Hashnode AI, which allows them to generate even more high-quality content.\n    \n* Custom Domain: Custom domains indicate authors leveraging Hashnode to build their brand and publish high-quality content.\n    \n\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e💡\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003eThe above list shows roughly the importance of the weights in a declining order. The main focus lies on the User-specific weights, whereas the following categories have less and less influence on the score.\u003c/div\u003e\n\u003c/div\u003e\n\n## Ranking posts to generate personalized feeds\n\nNow, it's time to look at how weights are calculated and how they influence the score of a post within a user's feed. 🧑‍💻\n\nThe User-specific weights are rather straightforward. We can check if the user is following the Author/Blog, the following tags added to the post, and if the article is from an author in the reading history of the user:\n\n```typescript\n  const followingScore = usersUserIsFollowing.includes(\n    post.author\n  )\n   ? FOLLOW_WEIGHT\n   : 0;\n\n  const readingHistoryScore = postsAuthorsUserHasViewed.includes(\n     post.author\n   )\n    ? READING_HISTORY_WEIGHT\n    : 0;\n\n   const tagScore = calculateTagWeights(\n     tagsUserIsFollowing,\n     post.tags\n   );\n\n   const userSpecificScore = followingScore \n                              + readingHistoryScore\n                              + tagScore;\n```\n\nFor the Community-specific weights, this is a little bit more difficult. We could go with a straightforward approach by deciding a weight for a single like and multiplying this with the likes this post has received, but the chance to over-boost a post becomes very high when going this route. Furthermore, this would not only result in potential over-boosts and decrease the relevance for the user, but it would also result in a non-uniform distribution of likes. Let's take a look at an example. Assuming two posts and a weight of 2 for each, like:\n\n$$10(likes) * 2 = 20$$\n\nand\n\n$$100(likes) * 2 = 200$$\n\n➡️ There is no way to compare these two as the values are too far apart.\n\nThe solution we came up with is twofold:\n\n* Normalize likes, views, and comments\n    \n* Treat the weight for these parameters as the maximum a post can receive. For this, we need to update how we calculate the weight.\n    \n\nThe formula can then look relatively easy. Let's retake a look at the likes for a post:\n\n```typescript\n// Baseline value, everything over 1000 likes will recive the\n// full score for the likes weight. Everything below will be fracitonal\n// For 1000 as basline this will be 3\nconst MAX_LIKE = Math.log10(1000);\n\n// For 10 likes this will be 1\n// For 100 likes this will be 2\nconst postLikes = Math.log10(post.likes)\n\n// Assuming 10 likes will result in: 1 * 2 / 3 = 0.66\n// Assuming 100 likes will result in: 2 * 2 /3 = 1.33\nconst scoreForLikes = (post.likes * LIKES_WEIGHT) / MAX_LIKE;\n\n// Check if the score is greater than the LIKES_WEIGHT\n// Yes -\u003e use LIKES_WEIGHT\n// No -\u003e use the calculated score \nconst actualLikeScore = scoreForLikes \u003e LIKES_WEIGHT ? LIKES_WEIGHT : scoreForLikes\n```\n\nAs we can see in the above snippet, this way of calculating the scores will ensure that:\n\n* An article with many likes is not over-boosted\n    \n* The score does not exceed the weight we set as a maximum\n    \n* The values are more evenly distributed, comparing `20` to `200` (`10` times) vs. `0.66` to `1.33` (roughly `2` times)\n    \n\nThis is done for all the Community-specific weights except the featured flag, which can be easily added by checking if the post is featured on Hashnode.\n\nOn the other hand, Recency also needs a specific logic to give us a desired score so we do not overboost newly published articles.\n\n```typescript\nconst getDateFactorForFeed = (date: Date) =\u003e {\n  // Consider the last 30 days in hours\n  const recentTimeFrame = 720;\n\n// Divide the recent weight by the time frime to get the points \n// each hour will recive\n// e.g. 5 / 720 = 0.0069444444\n  const pointsPerHour = RECENT_WEIGHT / recentTimeFrame;\n\n// Calculate the difference in hours between now and the publish date\n// of the article \n  const difference = dayjs().diff(dayjs(date), 'hours');\n\n// The weight should not be negative. \n  const weight = Math.max(recentTimeFrame - difference, 0);\n\n// Multiple the resulting weight with the points for each hour\n// weight = 0 =\u003e 0 * 0.0069444444 = 0\n// weight = 720 =\u003e 720 * 0.0069444444 = 5\n  return weight * pointsPerHour;\n};\n```\n\nWith this calculation, the maximum value recency can receive will always be `RECENT_WEIGHT`.\n\nLastly, the Write-specific weights are calculated similarly to User-specific weights by checking if the Blog has connected a custom domain or is subscribed to Hashnode Pro.\n\nThe overall score calculation for the specific post adds up all our values, and we have a score for the post 🚀\n\n## How we keep your feed fresh all the time\n\nAfter the initial testing, we noticed that the feed displays more relevant content but does not refresh as frequently as we would like.\n\n**How to make the feed highly dynamic and present fresh content on every visit?🤔**\n\nThere are multiple possible solutions to do this, but we decided to explore damping. We don't want to harshly penalize articles by removing them from feeds. With damping, posts receive a slight reduction in their score if they have already been presented to the user. Moreover, this allows them to reappear in the feed and be noticed by the user. To ensure fair treatment for all articles, we have decided on the following rules:\n\n* The damping is based on the page an article is presented on\n    \n* As the number of pages increases, the damping of articles on those pages decreases.\n    \n* We will only implement damping for the first five pages, ensuring we do not inadvertently exclude any articles beyond that point.\n    \n\nAfter 24 hours, we remove all damping effects from a user's feed, allowing each post to potentially resurface in the upper positions.\n\nIn combination with the score calculation algorithm, this has a very nice effect:\n\n\n\u003cdiv style={{ maxWidth: \"100%\", margin: \"0 auto\" }}\u003e\n  \u003ciframe\n    src=\"https://veed.io/embed/530d4a96-da87-4436-9a34-9cf2ec1b0efc\"\n    width=\"100%\"\n    height=\"504\"\n    style={{ border: \"none\" }}\n    allowFullScreen\n  /\u003e\n\u003c/div\u003e\n\n## Next plans for the personalized feeds on hashnode\n\nNow that we have created an algorithm and prepared the groundwork, what comes next for our new personalized feed?\n\nI assume you guessed it right:\n\n%[https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif] \n\nInitially, we only wanted to verify our assumptions about content and how to create a feed that engages users and shows high-quality and highly relevant articles from our Platform.\n\nAs you can imagine, the calculation is expensive from a computational point of view. We need to gather the latest posts from our platform, collect data for the user, and calculate the scores for each post before we can serve them. It is also not as straightforward as it would be with a following feed. There, we could cache everything and append new posts on the top of the cache to be served on a request to the feed.\n\nIn the case of a personalized feed, we need to have the user metadata at hand to correctly assign a score to the article for the user based on the algorithm.\n\nGuess what? We've developed a nice solution that I'll dive into in another article! But here's a little sneak peek: We're pre-calculating the personalized feed for all our active users on the platform! This way, we can slash peak loads on our service and serve the feed at lightning-fast speeds! 🚀💥🏎️\n\nUntil the next one,\n\nCheers 🙌","html":"\u003cp\u003eFeeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on \u003ca target=\"_blank\" href=\"https://saturncloud.io/blog/how-are-reddit-and-hacker-news-ranking-algorithms-used/#how-hot-ranking-works\"\u003ehot ranking algorithms.\u003c/a\u003e Over time, we noticed that users struggle to find the content they are genuinely interested in on our platform. This is why we have decided to power up our feed game with personalized feeds 🎉\u003c/p\u003e\n\u003ch3 id=\"heading-why-are-personalized-feeds-such-a-big-deal\"\u003eWhy are personalized feeds such a big deal? 🤔\u003c/h3\u003e\n\u003cp\u003eWhen you visit a community platform, you want to see content that speaks to you. That's where personalized feeds come in! Instead of a generic feed, personalized feeds focus on what the user finds interesting and valuable. They do this by looking at your past interactions, interests, and other factors to serve up content that's right up your alley 🎯\u003c/p\u003e\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e💡\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003ePersonalized feeds at Hashnode focus on what YOU find interesting!\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eAs a result, users get an enjoyable and engaging experience. Personalized feeds help to keep users happy and active by catering to their preferences and interests.\u003c/p\u003e\n\u003cp\u003eLet's explore how we implemented personalized feeds at Hashnode 🚀\u003c/p\u003e\n\u003ch2 id=\"heading-personalized-feeds-for-different-users-lets-see-the-result\"\u003ePersonalized feeds for different users – let’s see the result\u003c/h2\u003e\n\u003cp\u003eLet's examine the concept of personalization. From a user's standpoint, assuming that the feed will differ for each individual is reasonable. When we query our feed endpoint for two distinct users, we obtain the following results:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1693294681441/869135e2-d7db-4ed0-b81c-faaa6fb54f22.gif\" alt=\"Comparing Feeds - Result for a User\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003chr /\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1693294707867/3593c39f-2463-4067-98d0-79a61dfeb390.gif\" alt=\"Comparing Feeds - Result for a User\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThe users follow different tags and engage with Hashnode in unique ways. The outcome? A feed that is tailored to each user.\u003cbr /\u003eIf you want to see this in action, visit \u003ca target=\"_blank\" href=\"https://hashnode.com/\"\u003eour Homepage\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eLet's see how we have built this experience from an engineering perspective 👀\u003c/p\u003e\n\u003ch2 id=\"heading-how-to-generate-personalized-feeds-without-machine-learning\"\u003eHow to generate personalized feeds without machine learning?\u003c/h2\u003e\n\u003cp\u003eFor most platforms, machine learning is the go-to approach to calculate and personalize stuff. These techniques and algorithms have existed for a long time and are rooted in the early e-commerce systems to recommend other stuff that you may find interesting.\u003cbr /\u003ePlatforms like Facebook, Twitter, and Instagram have shown machine learning models can be effective when trained with enough and correct data.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://images.unsplash.com/photo-1620712943543-bcc4688e7485?ixlib=rb-4.0.3\u0026amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\u0026amp;auto=format\u0026amp;fit=crop\u0026amp;w=1000\u0026amp;q=80\" alt=\"a robot sitting on top of a wooden bench\" /\u003e\u003c/p\u003e\n\u003cp\u003eAt Hashnode, we decided initially not to go the machine learning route for our personalized feeds. Although incorporating machine learning into our platform is a long-term objective, we have opted for an alternative approach in the interim.\u003c/p\u003e\n\u003cp\u003eStarting with an ML approach is challenging. You need to have some knowledge about creating machine learning models and pipelines. You need to integrate ML into your existing platform. Multiple options are available: either go with self-hosting and self-creating/training your models or use a service where you can train models by feeding them data. The one point that stuck out was that you must understand your data and what you want to achieve with the model.\u003c/p\u003e\n\u003cp\u003eWe decided to go with a ranking-based approach, as we wanted to verify assumptions we already had about our content and get out a better algorithm as fast as possible. To generate personalized feeds without machine learning, we have developed our own unique recipe for feed generation. This method considers various aspects and user behavior patterns that we believe will be most beneficial in ranking posts for each user. By carefully considering multiple factors, we can curate a feed that caters to our users' specific interests and needs.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1692887045099/9eca6989-c052-43bb-846b-a64b06fabbed.png\" alt=\"a diagram of algorithm with different inputs to generate personalized feeds\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eGoing with this route gives us the leverage to understand the influence different weights and data points have on the quality of our feed. It enables us to provide a more customized experience for our community members and continually refine and improve our feed generation process. Resulting in a faster delivery of even more relevant and captivating content as we gather more data and insights on user preferences and behavior.\u003c/p\u003e\n\u003cp\u003eIn conclusion, while machine learning and AI algorithms are powerful tools for generating personalized feeds, traditional techniques can still be employed to create a tailored content experience.\u003c/p\u003e\n\u003cp\u003eLet's look at what we use to develop a personalized feed for a user 🫣\u003c/p\u003e\n\u003ch2 id=\"heading-which-data-is-relevant-for-feed-calculation\"\u003eWhich data is relevant for feed calculation?\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1692886298254/fe479a1d-0835-458b-b399-14b1cb9acb65.png\" alt=\"different inputs that are considered while calculating a personalized feed for a user \" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eTo effectively personalize feeds and generate accurate content rankings for each user, it is crucial to consider several pieces of data that can provide valuable insights into their preferences and behavior. These data points include:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUser-specific:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eFollowed Tags: The tags a user follows indicate their topics of interest. Content with matching tags should be prioritized higher.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFollowing the Author/Blog: A user who follows an author or blog will likely enjoy that content source. Content from followed authors/blogs should be weighted more heavily.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eReading History: What articles a user has read in the past shows their preferred content types and subjects. Similar new content should be ranked higher.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity-specific\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eLikes: If an article has received many likes from the community, it is likely high quality and relevant to some users.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eComments: More engagement in comments also indicates relevance and popularity.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eViews: Higher-viewed content is generally more relevant to more users.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFeatured: Featured articles are chosen for their relevance and quality.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eRecency: Newer content is likely fresher and more timely. Furthermore, this boosts newly published content and freshens up the feed.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eBlog-specific\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003ePro Account: Pro on a blog can indicate that the authors use Hashnode on a more sophisticated level and leverage features such as Hashnode AI, which allows them to generate even more high-quality content.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eCustom Domain: Custom domains indicate authors leveraging Hashnode to build their brand and publish high-quality content.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv data-node-type=\"callout\"\u003e\n\u003cdiv data-node-type=\"callout-emoji\"\u003e💡\u003c/div\u003e\n\u003cdiv data-node-type=\"callout-text\"\u003eThe above list shows roughly the importance of the weights in a declining order. The main focus lies on the User-specific weights, whereas the following categories have less and less influence on the score.\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"heading-ranking-posts-to-generate-personalized-feeds\"\u003eRanking posts to generate personalized feeds\u003c/h2\u003e\n\u003cp\u003eNow, it's time to look at how weights are calculated and how they influence the score of a post within a user's feed. 🧑‍💻\u003c/p\u003e\n\u003cp\u003eThe User-specific weights are rather straightforward. We can check if the user is following the Author/Blog, the following tags added to the post, and if the article is from an author in the reading history of the user:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e followingScore = usersUserIsFollowing.includes(\n    post.author\n  )\n   ? FOLLOW_WEIGHT\n   : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readingHistoryScore = postsAuthorsUserHasViewed.includes(\n     post.author\n   )\n    ? READING_HISTORY_WEIGHT\n    : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tagScore = calculateTagWeights(\n     tagsUserIsFollowing,\n     post.tags\n   );\n\n   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userSpecificScore = followingScore \n                              + readingHistoryScore\n                              + tagScore;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor the Community-specific weights, this is a little bit more difficult. We could go with a straightforward approach by deciding a weight for a single like and multiplying this with the likes this post has received, but the chance to over-boost a post becomes very high when going this route. Furthermore, this would not only result in potential over-boosts and decrease the relevance for the user, but it would also result in a non-uniform distribution of likes. Let's take a look at an example. Assuming two posts and a weight of 2 for each, like:\u003c/p\u003e\n\u003cp\u003e$$10(likes) * 2 = 20$$\u003c/p\u003e\u003cp\u003eand\u003c/p\u003e\n\u003cp\u003e$$100(likes) * 2 = 200$$\u003c/p\u003e\u003cp\u003e➡️ There is no way to compare these two as the values are too far apart.\u003c/p\u003e\n\u003cp\u003eThe solution we came up with is twofold:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eNormalize likes, views, and comments\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eTreat the weight for these parameters as the maximum a post can receive. For this, we need to update how we calculate the weight.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe formula can then look relatively easy. Let's retake a look at the likes for a post:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Baseline value, everything over 1000 likes will recive the\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// full score for the likes weight. Everything below will be fracitonal\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// For 1000 as basline this will be 3\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e MAX_LIKE = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.log10(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// For 10 likes this will be 1\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// For 100 likes this will be 2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e postLikes = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.log10(post.likes)\n\n\u003cspan class=\"hljs-comment\"\u003e// Assuming 10 likes will result in: 1 * 2 / 3 = 0.66\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Assuming 100 likes will result in: 2 * 2 /3 = 1.33\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scoreForLikes = (post.likes * LIKES_WEIGHT) / MAX_LIKE;\n\n\u003cspan class=\"hljs-comment\"\u003e// Check if the score is greater than the LIKES_WEIGHT\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Yes -\u0026gt; use LIKES_WEIGHT\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// No -\u0026gt; use the calculated score \u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e actualLikeScore = scoreForLikes \u0026gt; LIKES_WEIGHT ? LIKES_WEIGHT : scoreForLikes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs we can see in the above snippet, this way of calculating the scores will ensure that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eAn article with many likes is not over-boosted\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe score does not exceed the weight we set as a maximum\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe values are more evenly distributed, comparing \u003ccode\u003e20\u003c/code\u003e to \u003ccode\u003e200\u003c/code\u003e (\u003ccode\u003e10\u003c/code\u003e times) vs. \u003ccode\u003e0.66\u003c/code\u003e to \u003ccode\u003e1.33\u003c/code\u003e (roughly \u003ccode\u003e2\u003c/code\u003e times)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is done for all the Community-specific weights except the featured flag, which can be easily added by checking if the post is featured on Hashnode.\u003c/p\u003e\n\u003cp\u003eOn the other hand, Recency also needs a specific logic to give us a desired score so we do not overboost newly published articles.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getDateFactorForFeed = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edate: \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// Consider the last 30 days in hours\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e recentTimeFrame = \u003cspan class=\"hljs-number\"\u003e720\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// Divide the recent weight by the time frime to get the points \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// each hour will recive\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// e.g. 5 / 720 = 0.0069444444\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pointsPerHour = RECENT_WEIGHT / recentTimeFrame;\n\n\u003cspan class=\"hljs-comment\"\u003e// Calculate the difference in hours between now and the publish date\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// of the article \u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e difference = dayjs().diff(dayjs(date), \u003cspan class=\"hljs-string\"\u003e'hours'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// The weight should not be negative. \u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e weight = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.max(recentTimeFrame - difference, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// Multiple the resulting weight with the points for each hour\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// weight = 0 =\u0026gt; 0 * 0.0069444444 = 0\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// weight = 720 =\u0026gt; 720 * 0.0069444444 = 5\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e weight * pointsPerHour;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this calculation, the maximum value recency can receive will always be \u003ccode\u003eRECENT_WEIGHT\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLastly, the Write-specific weights are calculated similarly to User-specific weights by checking if the Blog has connected a custom domain or is subscribed to Hashnode Pro.\u003c/p\u003e\n\u003cp\u003eThe overall score calculation for the specific post adds up all our values, and we have a score for the post 🚀\u003c/p\u003e\n\u003ch2 id=\"heading-how-we-keep-your-feed-fresh-all-the-time\"\u003eHow we keep your feed fresh all the time\u003c/h2\u003e\n\u003cp\u003eAfter the initial testing, we noticed that the feed displays more relevant content but does not refresh as frequently as we would like.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow to make the feed highly dynamic and present fresh content on every visit?🤔\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThere are multiple possible solutions to do this, but we decided to explore damping. We don't want to harshly penalize articles by removing them from feeds. With damping, posts receive a slight reduction in their score if they have already been presented to the user. Moreover, this allows them to reappear in the feed and be noticed by the user. To ensure fair treatment for all articles, we have decided on the following rules:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eThe damping is based on the page an article is presented on\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAs the number of pages increases, the damping of articles on those pages decreases.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eWe will only implement damping for the first five pages, ensuring we do not inadvertently exclude any articles beyond that point.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAfter 24 hours, we remove all damping effects from a user's feed, allowing each post to potentially resurface in the upper positions.\u003c/p\u003e\n\u003cp\u003eIn combination with the score calculation algorithm, this has a very nice effect:\u003c/p\u003e\n\u003cdiv\u003e\n  \u003ciframe src=\"https://veed.io/embed/530d4a96-da87-4436-9a34-9cf2ec1b0efc\" width=\"100%\" height=\"504\"\u003e\n\u003c/iframe\u003e\u003c/div\u003e\n\n\u003ch2 id=\"heading-next-plans-for-the-personalized-feeds-on-hashnode\"\u003eNext plans for the personalized feeds on hashnode\u003c/h2\u003e\n\u003cp\u003eNow that we have created an algorithm and prepared the groundwork, what comes next for our new personalized feed?\u003c/p\u003e\n\u003cp\u003eI assume you guessed it right:\u003c/p\u003e\n\u003cdiv class=\"embed-wrapper\"\u003e\u003cdiv class=\"embed-loading\"\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003cdiv class=\"loadingRow\"\u003e\u003c/div\u003e\u003c/div\u003e\u003ca class=\"embed-card\" href=\"https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif\"\u003ehttps://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif\u003c/a\u003e\u003c/div\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003eInitially, we only wanted to verify our assumptions about content and how to create a feed that engages users and shows high-quality and highly relevant articles from our Platform.\u003c/p\u003e\n\u003cp\u003eAs you can imagine, the calculation is expensive from a computational point of view. We need to gather the latest posts from our platform, collect data for the user, and calculate the scores for each post before we can serve them. It is also not as straightforward as it would be with a following feed. There, we could cache everything and append new posts on the top of the cache to be served on a request to the feed.\u003c/p\u003e\n\u003cp\u003eIn the case of a personalized feed, we need to have the user metadata at hand to correctly assign a score to the article for the user based on the algorithm.\u003c/p\u003e\n\u003cp\u003eGuess what? We've developed a nice solution that I'll dive into in another article! But here's a little sneak peek: We're pre-calculating the personalized feed for all our active users on the platform! This way, we can slash peak loads on our service and serve the feed at lightning-fast speeds! 🚀💥🏎️\u003c/p\u003e\n\u003cp\u003eUntil the next one,\u003c/p\u003e\n\u003cp\u003eCheers 🙌\u003c/p\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1693400623549/fb200935-78c6-42d1-bb7f-96b3bac6a128.jpeg"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"the-art-of-feed-curating-our-approach-to-generating-personalized-feeds-that-match-users-interests"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>