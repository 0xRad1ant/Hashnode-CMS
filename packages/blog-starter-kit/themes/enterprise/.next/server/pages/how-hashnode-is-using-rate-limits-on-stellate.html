<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>How Hashnode is using Rate Limits on Stellate | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/how-hashnode-is-using-rate-limits-on-stellate"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1683620389317/7a63a71e-63ea-4afe-afbf-44e7258996e6.png"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">How Hashnode is using Rate Limits on Stellate</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg" class="w-10 h-10 rounded-full" alt="Sandro Volpicella"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Sandro Volpicella</div></div><time dateTime="2023-05-10T15:00:34.500Z">May 10, 2023</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for How Hashnode is using Rate Limits on Stellate" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683620384065%2Fc2fc7e7d-8803-43b5-8fe9-fb80adb13552.png&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>Rate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.</p>
<p>Implementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazon WAF. But limiting requests based on other user identifiers such as user IDs in JWTs or authorization headers can get quite tricky.</p>
<p>That is where Stellate comes to the rescue ü¶∏üèΩ</p>
<h2 id="heading-our-architecture">Our Architecture</h2>
<p>A small primer to our architecture and all involved parts:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1682692856042/5d6a29e2-7910-4898-ba13-e5c376865343.png" alt="Overall Architecture of Hashnode" class="image--center mx-auto" /></p>
<p>We have two methods of accessing our API: either through <strong>client calls</strong> or via <strong>server-side-rendered</strong> calls from Vercel. Both pass through Stellate's Edge Cache and now also utilize their rate-limiting feature. Following this, we make calls to the API Gateway on AWS.</p>
<h2 id="heading-why-not-only-ip">Why not only IP?</h2>
<p>The first question we mostly got about rate limits is: <strong>Why don't you only rate limit on IP?</strong></p>
<p>While it makes sense to rate limit on the IP address it often is a misleading identifier. Due to the shortage of IPs, many mobile carriers or internet providers share the IP across several zones. Also, universities, dorms, and companies are often using the same IP. If we would rate limit this one IP the whole university couldn't access Hashnode anymore. This is not what we want.</p>
<h2 id="heading-why-rate-limits">Why Rate Limits?</h2>
<p>There are mainly two reasons why we need rate limits.</p>
<h3 id="heading-impact-on-the-database">Impact on the Database</h3>
<p>First of all, we want to secure our database. You don't want people to be able to hit your database constantly. This will incur costs and can lead to downtime.</p>
<p>Yes, caching is the number one thing to consider here. Stellate &amp; Vercel are helping us with that already. But rate limits also help by ensuring that nobody bombards your API. Everything that isn't cached (e.g. <code>Mutations</code> ) hits the DB directly. We want to avoid that.</p>
<h3 id="heading-impact-on-your-business">Impact on your Business</h3>
<p>The second reason is, you simply don't want that your product gets abused. We don't want an automatic generation of posts running in a script.</p>
<p>We need rate limits to ensure that nobody abuses our API and impacts the database.</p>
<h2 id="heading-stellate-rate-limiting">Stellate Rate Limiting</h2>
<p><a target="_blank" href="https://hshno.de/FEuPQqw">Stellate</a> is a CDN for GraphQL. It mainly offers the functionality of:</p>
<ol>
<li><p>Caching GQL Requests on the Edge</p>
</li>
<li><p>Analytics and errors about your API</p>
</li>
<li><p><strong>Rate Limiting</strong></p>
</li>
</ol>
<p>The rate-limiting feature is currently in its public beta phase. Check out their <a target="_blank" href="https://stellate.co/docs/graphql-rate-limiting">docs</a> for more information.</p>
<p>To enable rate limits you can simply add the <code>rateLimits</code> field to your Stellate config file (with TypeScript support! üòâ):</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { Config } <span class="hljs-keyword">from</span> <span class="hljs-string">'stellate'</span>

<span class="hljs-keyword">const</span> config: Config = {
  config: {
    rateLimits: [
      {
        name: <span class="hljs-string">'IP limit'</span>,
        groupBy: <span class="hljs-string">'ip'</span>,
        state: <span class="hljs-string">'dryRun'</span>,
        limit: {
          <span class="hljs-keyword">type</span>: <span class="hljs-string">'RequestCount'</span>,
          <span class="hljs-built_in">window</span>: <span class="hljs-string">'1m'</span>,
          budget: <span class="hljs-number">50</span>,
        },
      },
    ],
  },
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<p>The code above creates a rate limit of 50 requests for every minute. The state <code>dryRun</code> means that this rate limit is not really available. Your dashboard will only show you which requests <strong>would be blocked</strong> but they won't be blocked.</p>
<h3 id="heading-dry-run">Dry Run</h3>
<p>The dry run mode in Stellate is an excellent feature for gaining a better understanding of the appropriate rate limit. Once you've activated it you can head over to your Stellate Dashboard, check the rate limiting dashboard, and see how many requests and customers would have been blocked. But no request will be blocked.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1683730304530/43f124fa-0c60-45cd-ad65-349c519b54c1.png" alt="Dashboard for rate limits in Stellate" class="image--center mx-auto" /></p>
<p>You can also send requests from the Stellate playground or from the API Client of your choice (cURL, Postman, Insomnia) and check the remaining budget.</p>
<p>In this example, I query my blog. In the result window on the right, I can see that the rule "Unatuehtnicated IP Limit - Request Count" was applied. I have 1998 of 2000 requests remaining.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1683730422729/8174681d-0f43-4ab7-84bd-8718c7c40f7d.png" alt="a screenshot of a computer screen with a code on it" class="image--center mx-auto" /></p>
<h2 id="heading-rate-limits">Rate Limits</h2>
<p>So far the introduction. But how do we use rate limits at Hashnode? We distinguish mainly from two different limits:</p>
<ol>
<li><p>Authenticated access</p>
</li>
<li><p>Unauthenticated access</p>
</li>
</ol>
<h3 id="heading-authenticated-access">Authenticated Access</h3>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1682692491128/f9e5c284-f05a-4b31-b94b-b7864fef5352.png" class="image--center mx-auto" /></p>
<p>Authenticated access is everything where a token in a cookie or header is present. If this token is present we create a limit of 500 requests per minute.</p>
<pre><code class="lang-typescript">{
  name: <span class="hljs-string">'Authenticated User Limit - Request Count'</span>,
  groupBy: req.headers[<span class="hljs-string">'token'</span>],
  state: <span class="hljs-string">'enabled'</span>,
  limit: {
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'RequestCount'</span>,
    budget: <span class="hljs-number">500</span>,
    <span class="hljs-built_in">window</span>: <span class="hljs-string">'1m'</span>
  }
}
</code></pre>
<p>This defines that each header <code>token</code> will have a limit of 500 requests per minute. To test this out you can also make use of Stellate's dashboard.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1682686423313/c4a810dd-7ca7-4708-94e2-e0ff09c4588e.png" class="image--center mx-auto" /></p>
<p>Here we query my personal blog and access the <code>title</code>. At the bottom of the result, we can see the remaining limit. In this case, we have 499 of 500 requests left.</p>
<h3 id="heading-unauthenticated-access">Unauthenticated Access</h3>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1682692472212/9ce5d2c0-7b0b-4f76-a9d2-3859d67978bf.png" class="image--center mx-auto" /></p>
<p>Unauthenticated access, on the other hand, is everything without an authentication token. In this case we group by the IP address of the user. This limit has 2000 requests per minute.</p>
<p><strong>Why is this limit larger?</strong></p>
<p>First of all, unauthenticated requests are typically <em>cheaper</em> in terms of computational costs. Querying a blog vs. creating a blog is a huge difference.</p>
<p>The second reason is the reason of IP sharing. We saw a lot of cases in that IPs are shared. If this is the case we don't want to have a too tight budget. This is why we allow quite a bit more room for unauthenticated access.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1682686578720/b13b1d39-bc37-444e-92a1-2247ef026486.png" class="image--center mx-auto" /></p>
<h2 id="heading-rate-limits-amp-server-side-rendering">Rate Limits &amp; Server-Side Rendering</h2>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1682692505588/6c5f97dd-f5b1-44af-ae8a-487ac4da319a.png" class="image--center mx-auto" /></p>
<p>Hashnode makes heavy usage of Vercel and Server-Side Rendering (SSR). The problem with SSR &amp; Rate limiting is that many customers can visit blogs that will be server-side rendered from the same server. This will then come from the same IP address.</p>
<p>There are separate solutions to take care of that:</p>
<ol>
<li><p>Ignore SSR for rate limits</p>
</li>
<li><p>Forward the public IP &amp; authorization header (if present) to Stellate.</p>
</li>
<li><p>(New) With <a target="_blank" href="https://hshno.de/jRSvsUN">Vercel Secure Compute</a> assign a fixed IP to Vercel and whitelist this one</p>
</li>
</ol>
<p>We opted for the first solution, ignoring all SSR calls. We primarily chose this option because we wanted to address rate limiting for the API. This is also a preparatory step for making our API publicly available. It is not specifically intended to rate limit the client's usage.</p>
<p>You can do that by defining a secret between Vercel &amp; Stellate. This secret can for example be a header you'll forward to each API Requests.</p>
<blockquote>
<p>‚ö†Ô∏è Be aware that this header needs to be treated as a secret. You can only send it from the server side <strong>not</strong> from the client side.</p>
</blockquote>
<p>In Stellate you can then define the following:</p>
<pre><code class="lang-typescript">      <span class="hljs-keyword">if</span> (
        req.headers[<span class="hljs-string">'ssr-call'</span>] &amp;&amp;
        req.headers[<span class="hljs-string">'ssr-call'</span>] === <span class="hljs-string">"123"</span>
      ) {
        <span class="hljs-keyword">return</span> [];
      }
</code></pre>
<p>This will return no rate limit in case the call is coming from Vercel.</p>
<h2 id="heading-block-ips">Block IPs</h2>
<p>One more remarkable feature is the ability to block individual IP addresses. Unfortunately, we face attacks quite frequently. Often, these attacks originate from a single IP address. Blocking such an IP address using rate limits is incredibly simple:</p>
<pre><code class="lang-typescript">      <span class="hljs-keyword">if</span> (ipListToBlock.includes(req.ip)) {
        <span class="hljs-keyword">return</span> [
          {
            name: <span class="hljs-string">'Blocked IP limit'</span>,
            groupBy: <span class="hljs-string">'ip'</span>,
            state: <span class="hljs-string">'enabled'</span>,
            limit: {
              <span class="hljs-keyword">type</span>: <span class="hljs-string">'RequestCount'</span>,
              budget: <span class="hljs-number">0</span>,
              <span class="hljs-built_in">window</span>: <span class="hljs-string">'1m'</span>
            }
          }
        ];
      }
</code></pre>
<h2 id="heading-thats-it">That's it üéâ</h2>
<p>That is all about rate limits.</p>
<p>It already saved us from a huge abusive spike in traffic to our API and it is super easy to implement!</p>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>¬© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"how-hashnode-is-using-rate-limits-on-stellate","url":"https://engineering.hashnode.com/how-hashnode-is-using-rate-limits-on-stellate","brief":"Rate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.\nImplementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazo...","title":"How Hashnode is using Rate Limits on Stellate","publishedAt":"2023-05-10T15:00:34.500Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683620384065/c2fc7e7d-8803-43b5-8fe9-fb80adb13552.png"},"author":{"name":"Sandro Volpicella","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg"},"id":"645bb1927c65daa656f54d96","content":{"markdown":"Rate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.\n\nImplementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazon WAF. But limiting requests based on other user identifiers such as user IDs in JWTs or authorization headers can get quite tricky.\n\nThat is where Stellate comes to the rescue ü¶∏üèΩ\n\n## Our Architecture\n\nA small primer to our architecture and all involved parts:\n\n![Overall Architecture of Hashnode](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692856042/5d6a29e2-7910-4898-ba13-e5c376865343.png align=\"center\")\n\nWe have two methods of accessing our API: either through **client calls** or via **server-side-rendered** calls from Vercel. Both pass through Stellate's Edge Cache and now also utilize their rate-limiting feature. Following this, we make calls to the API Gateway on AWS.\n\n## Why not only IP?\n\nThe first question we mostly got about rate limits is: **Why don't you only rate limit on IP?**\n\nWhile it makes sense to rate limit on the IP address it often is a misleading identifier. Due to the shortage of IPs, many mobile carriers or internet providers share the IP across several zones. Also, universities, dorms, and companies are often using the same IP. If we would rate limit this one IP the whole university couldn't access Hashnode anymore. This is not what we want.\n\n## Why Rate Limits?\n\nThere are mainly two reasons why we need rate limits.\n\n### Impact on the Database\n\nFirst of all, we want to secure our database. You don't want people to be able to hit your database constantly. This will incur costs and can lead to downtime.\n\nYes, caching is the number one thing to consider here. Stellate \u0026 Vercel are helping us with that already. But rate limits also help by ensuring that nobody bombards your API. Everything that isn't cached (e.g. `Mutations` ) hits the DB directly. We want to avoid that.\n\n### Impact on your Business\n\nThe second reason is, you simply don't want that your product gets abused. We don't want an automatic generation of posts running in a script.\n\nWe need rate limits to ensure that nobody abuses our API and impacts the database.\n\n## Stellate Rate Limiting\n\n[Stellate](https://hshno.de/FEuPQqw) is a CDN for GraphQL. It mainly offers the functionality of:\n\n1. Caching GQL Requests on the Edge\n    \n2. Analytics and errors about your API\n    \n3. **Rate Limiting**\n    \n\nThe rate-limiting feature is currently in its public beta phase. Check out their [docs](https://stellate.co/docs/graphql-rate-limiting) for more information.\n\nTo enable rate limits you can simply add the `rateLimits` field to your Stellate config file (with TypeScript support! üòâ):\n\n```typescript\nimport { Config } from 'stellate'\n\nconst config: Config = {\n  config: {\n    rateLimits: [\n      {\n        name: 'IP limit',\n        groupBy: 'ip',\n        state: 'dryRun',\n        limit: {\n          type: 'RequestCount',\n          window: '1m',\n          budget: 50,\n        },\n      },\n    ],\n  },\n}\nexport default config\n```\n\nThe code above creates a rate limit of 50 requests for every minute. The state `dryRun` means that this rate limit is not really available. Your dashboard will only show you which requests **would be blocked** but they won't be blocked.\n\n### Dry Run\n\nThe dry run mode in Stellate is an excellent feature for gaining a better understanding of the appropriate rate limit. Once you've activated it you can head over to your Stellate Dashboard, check the rate limiting dashboard, and see how many requests and customers would have been blocked. But no request will be blocked.\n\n![Dashboard for rate limits in Stellate](https://cdn.hashnode.com/res/hashnode/image/upload/v1683730304530/43f124fa-0c60-45cd-ad65-349c519b54c1.png align=\"center\")\n\nYou can also send requests from the Stellate playground or from the API Client of your choice (cURL, Postman, Insomnia) and check the remaining budget.\n\nIn this example, I query my blog. In the result window on the right, I can see that the rule \"Unatuehtnicated IP Limit - Request Count\" was applied. I have 1998 of 2000 requests remaining.\n\n![a screenshot of a computer screen with a code on it](https://cdn.hashnode.com/res/hashnode/image/upload/v1683730422729/8174681d-0f43-4ab7-84bd-8718c7c40f7d.png align=\"center\")\n\n## Rate Limits\n\nSo far the introduction. But how do we use rate limits at Hashnode? We distinguish mainly from two different limits:\n\n1. Authenticated access\n    \n2. Unauthenticated access\n    \n\n### Authenticated Access\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692491128/f9e5c284-f05a-4b31-b94b-b7864fef5352.png align=\"center\")\n\nAuthenticated access is everything where a token in a cookie or header is present. If this token is present we create a limit of 500 requests per minute.\n\n```typescript\n{\n  name: 'Authenticated User Limit - Request Count',\n  groupBy: req.headers['token'],\n  state: 'enabled',\n  limit: {\n    type: 'RequestCount',\n    budget: 500,\n    window: '1m'\n  }\n}\n```\n\nThis defines that each header `token` will have a limit of 500 requests per minute. To test this out you can also make use of Stellate's dashboard.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682686423313/c4a810dd-7ca7-4708-94e2-e0ff09c4588e.png align=\"center\")\n\nHere we query my personal blog and access the `title`. At the bottom of the result, we can see the remaining limit. In this case, we have 499 of 500 requests left.\n\n### Unauthenticated Access\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692472212/9ce5d2c0-7b0b-4f76-a9d2-3859d67978bf.png align=\"center\")\n\nUnauthenticated access, on the other hand, is everything without an authentication token. In this case we group by the IP address of the user. This limit has 2000 requests per minute.\n\n**Why is this limit larger?**\n\nFirst of all, unauthenticated requests are typically *cheaper* in terms of computational costs. Querying a blog vs. creating a blog is a huge difference.\n\nThe second reason is the reason of IP sharing. We saw a lot of cases in that IPs are shared. If this is the case we don't want to have a too tight budget. This is why we allow quite a bit more room for unauthenticated access.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682686578720/b13b1d39-bc37-444e-92a1-2247ef026486.png align=\"center\")\n\n## Rate Limits \u0026 Server-Side Rendering\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1682692505588/6c5f97dd-f5b1-44af-ae8a-487ac4da319a.png align=\"center\")\n\nHashnode makes heavy usage of Vercel and Server-Side Rendering (SSR). The problem with SSR \u0026 Rate limiting is that many customers can visit blogs that will be server-side rendered from the same server. This will then come from the same IP address.\n\nThere are separate solutions to take care of that:\n\n1. Ignore SSR for rate limits\n    \n2. Forward the public IP \u0026 authorization header (if present) to Stellate.\n    \n3. (New) With [Vercel Secure Compute](https://hshno.de/jRSvsUN) assign a fixed IP to Vercel and whitelist this one\n    \n\nWe opted for the first solution, ignoring all SSR calls. We primarily chose this option because we wanted to address rate limiting for the API. This is also a preparatory step for making our API publicly available. It is not specifically intended to rate limit the client's usage.\n\nYou can do that by defining a secret between Vercel \u0026 Stellate. This secret can for example be a header you'll forward to each API Requests.\n\n\u003e ‚ö†Ô∏è Be aware that this header needs to be treated as a secret. You can only send it from the server side **not** from the client side.\n\nIn Stellate you can then define the following:\n\n```typescript\n      if (\n        req.headers['ssr-call'] \u0026\u0026\n        req.headers['ssr-call'] === \"123\"\n      ) {\n        return [];\n      }\n```\n\nThis will return no rate limit in case the call is coming from Vercel.\n\n## Block IPs\n\nOne more remarkable feature is the ability to block individual IP addresses. Unfortunately, we face attacks quite frequently. Often, these attacks originate from a single IP address. Blocking such an IP address using rate limits is incredibly simple:\n\n```typescript\n      if (ipListToBlock.includes(req.ip)) {\n        return [\n          {\n            name: 'Blocked IP limit',\n            groupBy: 'ip',\n            state: 'enabled',\n            limit: {\n              type: 'RequestCount',\n              budget: 0,\n              window: '1m'\n            }\n          }\n        ];\n      }\n```\n\n## That's it üéâ\n\nThat is all about rate limits.\n\nIt already saved us from a huge abusive spike in traffic to our API and it is super easy to implement!","html":"\u003cp\u003eRate Limits are a vital part of every API. Especially, since we operate quite a lot of public and unprotected APIs we need to rate limit them.\u003c/p\u003e\n\u003cp\u003eImplementing Rate limits based on IP addresses is fairly easy, especially with Amazon API Gateway and Amazon WAF. But limiting requests based on other user identifiers such as user IDs in JWTs or authorization headers can get quite tricky.\u003c/p\u003e\n\u003cp\u003eThat is where Stellate comes to the rescue ü¶∏üèΩ\u003c/p\u003e\n\u003ch2 id=\"heading-our-architecture\"\u003eOur Architecture\u003c/h2\u003e\n\u003cp\u003eA small primer to our architecture and all involved parts:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692856042/5d6a29e2-7910-4898-ba13-e5c376865343.png\" alt=\"Overall Architecture of Hashnode\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eWe have two methods of accessing our API: either through \u003cstrong\u003eclient calls\u003c/strong\u003e or via \u003cstrong\u003eserver-side-rendered\u003c/strong\u003e calls from Vercel. Both pass through Stellate's Edge Cache and now also utilize their rate-limiting feature. Following this, we make calls to the API Gateway on AWS.\u003c/p\u003e\n\u003ch2 id=\"heading-why-not-only-ip\"\u003eWhy not only IP?\u003c/h2\u003e\n\u003cp\u003eThe first question we mostly got about rate limits is: \u003cstrong\u003eWhy don't you only rate limit on IP?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhile it makes sense to rate limit on the IP address it often is a misleading identifier. Due to the shortage of IPs, many mobile carriers or internet providers share the IP across several zones. Also, universities, dorms, and companies are often using the same IP. If we would rate limit this one IP the whole university couldn't access Hashnode anymore. This is not what we want.\u003c/p\u003e\n\u003ch2 id=\"heading-why-rate-limits\"\u003eWhy Rate Limits?\u003c/h2\u003e\n\u003cp\u003eThere are mainly two reasons why we need rate limits.\u003c/p\u003e\n\u003ch3 id=\"heading-impact-on-the-database\"\u003eImpact on the Database\u003c/h3\u003e\n\u003cp\u003eFirst of all, we want to secure our database. You don't want people to be able to hit your database constantly. This will incur costs and can lead to downtime.\u003c/p\u003e\n\u003cp\u003eYes, caching is the number one thing to consider here. Stellate \u0026amp; Vercel are helping us with that already. But rate limits also help by ensuring that nobody bombards your API. Everything that isn't cached (e.g. \u003ccode\u003eMutations\u003c/code\u003e ) hits the DB directly. We want to avoid that.\u003c/p\u003e\n\u003ch3 id=\"heading-impact-on-your-business\"\u003eImpact on your Business\u003c/h3\u003e\n\u003cp\u003eThe second reason is, you simply don't want that your product gets abused. We don't want an automatic generation of posts running in a script.\u003c/p\u003e\n\u003cp\u003eWe need rate limits to ensure that nobody abuses our API and impacts the database.\u003c/p\u003e\n\u003ch2 id=\"heading-stellate-rate-limiting\"\u003eStellate Rate Limiting\u003c/h2\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://hshno.de/FEuPQqw\"\u003eStellate\u003c/a\u003e is a CDN for GraphQL. It mainly offers the functionality of:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eCaching GQL Requests on the Edge\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAnalytics and errors about your API\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eRate Limiting\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe rate-limiting feature is currently in its public beta phase. Check out their \u003ca target=\"_blank\" href=\"https://stellate.co/docs/graphql-rate-limiting\"\u003edocs\u003c/a\u003e for more information.\u003c/p\u003e\n\u003cp\u003eTo enable rate limits you can simply add the \u003ccode\u003erateLimits\u003c/code\u003e field to your Stellate config file (with TypeScript support! üòâ):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { Config } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'stellate'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config: Config = {\n  config: {\n    rateLimits: [\n      {\n        name: \u003cspan class=\"hljs-string\"\u003e'IP limit'\u003c/span\u003e,\n        groupBy: \u003cspan class=\"hljs-string\"\u003e'ip'\u003c/span\u003e,\n        state: \u003cspan class=\"hljs-string\"\u003e'dryRun'\u003c/span\u003e,\n        limit: {\n          \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'RequestCount'\u003c/span\u003e,\n          \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'1m'\u003c/span\u003e,\n          budget: \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\n        },\n      },\n    ],\n  },\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e config\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe code above creates a rate limit of 50 requests for every minute. The state \u003ccode\u003edryRun\u003c/code\u003e means that this rate limit is not really available. Your dashboard will only show you which requests \u003cstrong\u003ewould be blocked\u003c/strong\u003e but they won't be blocked.\u003c/p\u003e\n\u003ch3 id=\"heading-dry-run\"\u003eDry Run\u003c/h3\u003e\n\u003cp\u003eThe dry run mode in Stellate is an excellent feature for gaining a better understanding of the appropriate rate limit. Once you've activated it you can head over to your Stellate Dashboard, check the rate limiting dashboard, and see how many requests and customers would have been blocked. But no request will be blocked.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683730304530/43f124fa-0c60-45cd-ad65-349c519b54c1.png\" alt=\"Dashboard for rate limits in Stellate\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eYou can also send requests from the Stellate playground or from the API Client of your choice (cURL, Postman, Insomnia) and check the remaining budget.\u003c/p\u003e\n\u003cp\u003eIn this example, I query my blog. In the result window on the right, I can see that the rule \"Unatuehtnicated IP Limit - Request Count\" was applied. I have 1998 of 2000 requests remaining.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683730422729/8174681d-0f43-4ab7-84bd-8718c7c40f7d.png\" alt=\"a screenshot of a computer screen with a code on it\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-rate-limits\"\u003eRate Limits\u003c/h2\u003e\n\u003cp\u003eSo far the introduction. But how do we use rate limits at Hashnode? We distinguish mainly from two different limits:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eAuthenticated access\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUnauthenticated access\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"heading-authenticated-access\"\u003eAuthenticated Access\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692491128/f9e5c284-f05a-4b31-b94b-b7864fef5352.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eAuthenticated access is everything where a token in a cookie or header is present. If this token is present we create a limit of 500 requests per minute.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e{\n  name: \u003cspan class=\"hljs-string\"\u003e'Authenticated User Limit - Request Count'\u003c/span\u003e,\n  groupBy: req.headers[\u003cspan class=\"hljs-string\"\u003e'token'\u003c/span\u003e],\n  state: \u003cspan class=\"hljs-string\"\u003e'enabled'\u003c/span\u003e,\n  limit: {\n    \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'RequestCount'\u003c/span\u003e,\n    budget: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e,\n    \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'1m'\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis defines that each header \u003ccode\u003etoken\u003c/code\u003e will have a limit of 500 requests per minute. To test this out you can also make use of Stellate's dashboard.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682686423313/c4a810dd-7ca7-4708-94e2-e0ff09c4588e.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eHere we query my personal blog and access the \u003ccode\u003etitle\u003c/code\u003e. At the bottom of the result, we can see the remaining limit. In this case, we have 499 of 500 requests left.\u003c/p\u003e\n\u003ch3 id=\"heading-unauthenticated-access\"\u003eUnauthenticated Access\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692472212/9ce5d2c0-7b0b-4f76-a9d2-3859d67978bf.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eUnauthenticated access, on the other hand, is everything without an authentication token. In this case we group by the IP address of the user. This limit has 2000 requests per minute.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhy is this limit larger?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFirst of all, unauthenticated requests are typically \u003cem\u003echeaper\u003c/em\u003e in terms of computational costs. Querying a blog vs. creating a blog is a huge difference.\u003c/p\u003e\n\u003cp\u003eThe second reason is the reason of IP sharing. We saw a lot of cases in that IPs are shared. If this is the case we don't want to have a too tight budget. This is why we allow quite a bit more room for unauthenticated access.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682686578720/b13b1d39-bc37-444e-92a1-2247ef026486.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-rate-limits-andamp-server-side-rendering\"\u003eRate Limits \u0026amp; Server-Side Rendering\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1682692505588/6c5f97dd-f5b1-44af-ae8a-487ac4da319a.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eHashnode makes heavy usage of Vercel and Server-Side Rendering (SSR). The problem with SSR \u0026amp; Rate limiting is that many customers can visit blogs that will be server-side rendered from the same server. This will then come from the same IP address.\u003c/p\u003e\n\u003cp\u003eThere are separate solutions to take care of that:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eIgnore SSR for rate limits\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eForward the public IP \u0026amp; authorization header (if present) to Stellate.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e(New) With \u003ca target=\"_blank\" href=\"https://hshno.de/jRSvsUN\"\u003eVercel Secure Compute\u003c/a\u003e assign a fixed IP to Vercel and whitelist this one\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWe opted for the first solution, ignoring all SSR calls. We primarily chose this option because we wanted to address rate limiting for the API. This is also a preparatory step for making our API publicly available. It is not specifically intended to rate limit the client's usage.\u003c/p\u003e\n\u003cp\u003eYou can do that by defining a secret between Vercel \u0026amp; Stellate. This secret can for example be a header you'll forward to each API Requests.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e‚ö†Ô∏è Be aware that this header needs to be treated as a secret. You can only send it from the server side \u003cstrong\u003enot\u003c/strong\u003e from the client side.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn Stellate you can then define the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        req.headers[\u003cspan class=\"hljs-string\"\u003e'ssr-call'\u003c/span\u003e] \u0026amp;\u0026amp;\n        req.headers[\u003cspan class=\"hljs-string\"\u003e'ssr-call'\u003c/span\u003e] === \u003cspan class=\"hljs-string\"\u003e\"123\"\u003c/span\u003e\n      ) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [];\n      }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will return no rate limit in case the call is coming from Vercel.\u003c/p\u003e\n\u003ch2 id=\"heading-block-ips\"\u003eBlock IPs\u003c/h2\u003e\n\u003cp\u003eOne more remarkable feature is the ability to block individual IP addresses. Unfortunately, we face attacks quite frequently. Often, these attacks originate from a single IP address. Blocking such an IP address using rate limits is incredibly simple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ipListToBlock.includes(req.ip)) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n          {\n            name: \u003cspan class=\"hljs-string\"\u003e'Blocked IP limit'\u003c/span\u003e,\n            groupBy: \u003cspan class=\"hljs-string\"\u003e'ip'\u003c/span\u003e,\n            state: \u003cspan class=\"hljs-string\"\u003e'enabled'\u003c/span\u003e,\n            limit: {\n              \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'RequestCount'\u003c/span\u003e,\n              budget: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n              \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'1m'\u003c/span\u003e\n            }\n          }\n        ];\n      }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"heading-thats-it\"\u003eThat's it üéâ\u003c/h2\u003e\n\u003cp\u003eThat is all about rate limits.\u003c/p\u003e\n\u003cp\u003eIt already saved us from a huge abusive spike in traffic to our API and it is super easy to implement!\u003c/p\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683620389317/7a63a71e-63ea-4afe-afbf-44e7258996e6.png"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"how-hashnode-is-using-rate-limits-on-stellate"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>