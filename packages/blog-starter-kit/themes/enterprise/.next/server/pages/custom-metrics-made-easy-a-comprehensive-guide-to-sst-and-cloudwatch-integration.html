<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>Custom Metrics Made Easy: A Comprehensive Guide to SST and CloudWatch Integration | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/custom-metrics-made-easy-a-comprehensive-guide-to-sst-and-cloudwatch-integration"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1680672912724/f670a27e-3267-4bed-9f05-500df64cfbc9.png"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">Custom Metrics Made Easy: A Comprehensive Guide to SST and CloudWatch Integration</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1663070035311/JaSbIMfve.jpg" class="w-10 h-10 rounded-full" alt="Shad Mirza"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Shad Mirza</div></div><time dateTime="2023-04-19T06:00:13.019Z">April 18, 2023</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for Custom Metrics Made Easy: A Comprehensive Guide to SST and CloudWatch Integration" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1680672874136%2Ff3bfe7ef-8741-4236-b798-012fa2687f0b.png&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>Monitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the performance of your resources. One of these services is CloudWatch, which allows you to collect and track metrics, collect and monitor log files, and set alarms for all the AWS Services.</p>
<p>This article will discuss such metrics, specially custom metrics in depth. We will also understand when they can be helpful, and how to add them to using SST. At last, we will look at how we use them at Hashnode.</p>
<p>Let's start by understanding the platform <a target="_blank" href="https://sst.dev/">Serverless Stack (SST)</a> and how it helps in developing serverless applications.</p>
<h2 id="heading-what-is-sst">What is SST</h2>
<p><a target="_blank" href="https://sst.dev/">SST (Serverless Stack)</a> simplifies developing and deploying AWS applications. SST's construct makes it easy to add features with very few lines of code.</p>
<p>The <code>create-sst</code> CLI helps us create a new SST app with a basic structure. The <code>cd</code> command changes the current directory to the new app and <code>npm install</code> will install the required dependencies.<br />Finally, you can run <code>sst start</code> to deploy your sandbox environment to AWS and start your debug stack.</p>
<pre><code class="lang-bash">npx create-sst@latest my-sst-app

<span class="hljs-built_in">cd</span> my-sst-app
npm install

npx sst dev
</code></pre>
<p>The CLI will ask you to pick a stage name which can be your name. Once the setup is complete, the app will be deployed to AWS and connected to the local machine. You can then jump to the SST console <a target="_blank" href="https://console.sst.dev/">https://console.sst.dev/</a> which will stream all the logs.</p>
<h2 id="heading-what-are-custom-metrics-and-when-to-use-them">What are Custom Metrics and When To Use Them</h2>
<p>Custom metrics allow us to monitor specific aspects of your application beyond the scope of default metrics provided by AWS. The default metrics provided by CloudWatch include instance metrics, traffic mirroring metrics, error metrics, etc. Still, we might need more information about our serverless app.</p>
<p>Custom Metrics come in handy when we need a piece of more specific information like the number of times an API is called, the origin of requests, requests that resulted in a particular error code, metrics with additional information, etc. Custom metrics can provide more context to your metrics by adding custom dimensions that help you filter and group your metrics in CloudWatch.</p>
<p>It can help in various other aspects like analyzing data over a period of time, creating alarms based on specific thresholds of error requests, number of concurrent users, etc. Custom metrics provide granular control over the aspects of the serverless applications we want to measure. It's up to us to get the insights that help us improve the performance and manage the application.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676190070152/488cc3a7-833a-42ee-be1a-872280edb87c.png?auto=compress,format&amp;format=webp&amp;auto=compress,format&amp;format=webp" alt="Graphic taken from https://blog.awsfundamentals.com" /></p>
<h2 id="heading-creating-custom-metrics-with-sst-and-cloudwatch">Creating Custom Metrics with SST and CloudWatch</h2>
<p>There are mainly three ways to create custom metrics in CloudWatch.</p>
<ul>
<li><p>API</p>
</li>
<li><p>CLI</p>
</li>
<li><p>Embedded Metric Format (EMF)</p>
</li>
</ul>
<p>We are interested in using EMF for the scope of this article.</p>
<p><strong>Embedded Metric Format (EMF)</strong> is a format that is used to send custom metrics to CloudWatch. CloudWatch can automatically extract custom metrics based on the logs it receives in Embedded Metric Format, allowing us to add alarms or visualise them in detail.</p>
<p>EMF is particularly useful when sending a large number of custom metrics, as it allows you to send them in batches via logs. An embedded metric format looks like this:</p>
<pre><code class="lang-json">{
  <span class="hljs-attr">"_aws"</span>: {
    <span class="hljs-attr">"Timestamp"</span>: <span class="hljs-number">1574109732004</span>,
    <span class="hljs-attr">"CloudWatchMetrics"</span>: [
      {
        <span class="hljs-attr">"Namespace"</span>: <span class="hljs-string">"lambda-function-metrics"</span>,
        <span class="hljs-attr">"Dimensions"</span>: [[<span class="hljs-string">"functionVersion"</span>]],
        <span class="hljs-attr">"Metrics"</span>: [
          {
            <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"time"</span>,
            <span class="hljs-attr">"Unit"</span>: <span class="hljs-string">"Milliseconds"</span>,
            <span class="hljs-attr">"StorageResolution"</span>: <span class="hljs-number">60</span>
          }
        ]
      }
    ]
  },
  <span class="hljs-attr">"functionVersion"</span>: <span class="hljs-string">"$LATEST"</span>,
  <span class="hljs-attr">"time"</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">"requestId"</span>: <span class="hljs-string">"989ffbf8-9ace-4817-a57c-e4dd734019ee"</span>
}
</code></pre>
<blockquote>
<p><a target="_blank" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html">Refer to this documentation for detailed specification on EMF</a></p>
</blockquote>
<h2 id="heading-sending-custom-metrics-to-cloudwatch">Sending Custom Metrics to CloudWatch</h2>
<p>We use AWS Lambda Powertool to send custom metrics to CloudWatch. Using the <code>@aws-lambda-powertools/metrics</code> library, you can use the <code>Metrics</code> class provided by the library. Here is an example of how to send a custom metric to CloudWatch using <code>@aws-lambda-powertools/metrics</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { Metrics, MetricUnits } <span class="hljs-keyword">from</span> <span class="hljs-string">"@aws-lambda-powertools/metrics"</span>;

<span class="hljs-keyword">const</span> metrics = <span class="hljs-keyword">new</span> Metrics({
  <span class="hljs-attr">namespace</span>: <span class="hljs-string">"hashnode"</span>,
  <span class="hljs-attr">serviceName</span>: <span class="hljs-string">"graphql"</span>,
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> singleMetric = metrics.singleMetric();
  singleMetric.addDimension(<span class="hljs-string">'origin'</span>, <span class="hljs-string">'app'</span>);
  singleMetric.addMetric(<span class="hljs-string">'count'</span>, MetricUnits.Count, <span class="hljs-number">1</span>);
  metrics.publishStoredMetrics();
};
</code></pre>
<p>In the example above, we have defined the custom metric with namespace, dimension and unit. Let's understand them a little better:</p>
<h3 id="heading-1-namespaces">1. Namespaces</h3>
<p>A namespace is a container for CloudWatch metrics. We can create multiple namespaces for different metrics and distinguish them from each other. For example, AWS Amplify stores the metrics under <code>AWS/AmplifyHosting</code> namespace.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1679914036400/2153463e-88b2-48ee-8a3e-58ea47cfea3f.png" class="image--center mx-auto" /></p>
<p>In the above example, we are creating a custom namespace <code>hashnode</code> to group all the Hashnode-related metrics. It will look something like this on the console:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1679914124331/833ae87c-1c62-4e19-9903-e1f79db701ff.png" class="image--center mx-auto" /></p>
<h3 id="heading-2-dimensions">2. Dimensions</h3>
<p>A dimension is a name-value pair that help us describe and categorise the metric. Custom dimensions are additional information that helps us filter and group metrics in CloudWatch.<br />In the above example, we are adding a dimension <code>origin</code> to track the origin of a request. This <code>origin</code> dimension can be used to group and filter metrics by the origin of the request. Another example of dimension could be adding <code>stage</code> property, which keeps track of the environment of the request. It can be <code>production</code>, <code>dev</code>, or <code>staging</code> which can further be used for filtering or sorting.<br />It will appear like this in the AWS console:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1679980280508/49a0eb8b-cf4d-49e4-87f0-55b0a60d1fea.png" class="image--center mx-auto" /></p>
<h3 id="heading-3-units">3. Units</h3>
<p>A unit is simply the data type we use as a measure. A unit can be <code>Bytes</code>, <code>Seconds</code>, <code>Microseconds</code>, <code>Count</code> and <code>Percent</code>, etc. In our case, we are using <code>Count</code> as a unit and setting its value to one.</p>
<blockquote>
<p><a target="_blank" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">Complete list of supported units can be found here.</a></p>
</blockquote>
<p>The resulting log will look something like this in the embedded metric format:</p>
<pre><code class="lang-json">{
    <span class="hljs-attr">"_aws"</span>: {
        <span class="hljs-attr">"Timestamp"</span>: <span class="hljs-number">1679312949002</span>,
        <span class="hljs-attr">"CloudWatchMetrics"</span>: [
            {
                <span class="hljs-attr">"Namespace"</span>: <span class="hljs-string">"hashnode"</span>,
                <span class="hljs-attr">"Dimensions"</span>: [
                    [
                        <span class="hljs-string">"origin"</span>
                    ]
                ],
                <span class="hljs-attr">"Metrics"</span>: [
                    {
                        <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"count"</span>,
                        <span class="hljs-attr">"Unit"</span>: <span class="hljs-string">"Count"</span>
                    }
                ]
            }
        ]
    },
    <span class="hljs-attr">"service"</span>: <span class="hljs-string">"graphql"</span>,
    <span class="hljs-attr">"order"</span>: <span class="hljs-number">1</span>
}
</code></pre>
<h2 id="heading-how-to-check-custom-metrics-on-cloudwatch">How to Check Custom Metrics on CloudWatch</h2>
<p>Once we are done with adding custom metrics, we can head over to CloudWatch to check the logs. Go to <a target="_blank" href="https://us-east-1.console.aws.amazon.com/cloudwatch/home?region=us-east-1#metricsV2:graph=~()">the metrics overview</a> in CloudWatch and find the custom namespace we just added.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1679312473318/9fb3fab6-6645-4e94-b960-f8c6a0799621.png" class="image--center mx-auto" /></p>
<p>If you click on the namespaces, you will see your metrics.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1679915022589/35fccffe-b78d-49f4-9509-d6db2f064242.png" class="image--center mx-auto" /></p>
<h2 id="heading-how-we-are-using-custom-metrics-at-hashnode">How We Are Using Custom Metrics at Hashnode</h2>
<p>At Hashnode, we use custom metrics in multiple ways. Let's delve into some of these metrics and explore them thoroughly.</p>
<h3 id="heading-tracking-origins-of-graphql-requests">Tracking Origins of GraphQL Requests</h3>
<p>We use GraphQL APIs at Hashnode, which are utilized by multiple apps, including the community front, the blog front, and the mobile app. Knowing the origin of these requests is essential to allocate resources accordingly. Custom Metrics help us identify the number of requests originating per app.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1680765732583/d629e77a-dbf8-4b6c-a412-4400a7546510.png" alt="Table of API origin, stage and count organised by origin" class="image--center mx-auto" /></p>
<h3 id="heading-tracking-application-version-and-os-for-mobile-app">Tracking Application Version and OS for Mobile App</h3>
<p>We use custom metrics to track usage by each application version and OS for Hashnode mobile app. Multiple active mobile app versions can be installed on different devices on different platforms. Custom Metrics have proven invaluable in providing great insight into the mobile app user base.</p>
<h3 id="heading-tracking-errors-via-error-code">Tracking Errors via Error Code</h3>
<p>We use custom metrics to record errors by error codes and rearrange them for easy monitoring. We can get insights about errors thrown per app/lambda categorized by the error code.<br />Metrics associated with error codes allow us to have precise control over what occurs during an incident. For instance, we can associate a 5xx error code with an AWS alarm that can heighten the issue and notify the team during downtime. Refer to the next section for more info on how to use alarms with metrics.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1680765483642/8d9b5cf1-3d5f-4c53-8ccb-7236d053aec7.png" alt="Table of API and Metrics organised by error code" class="image--center mx-auto" /></p>
<h3 id="heading-using-data-to-set-alarms">Using Data to Set Alarms</h3>
<p>We utilize the historical data of the metric when monitoring errors by error code, and set up alarms to notify us when it surpasses a certain threshold.<br />For example, we define threshold as <code>"Errors &gt;= 1 for 1 datapoints within 1 minute"</code> under conditions while creating an alarm. This will ensure that the associated action is triggered when the threshold is reached.<br />The action can be enabled to send one or more notifications via SNS informing the person on-call.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1680765777862/7d348157-8bd3-4df9-8dbf-e9cf10c67959.png" alt="Screenshot showing usage of Metrics to set alarms under conditions and enable actions" class="image--center mx-auto" /></p>
<h2 id="heading-conclusion">Conclusion</h2>
<p>Adding custom metrics to your serverless application is essential for monitoring and optimizing its performance. Embedded Metric Format provides an easy way to send logs and extract custom metrics to CloudWatch for monitoring. We also learned how we utilize custom metrics at hashnode.</p>
<p>Do let us know if this article was helpful in the comments.</p>
<blockquote>
<p><a target="_blank" href="https://blog.awsfundamentals.com/optimize-your-application-monitoring-with-cloudwatch-custom-metrics">Checkout this article for a more detailed guide on Custom Metrics</a>.</p>
</blockquote>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"custom-metrics-made-easy-a-comprehensive-guide-to-sst-and-cloudwatch-integration","url":"https://engineering.hashnode.com/custom-metrics-made-easy-a-comprehensive-guide-to-sst-and-cloudwatch-integration","brief":"Monitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the perfo...","title":"Custom Metrics Made Easy: A Comprehensive Guide to SST and CloudWatch Integration","publishedAt":"2023-04-19T06:00:13.019Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1680672874136/f3bfe7ef-8741-4236-b798-012fa2687f0b.png"},"author":{"name":"Shad Mirza","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1663070035311/JaSbIMfve.jpg"},"id":"643f836df032a1495fab9abe","content":{"markdown":"Monitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the performance of your resources. One of these services is CloudWatch, which allows you to collect and track metrics, collect and monitor log files, and set alarms for all the AWS Services.\n\nThis article will discuss such metrics, specially custom metrics in depth. We will also understand when they can be helpful, and how to add them to using SST. At last, we will look at how we use them at Hashnode.\n\nLet's start by understanding the platform [Serverless Stack (SST)](https://sst.dev/) and how it helps in developing serverless applications.\n\n## What is SST\n\n[SST (Serverless Stack)](https://sst.dev/) simplifies developing and deploying AWS applications. SST's construct makes it easy to add features with very few lines of code.\n\nThe `create-sst` CLI helps us create a new SST app with a basic structure. The `cd` command changes the current directory to the new app and `npm install` will install the required dependencies.  \nFinally, you can run `sst start` to deploy your sandbox environment to AWS and start your debug stack.\n\n```bash\nnpx create-sst@latest my-sst-app\n\ncd my-sst-app\nnpm install\n\nnpx sst dev\n```\n\nThe CLI will ask you to pick a stage name which can be your name. Once the setup is complete, the app will be deployed to AWS and connected to the local machine. You can then jump to the SST console [https://console.sst.dev/](https://console.sst.dev/) which will stream all the logs.\n\n## What are Custom Metrics and When To Use Them\n\nCustom metrics allow us to monitor specific aspects of your application beyond the scope of default metrics provided by AWS. The default metrics provided by CloudWatch include instance metrics, traffic mirroring metrics, error metrics, etc. Still, we might need more information about our serverless app.\n\nCustom Metrics come in handy when we need a piece of more specific information like the number of times an API is called, the origin of requests, requests that resulted in a particular error code, metrics with additional information, etc. Custom metrics can provide more context to your metrics by adding custom dimensions that help you filter and group your metrics in CloudWatch.\n\nIt can help in various other aspects like analyzing data over a period of time, creating alarms based on specific thresholds of error requests, number of concurrent users, etc. Custom metrics provide granular control over the aspects of the serverless applications we want to measure. It's up to us to get the insights that help us improve the performance and manage the application.\n\n![Graphic taken from https://blog.awsfundamentals.com](https://cdn.hashnode.com/res/hashnode/image/upload/v1676190070152/488cc3a7-833a-42ee-be1a-872280edb87c.png?auto=compress,format\u0026format=webp\u0026auto=compress,format\u0026format=webp align=\"left\")\n\n## Creating Custom Metrics with SST and CloudWatch\n\nThere are mainly three ways to create custom metrics in CloudWatch.\n\n* API\n    \n* CLI\n    \n* Embedded Metric Format (EMF)\n    \n\nWe are interested in using EMF for the scope of this article.\n\n**Embedded Metric Format (EMF)** is a format that is used to send custom metrics to CloudWatch. CloudWatch can automatically extract custom metrics based on the logs it receives in Embedded Metric Format, allowing us to add alarms or visualise them in detail.\n\nEMF is particularly useful when sending a large number of custom metrics, as it allows you to send them in batches via logs. An embedded metric format looks like this:\n\n```json\n{\n  \"_aws\": {\n    \"Timestamp\": 1574109732004,\n    \"CloudWatchMetrics\": [\n      {\n        \"Namespace\": \"lambda-function-metrics\",\n        \"Dimensions\": [[\"functionVersion\"]],\n        \"Metrics\": [\n          {\n            \"Name\": \"time\",\n            \"Unit\": \"Milliseconds\",\n            \"StorageResolution\": 60\n          }\n        ]\n      }\n    ]\n  },\n  \"functionVersion\": \"$LATEST\",\n  \"time\": 100,\n  \"requestId\": \"989ffbf8-9ace-4817-a57c-e4dd734019ee\"\n}\n```\n\n\u003e [Refer to this documentation for detailed specification on EMF](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html)\n\n## Sending Custom Metrics to CloudWatch\n\nWe use AWS Lambda Powertool to send custom metrics to CloudWatch. Using the `@aws-lambda-powertools/metrics` library, you can use the `Metrics` class provided by the library. Here is an example of how to send a custom metric to CloudWatch using `@aws-lambda-powertools/metrics`:\n\n```javascript\nimport { Metrics, MetricUnits } from \"@aws-lambda-powertools/metrics\";\n\nconst metrics = new Metrics({\n  namespace: \"hashnode\",\n  serviceName: \"graphql\",\n});\n\nexport const handler = async () =\u003e {\n  const singleMetric = metrics.singleMetric();\n  singleMetric.addDimension('origin', 'app');\n  singleMetric.addMetric('count', MetricUnits.Count, 1);\n  metrics.publishStoredMetrics();\n};\n```\n\nIn the example above, we have defined the custom metric with namespace, dimension and unit. Let's understand them a little better:\n\n### 1\\. Namespaces\n\nA namespace is a container for CloudWatch metrics. We can create multiple namespaces for different metrics and distinguish them from each other. For example, AWS Amplify stores the metrics under `AWS/AmplifyHosting` namespace.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679914036400/2153463e-88b2-48ee-8a3e-58ea47cfea3f.png align=\"center\")\n\nIn the above example, we are creating a custom namespace `hashnode` to group all the Hashnode-related metrics. It will look something like this on the console:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679914124331/833ae87c-1c62-4e19-9903-e1f79db701ff.png align=\"center\")\n\n### 2\\. Dimensions\n\nA dimension is a name-value pair that help us describe and categorise the metric. Custom dimensions are additional information that helps us filter and group metrics in CloudWatch.  \nIn the above example, we are adding a dimension `origin` to track the origin of a request. This `origin` dimension can be used to group and filter metrics by the origin of the request. Another example of dimension could be adding `stage` property, which keeps track of the environment of the request. It can be `production`, `dev`, or `staging` which can further be used for filtering or sorting.  \nIt will appear like this in the AWS console:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679980280508/49a0eb8b-cf4d-49e4-87f0-55b0a60d1fea.png align=\"center\")\n\n### 3\\. Units\n\nA unit is simply the data type we use as a measure. A unit can be `Bytes`, `Seconds`, `Microseconds`, `Count` and `Percent`, etc. In our case, we are using `Count` as a unit and setting its value to one.\n\n\u003e [Complete list of supported units can be found here.](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html)\n\nThe resulting log will look something like this in the embedded metric format:\n\n```json\n{\n    \"_aws\": {\n        \"Timestamp\": 1679312949002,\n        \"CloudWatchMetrics\": [\n            {\n                \"Namespace\": \"hashnode\",\n                \"Dimensions\": [\n                    [\n                        \"origin\"\n                    ]\n                ],\n                \"Metrics\": [\n                    {\n                        \"Name\": \"count\",\n                        \"Unit\": \"Count\"\n                    }\n                ]\n            }\n        ]\n    },\n    \"service\": \"graphql\",\n    \"order\": 1\n}\n```\n\n## How to Check Custom Metrics on CloudWatch\n\nOnce we are done with adding custom metrics, we can head over to CloudWatch to check the logs. Go to [the metrics overview](https://us-east-1.console.aws.amazon.com/cloudwatch/home?region=us-east-1#metricsV2:graph=~()) in CloudWatch and find the custom namespace we just added.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679312473318/9fb3fab6-6645-4e94-b960-f8c6a0799621.png align=\"center\")\n\nIf you click on the namespaces, you will see your metrics.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679915022589/35fccffe-b78d-49f4-9509-d6db2f064242.png align=\"center\")\n\n## How We Are Using Custom Metrics at Hashnode\n\nAt Hashnode, we use custom metrics in multiple ways. Let's delve into some of these metrics and explore them thoroughly.\n\n### Tracking Origins of GraphQL Requests\n\nWe use GraphQL APIs at Hashnode, which are utilized by multiple apps, including the community front, the blog front, and the mobile app. Knowing the origin of these requests is essential to allocate resources accordingly. Custom Metrics help us identify the number of requests originating per app.\n\n![Table of API origin, stage and count organised by origin](https://cdn.hashnode.com/res/hashnode/image/upload/v1680765732583/d629e77a-dbf8-4b6c-a412-4400a7546510.png align=\"center\")\n\n### Tracking Application Version and OS for Mobile App\n\nWe use custom metrics to track usage by each application version and OS for Hashnode mobile app. Multiple active mobile app versions can be installed on different devices on different platforms. Custom Metrics have proven invaluable in providing great insight into the mobile app user base.\n\n### Tracking Errors via Error Code\n\nWe use custom metrics to record errors by error codes and rearrange them for easy monitoring. We can get insights about errors thrown per app/lambda categorized by the error code.  \nMetrics associated with error codes allow us to have precise control over what occurs during an incident. For instance, we can associate a 5xx error code with an AWS alarm that can heighten the issue and notify the team during downtime. Refer to the next section for more info on how to use alarms with metrics.\n\n![Table of API and Metrics organised by error code](https://cdn.hashnode.com/res/hashnode/image/upload/v1680765483642/8d9b5cf1-3d5f-4c53-8ccb-7236d053aec7.png align=\"center\")\n\n### Using Data to Set Alarms\n\nWe utilize the historical data of the metric when monitoring errors by error code, and set up alarms to notify us when it surpasses a certain threshold.  \nFor example, we define threshold as `\"Errors \u003e= 1 for 1 datapoints within 1 minute\"` under conditions while creating an alarm. This will ensure that the associated action is triggered when the threshold is reached.  \nThe action can be enabled to send one or more notifications via SNS informing the person on-call.\n\n![Screenshot showing usage of Metrics to set alarms under conditions and enable actions](https://cdn.hashnode.com/res/hashnode/image/upload/v1680765777862/7d348157-8bd3-4df9-8dbf-e9cf10c67959.png align=\"center\")\n\n## Conclusion\n\nAdding custom metrics to your serverless application is essential for monitoring and optimizing its performance. Embedded Metric Format provides an easy way to send logs and extract custom metrics to CloudWatch for monitoring. We also learned how we utilize custom metrics at hashnode.\n\nDo let us know if this article was helpful in the comments.\n\n\u003e [Checkout this article for a more detailed guide on Custom Metrics](https://blog.awsfundamentals.com/optimize-your-application-monitoring-with-cloudwatch-custom-metrics).","html":"\u003cp\u003eMonitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the performance of your resources. One of these services is CloudWatch, which allows you to collect and track metrics, collect and monitor log files, and set alarms for all the AWS Services.\u003c/p\u003e\n\u003cp\u003eThis article will discuss such metrics, specially custom metrics in depth. We will also understand when they can be helpful, and how to add them to using SST. At last, we will look at how we use them at Hashnode.\u003c/p\u003e\n\u003cp\u003eLet's start by understanding the platform \u003ca target=\"_blank\" href=\"https://sst.dev/\"\u003eServerless Stack (SST)\u003c/a\u003e and how it helps in developing serverless applications.\u003c/p\u003e\n\u003ch2 id=\"heading-what-is-sst\"\u003eWhat is SST\u003c/h2\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://sst.dev/\"\u003eSST (Serverless Stack)\u003c/a\u003e simplifies developing and deploying AWS applications. SST's construct makes it easy to add features with very few lines of code.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ecreate-sst\u003c/code\u003e CLI helps us create a new SST app with a basic structure. The \u003ccode\u003ecd\u003c/code\u003e command changes the current directory to the new app and \u003ccode\u003enpm install\u003c/code\u003e will install the required dependencies.\u003cbr /\u003eFinally, you can run \u003ccode\u003esst start\u003c/code\u003e to deploy your sandbox environment to AWS and start your debug stack.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-bash\"\u003enpx create-sst@latest my-sst-app\n\n\u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e my-sst-app\nnpm install\n\nnpx sst dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe CLI will ask you to pick a stage name which can be your name. Once the setup is complete, the app will be deployed to AWS and connected to the local machine. You can then jump to the SST console \u003ca target=\"_blank\" href=\"https://console.sst.dev/\"\u003ehttps://console.sst.dev/\u003c/a\u003e which will stream all the logs.\u003c/p\u003e\n\u003ch2 id=\"heading-what-are-custom-metrics-and-when-to-use-them\"\u003eWhat are Custom Metrics and When To Use Them\u003c/h2\u003e\n\u003cp\u003eCustom metrics allow us to monitor specific aspects of your application beyond the scope of default metrics provided by AWS. The default metrics provided by CloudWatch include instance metrics, traffic mirroring metrics, error metrics, etc. Still, we might need more information about our serverless app.\u003c/p\u003e\n\u003cp\u003eCustom Metrics come in handy when we need a piece of more specific information like the number of times an API is called, the origin of requests, requests that resulted in a particular error code, metrics with additional information, etc. Custom metrics can provide more context to your metrics by adding custom dimensions that help you filter and group your metrics in CloudWatch.\u003c/p\u003e\n\u003cp\u003eIt can help in various other aspects like analyzing data over a period of time, creating alarms based on specific thresholds of error requests, number of concurrent users, etc. Custom metrics provide granular control over the aspects of the serverless applications we want to measure. It's up to us to get the insights that help us improve the performance and manage the application.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676190070152/488cc3a7-833a-42ee-be1a-872280edb87c.png?auto=compress,format\u0026amp;format=webp\u0026amp;auto=compress,format\u0026amp;format=webp\" alt=\"Graphic taken from https://blog.awsfundamentals.com\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-creating-custom-metrics-with-sst-and-cloudwatch\"\u003eCreating Custom Metrics with SST and CloudWatch\u003c/h2\u003e\n\u003cp\u003eThere are mainly three ways to create custom metrics in CloudWatch.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eAPI\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eCLI\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eEmbedded Metric Format (EMF)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe are interested in using EMF for the scope of this article.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEmbedded Metric Format (EMF)\u003c/strong\u003e is a format that is used to send custom metrics to CloudWatch. CloudWatch can automatically extract custom metrics based on the logs it receives in Embedded Metric Format, allowing us to add alarms or visualise them in detail.\u003c/p\u003e\n\u003cp\u003eEMF is particularly useful when sending a large number of custom metrics, as it allows you to send them in batches via logs. An embedded metric format looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-json\"\u003e{\n  \u003cspan class=\"hljs-attr\"\u003e\"_aws\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003e\"Timestamp\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1574109732004\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"CloudWatchMetrics\"\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003e\"Namespace\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"lambda-function-metrics\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003e\"Dimensions\"\u003c/span\u003e: [[\u003cspan class=\"hljs-string\"\u003e\"functionVersion\"\u003c/span\u003e]],\n        \u003cspan class=\"hljs-attr\"\u003e\"Metrics\"\u003c/span\u003e: [\n          {\n            \u003cspan class=\"hljs-attr\"\u003e\"Name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"time\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003e\"Unit\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Milliseconds\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003e\"StorageResolution\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e\n          }\n        ]\n      }\n    ]\n  },\n  \u003cspan class=\"hljs-attr\"\u003e\"functionVersion\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"$LATEST\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003e\"time\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003e\"requestId\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"989ffbf8-9ace-4817-a57c-e4dd734019ee\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html\"\u003eRefer to this documentation for detailed specification on EMF\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"heading-sending-custom-metrics-to-cloudwatch\"\u003eSending Custom Metrics to CloudWatch\u003c/h2\u003e\n\u003cp\u003eWe use AWS Lambda Powertool to send custom metrics to CloudWatch. Using the \u003ccode\u003e@aws-lambda-powertools/metrics\u003c/code\u003e library, you can use the \u003ccode\u003eMetrics\u003c/code\u003e class provided by the library. Here is an example of how to send a custom metric to CloudWatch using \u003ccode\u003e@aws-lambda-powertools/metrics\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { Metrics, MetricUnits } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@aws-lambda-powertools/metrics\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e metrics = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Metrics({\n  \u003cspan class=\"hljs-attr\"\u003enamespace\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"hashnode\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eserviceName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"graphql\"\u003c/span\u003e,\n});\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handler = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e singleMetric = metrics.singleMetric();\n  singleMetric.addDimension(\u003cspan class=\"hljs-string\"\u003e'origin'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'app'\u003c/span\u003e);\n  singleMetric.addMetric(\u003cspan class=\"hljs-string\"\u003e'count'\u003c/span\u003e, MetricUnits.Count, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  metrics.publishStoredMetrics();\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the example above, we have defined the custom metric with namespace, dimension and unit. Let's understand them a little better:\u003c/p\u003e\n\u003ch3 id=\"heading-1-namespaces\"\u003e1. Namespaces\u003c/h3\u003e\n\u003cp\u003eA namespace is a container for CloudWatch metrics. We can create multiple namespaces for different metrics and distinguish them from each other. For example, AWS Amplify stores the metrics under \u003ccode\u003eAWS/AmplifyHosting\u003c/code\u003e namespace.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679914036400/2153463e-88b2-48ee-8a3e-58ea47cfea3f.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIn the above example, we are creating a custom namespace \u003ccode\u003ehashnode\u003c/code\u003e to group all the Hashnode-related metrics. It will look something like this on the console:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679914124331/833ae87c-1c62-4e19-9903-e1f79db701ff.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-2-dimensions\"\u003e2. Dimensions\u003c/h3\u003e\n\u003cp\u003eA dimension is a name-value pair that help us describe and categorise the metric. Custom dimensions are additional information that helps us filter and group metrics in CloudWatch.\u003cbr /\u003eIn the above example, we are adding a dimension \u003ccode\u003eorigin\u003c/code\u003e to track the origin of a request. This \u003ccode\u003eorigin\u003c/code\u003e dimension can be used to group and filter metrics by the origin of the request. Another example of dimension could be adding \u003ccode\u003estage\u003c/code\u003e property, which keeps track of the environment of the request. It can be \u003ccode\u003eproduction\u003c/code\u003e, \u003ccode\u003edev\u003c/code\u003e, or \u003ccode\u003estaging\u003c/code\u003e which can further be used for filtering or sorting.\u003cbr /\u003eIt will appear like this in the AWS console:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679980280508/49a0eb8b-cf4d-49e4-87f0-55b0a60d1fea.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-3-units\"\u003e3. Units\u003c/h3\u003e\n\u003cp\u003eA unit is simply the data type we use as a measure. A unit can be \u003ccode\u003eBytes\u003c/code\u003e, \u003ccode\u003eSeconds\u003c/code\u003e, \u003ccode\u003eMicroseconds\u003c/code\u003e, \u003ccode\u003eCount\u003c/code\u003e and \u003ccode\u003ePercent\u003c/code\u003e, etc. In our case, we are using \u003ccode\u003eCount\u003c/code\u003e as a unit and setting its value to one.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html\"\u003eComplete list of supported units can be found here.\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe resulting log will look something like this in the embedded metric format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-json\"\u003e{\n    \u003cspan class=\"hljs-attr\"\u003e\"_aws\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003e\"Timestamp\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1679312949002\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003e\"CloudWatchMetrics\"\u003c/span\u003e: [\n            {\n                \u003cspan class=\"hljs-attr\"\u003e\"Namespace\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"hashnode\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003e\"Dimensions\"\u003c/span\u003e: [\n                    [\n                        \u003cspan class=\"hljs-string\"\u003e\"origin\"\u003c/span\u003e\n                    ]\n                ],\n                \u003cspan class=\"hljs-attr\"\u003e\"Metrics\"\u003c/span\u003e: [\n                    {\n                        \u003cspan class=\"hljs-attr\"\u003e\"Name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"count\"\u003c/span\u003e,\n                        \u003cspan class=\"hljs-attr\"\u003e\"Unit\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Count\"\u003c/span\u003e\n                    }\n                ]\n            }\n        ]\n    },\n    \u003cspan class=\"hljs-attr\"\u003e\"service\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"graphql\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"order\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"heading-how-to-check-custom-metrics-on-cloudwatch\"\u003eHow to Check Custom Metrics on CloudWatch\u003c/h2\u003e\n\u003cp\u003eOnce we are done with adding custom metrics, we can head over to CloudWatch to check the logs. Go to \u003ca target=\"_blank\" href=\"https://us-east-1.console.aws.amazon.com/cloudwatch/home?region=us-east-1#metricsV2:graph=~()\"\u003ethe metrics overview\u003c/a\u003e in CloudWatch and find the custom namespace we just added.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679312473318/9fb3fab6-6645-4e94-b960-f8c6a0799621.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIf you click on the namespaces, you will see your metrics.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679915022589/35fccffe-b78d-49f4-9509-d6db2f064242.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-how-we-are-using-custom-metrics-at-hashnode\"\u003eHow We Are Using Custom Metrics at Hashnode\u003c/h2\u003e\n\u003cp\u003eAt Hashnode, we use custom metrics in multiple ways. Let's delve into some of these metrics and explore them thoroughly.\u003c/p\u003e\n\u003ch3 id=\"heading-tracking-origins-of-graphql-requests\"\u003eTracking Origins of GraphQL Requests\u003c/h3\u003e\n\u003cp\u003eWe use GraphQL APIs at Hashnode, which are utilized by multiple apps, including the community front, the blog front, and the mobile app. Knowing the origin of these requests is essential to allocate resources accordingly. Custom Metrics help us identify the number of requests originating per app.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680765732583/d629e77a-dbf8-4b6c-a412-4400a7546510.png\" alt=\"Table of API origin, stage and count organised by origin\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-tracking-application-version-and-os-for-mobile-app\"\u003eTracking Application Version and OS for Mobile App\u003c/h3\u003e\n\u003cp\u003eWe use custom metrics to track usage by each application version and OS for Hashnode mobile app. Multiple active mobile app versions can be installed on different devices on different platforms. Custom Metrics have proven invaluable in providing great insight into the mobile app user base.\u003c/p\u003e\n\u003ch3 id=\"heading-tracking-errors-via-error-code\"\u003eTracking Errors via Error Code\u003c/h3\u003e\n\u003cp\u003eWe use custom metrics to record errors by error codes and rearrange them for easy monitoring. We can get insights about errors thrown per app/lambda categorized by the error code.\u003cbr /\u003eMetrics associated with error codes allow us to have precise control over what occurs during an incident. For instance, we can associate a 5xx error code with an AWS alarm that can heighten the issue and notify the team during downtime. Refer to the next section for more info on how to use alarms with metrics.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680765483642/8d9b5cf1-3d5f-4c53-8ccb-7236d053aec7.png\" alt=\"Table of API and Metrics organised by error code\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-using-data-to-set-alarms\"\u003eUsing Data to Set Alarms\u003c/h3\u003e\n\u003cp\u003eWe utilize the historical data of the metric when monitoring errors by error code, and set up alarms to notify us when it surpasses a certain threshold.\u003cbr /\u003eFor example, we define threshold as \u003ccode\u003e\"Errors \u0026gt;= 1 for 1 datapoints within 1 minute\"\u003c/code\u003e under conditions while creating an alarm. This will ensure that the associated action is triggered when the threshold is reached.\u003cbr /\u003eThe action can be enabled to send one or more notifications via SNS informing the person on-call.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680765777862/7d348157-8bd3-4df9-8dbf-e9cf10c67959.png\" alt=\"Screenshot showing usage of Metrics to set alarms under conditions and enable actions\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch2 id=\"heading-conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eAdding custom metrics to your serverless application is essential for monitoring and optimizing its performance. Embedded Metric Format provides an easy way to send logs and extract custom metrics to CloudWatch for monitoring. We also learned how we utilize custom metrics at hashnode.\u003c/p\u003e\n\u003cp\u003eDo let us know if this article was helpful in the comments.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://blog.awsfundamentals.com/optimize-your-application-monitoring-with-cloudwatch-custom-metrics\"\u003eCheckout this article for a more detailed guide on Custom Metrics\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1680672912724/f670a27e-3267-4bed-9f05-500df64cfbc9.png"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"custom-metrics-made-easy-a-comprehensive-guide-to-sst-and-cloudwatch-integration"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>