{"pageProps":{"post":{"slug":"custom-metrics-made-easy-a-comprehensive-guide-to-sst-and-cloudwatch-integration","url":"https://engineering.hashnode.com/custom-metrics-made-easy-a-comprehensive-guide-to-sst-and-cloudwatch-integration","brief":"Monitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the perfo...","title":"Custom Metrics Made Easy: A Comprehensive Guide to SST and CloudWatch Integration","publishedAt":"2023-04-19T06:00:13.019Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1680672874136/f3bfe7ef-8741-4236-b798-012fa2687f0b.png"},"author":{"name":"Shad Mirza","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1663070035311/JaSbIMfve.jpg"},"id":"643f836df032a1495fab9abe","content":{"markdown":"Monitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the performance of your resources. One of these services is CloudWatch, which allows you to collect and track metrics, collect and monitor log files, and set alarms for all the AWS Services.\n\nThis article will discuss such metrics, specially custom metrics in depth. We will also understand when they can be helpful, and how to add them to using SST. At last, we will look at how we use them at Hashnode.\n\nLet's start by understanding the platform [Serverless Stack (SST)](https://sst.dev/) and how it helps in developing serverless applications.\n\n## What is SST\n\n[SST (Serverless Stack)](https://sst.dev/) simplifies developing and deploying AWS applications. SST's construct makes it easy to add features with very few lines of code.\n\nThe `create-sst` CLI helps us create a new SST app with a basic structure. The `cd` command changes the current directory to the new app and `npm install` will install the required dependencies.  \nFinally, you can run `sst start` to deploy your sandbox environment to AWS and start your debug stack.\n\n```bash\nnpx create-sst@latest my-sst-app\n\ncd my-sst-app\nnpm install\n\nnpx sst dev\n```\n\nThe CLI will ask you to pick a stage name which can be your name. Once the setup is complete, the app will be deployed to AWS and connected to the local machine. You can then jump to the SST console [https://console.sst.dev/](https://console.sst.dev/) which will stream all the logs.\n\n## What are Custom Metrics and When To Use Them\n\nCustom metrics allow us to monitor specific aspects of your application beyond the scope of default metrics provided by AWS. The default metrics provided by CloudWatch include instance metrics, traffic mirroring metrics, error metrics, etc. Still, we might need more information about our serverless app.\n\nCustom Metrics come in handy when we need a piece of more specific information like the number of times an API is called, the origin of requests, requests that resulted in a particular error code, metrics with additional information, etc. Custom metrics can provide more context to your metrics by adding custom dimensions that help you filter and group your metrics in CloudWatch.\n\nIt can help in various other aspects like analyzing data over a period of time, creating alarms based on specific thresholds of error requests, number of concurrent users, etc. Custom metrics provide granular control over the aspects of the serverless applications we want to measure. It's up to us to get the insights that help us improve the performance and manage the application.\n\n![Graphic taken from https://blog.awsfundamentals.com](https://cdn.hashnode.com/res/hashnode/image/upload/v1676190070152/488cc3a7-833a-42ee-be1a-872280edb87c.png?auto=compress,format&format=webp&auto=compress,format&format=webp align=\"left\")\n\n## Creating Custom Metrics with SST and CloudWatch\n\nThere are mainly three ways to create custom metrics in CloudWatch.\n\n* API\n    \n* CLI\n    \n* Embedded Metric Format (EMF)\n    \n\nWe are interested in using EMF for the scope of this article.\n\n**Embedded Metric Format (EMF)** is a format that is used to send custom metrics to CloudWatch. CloudWatch can automatically extract custom metrics based on the logs it receives in Embedded Metric Format, allowing us to add alarms or visualise them in detail.\n\nEMF is particularly useful when sending a large number of custom metrics, as it allows you to send them in batches via logs. An embedded metric format looks like this:\n\n```json\n{\n  \"_aws\": {\n    \"Timestamp\": 1574109732004,\n    \"CloudWatchMetrics\": [\n      {\n        \"Namespace\": \"lambda-function-metrics\",\n        \"Dimensions\": [[\"functionVersion\"]],\n        \"Metrics\": [\n          {\n            \"Name\": \"time\",\n            \"Unit\": \"Milliseconds\",\n            \"StorageResolution\": 60\n          }\n        ]\n      }\n    ]\n  },\n  \"functionVersion\": \"$LATEST\",\n  \"time\": 100,\n  \"requestId\": \"989ffbf8-9ace-4817-a57c-e4dd734019ee\"\n}\n```\n\n> [Refer to this documentation for detailed specification on EMF](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html)\n\n## Sending Custom Metrics to CloudWatch\n\nWe use AWS Lambda Powertool to send custom metrics to CloudWatch. Using the `@aws-lambda-powertools/metrics` library, you can use the `Metrics` class provided by the library. Here is an example of how to send a custom metric to CloudWatch using `@aws-lambda-powertools/metrics`:\n\n```javascript\nimport { Metrics, MetricUnits } from \"@aws-lambda-powertools/metrics\";\n\nconst metrics = new Metrics({\n  namespace: \"hashnode\",\n  serviceName: \"graphql\",\n});\n\nexport const handler = async () => {\n  const singleMetric = metrics.singleMetric();\n  singleMetric.addDimension('origin', 'app');\n  singleMetric.addMetric('count', MetricUnits.Count, 1);\n  metrics.publishStoredMetrics();\n};\n```\n\nIn the example above, we have defined the custom metric with namespace, dimension and unit. Let's understand them a little better:\n\n### 1\\. Namespaces\n\nA namespace is a container for CloudWatch metrics. We can create multiple namespaces for different metrics and distinguish them from each other. For example, AWS Amplify stores the metrics under `AWS/AmplifyHosting` namespace.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679914036400/2153463e-88b2-48ee-8a3e-58ea47cfea3f.png align=\"center\")\n\nIn the above example, we are creating a custom namespace `hashnode` to group all the Hashnode-related metrics. It will look something like this on the console:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679914124331/833ae87c-1c62-4e19-9903-e1f79db701ff.png align=\"center\")\n\n### 2\\. Dimensions\n\nA dimension is a name-value pair that help us describe and categorise the metric. Custom dimensions are additional information that helps us filter and group metrics in CloudWatch.  \nIn the above example, we are adding a dimension `origin` to track the origin of a request. This `origin` dimension can be used to group and filter metrics by the origin of the request. Another example of dimension could be adding `stage` property, which keeps track of the environment of the request. It can be `production`, `dev`, or `staging` which can further be used for filtering or sorting.  \nIt will appear like this in the AWS console:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679980280508/49a0eb8b-cf4d-49e4-87f0-55b0a60d1fea.png align=\"center\")\n\n### 3\\. Units\n\nA unit is simply the data type we use as a measure. A unit can be `Bytes`, `Seconds`, `Microseconds`, `Count` and `Percent`, etc. In our case, we are using `Count` as a unit and setting its value to one.\n\n> [Complete list of supported units can be found here.](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html)\n\nThe resulting log will look something like this in the embedded metric format:\n\n```json\n{\n    \"_aws\": {\n        \"Timestamp\": 1679312949002,\n        \"CloudWatchMetrics\": [\n            {\n                \"Namespace\": \"hashnode\",\n                \"Dimensions\": [\n                    [\n                        \"origin\"\n                    ]\n                ],\n                \"Metrics\": [\n                    {\n                        \"Name\": \"count\",\n                        \"Unit\": \"Count\"\n                    }\n                ]\n            }\n        ]\n    },\n    \"service\": \"graphql\",\n    \"order\": 1\n}\n```\n\n## How to Check Custom Metrics on CloudWatch\n\nOnce we are done with adding custom metrics, we can head over to CloudWatch to check the logs. Go to [the metrics overview](https://us-east-1.console.aws.amazon.com/cloudwatch/home?region=us-east-1#metricsV2:graph=~()) in CloudWatch and find the custom namespace we just added.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679312473318/9fb3fab6-6645-4e94-b960-f8c6a0799621.png align=\"center\")\n\nIf you click on the namespaces, you will see your metrics.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1679915022589/35fccffe-b78d-49f4-9509-d6db2f064242.png align=\"center\")\n\n## How We Are Using Custom Metrics at Hashnode\n\nAt Hashnode, we use custom metrics in multiple ways. Let's delve into some of these metrics and explore them thoroughly.\n\n### Tracking Origins of GraphQL Requests\n\nWe use GraphQL APIs at Hashnode, which are utilized by multiple apps, including the community front, the blog front, and the mobile app. Knowing the origin of these requests is essential to allocate resources accordingly. Custom Metrics help us identify the number of requests originating per app.\n\n![Table of API origin, stage and count organised by origin](https://cdn.hashnode.com/res/hashnode/image/upload/v1680765732583/d629e77a-dbf8-4b6c-a412-4400a7546510.png align=\"center\")\n\n### Tracking Application Version and OS for Mobile App\n\nWe use custom metrics to track usage by each application version and OS for Hashnode mobile app. Multiple active mobile app versions can be installed on different devices on different platforms. Custom Metrics have proven invaluable in providing great insight into the mobile app user base.\n\n### Tracking Errors via Error Code\n\nWe use custom metrics to record errors by error codes and rearrange them for easy monitoring. We can get insights about errors thrown per app/lambda categorized by the error code.  \nMetrics associated with error codes allow us to have precise control over what occurs during an incident. For instance, we can associate a 5xx error code with an AWS alarm that can heighten the issue and notify the team during downtime. Refer to the next section for more info on how to use alarms with metrics.\n\n![Table of API and Metrics organised by error code](https://cdn.hashnode.com/res/hashnode/image/upload/v1680765483642/8d9b5cf1-3d5f-4c53-8ccb-7236d053aec7.png align=\"center\")\n\n### Using Data to Set Alarms\n\nWe utilize the historical data of the metric when monitoring errors by error code, and set up alarms to notify us when it surpasses a certain threshold.  \nFor example, we define threshold as `\"Errors >= 1 for 1 datapoints within 1 minute\"` under conditions while creating an alarm. This will ensure that the associated action is triggered when the threshold is reached.  \nThe action can be enabled to send one or more notifications via SNS informing the person on-call.\n\n![Screenshot showing usage of Metrics to set alarms under conditions and enable actions](https://cdn.hashnode.com/res/hashnode/image/upload/v1680765777862/7d348157-8bd3-4df9-8dbf-e9cf10c67959.png align=\"center\")\n\n## Conclusion\n\nAdding custom metrics to your serverless application is essential for monitoring and optimizing its performance. Embedded Metric Format provides an easy way to send logs and extract custom metrics to CloudWatch for monitoring. We also learned how we utilize custom metrics at hashnode.\n\nDo let us know if this article was helpful in the comments.\n\n> [Checkout this article for a more detailed guide on Custom Metrics](https://blog.awsfundamentals.com/optimize-your-application-monitoring-with-cloudwatch-custom-metrics).","html":"<p>Monitoring and managing resources is an important part of making sure your serverless application is working as expected and troubleshooting when issues arise. Amazon Web Services (AWS) provides a wide range of services to monitor and track the performance of your resources. One of these services is CloudWatch, which allows you to collect and track metrics, collect and monitor log files, and set alarms for all the AWS Services.</p>\n<p>This article will discuss such metrics, specially custom metrics in depth. We will also understand when they can be helpful, and how to add them to using SST. At last, we will look at how we use them at Hashnode.</p>\n<p>Let's start by understanding the platform <a target=\"_blank\" href=\"https://sst.dev/\">Serverless Stack (SST)</a> and how it helps in developing serverless applications.</p>\n<h2 id=\"heading-what-is-sst\">What is SST</h2>\n<p><a target=\"_blank\" href=\"https://sst.dev/\">SST (Serverless Stack)</a> simplifies developing and deploying AWS applications. SST's construct makes it easy to add features with very few lines of code.</p>\n<p>The <code>create-sst</code> CLI helps us create a new SST app with a basic structure. The <code>cd</code> command changes the current directory to the new app and <code>npm install</code> will install the required dependencies.<br />Finally, you can run <code>sst start</code> to deploy your sandbox environment to AWS and start your debug stack.</p>\n<pre><code class=\"lang-bash\">npx create-sst@latest my-sst-app\n\n<span class=\"hljs-built_in\">cd</span> my-sst-app\nnpm install\n\nnpx sst dev\n</code></pre>\n<p>The CLI will ask you to pick a stage name which can be your name. Once the setup is complete, the app will be deployed to AWS and connected to the local machine. You can then jump to the SST console <a target=\"_blank\" href=\"https://console.sst.dev/\">https://console.sst.dev/</a> which will stream all the logs.</p>\n<h2 id=\"heading-what-are-custom-metrics-and-when-to-use-them\">What are Custom Metrics and When To Use Them</h2>\n<p>Custom metrics allow us to monitor specific aspects of your application beyond the scope of default metrics provided by AWS. The default metrics provided by CloudWatch include instance metrics, traffic mirroring metrics, error metrics, etc. Still, we might need more information about our serverless app.</p>\n<p>Custom Metrics come in handy when we need a piece of more specific information like the number of times an API is called, the origin of requests, requests that resulted in a particular error code, metrics with additional information, etc. Custom metrics can provide more context to your metrics by adding custom dimensions that help you filter and group your metrics in CloudWatch.</p>\n<p>It can help in various other aspects like analyzing data over a period of time, creating alarms based on specific thresholds of error requests, number of concurrent users, etc. Custom metrics provide granular control over the aspects of the serverless applications we want to measure. It's up to us to get the insights that help us improve the performance and manage the application.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676190070152/488cc3a7-833a-42ee-be1a-872280edb87c.png?auto=compress,format&amp;format=webp&amp;auto=compress,format&amp;format=webp\" alt=\"Graphic taken from https://blog.awsfundamentals.com\" /></p>\n<h2 id=\"heading-creating-custom-metrics-with-sst-and-cloudwatch\">Creating Custom Metrics with SST and CloudWatch</h2>\n<p>There are mainly three ways to create custom metrics in CloudWatch.</p>\n<ul>\n<li><p>API</p>\n</li>\n<li><p>CLI</p>\n</li>\n<li><p>Embedded Metric Format (EMF)</p>\n</li>\n</ul>\n<p>We are interested in using EMF for the scope of this article.</p>\n<p><strong>Embedded Metric Format (EMF)</strong> is a format that is used to send custom metrics to CloudWatch. CloudWatch can automatically extract custom metrics based on the logs it receives in Embedded Metric Format, allowing us to add alarms or visualise them in detail.</p>\n<p>EMF is particularly useful when sending a large number of custom metrics, as it allows you to send them in batches via logs. An embedded metric format looks like this:</p>\n<pre><code class=\"lang-json\">{\n  <span class=\"hljs-attr\">\"_aws\"</span>: {\n    <span class=\"hljs-attr\">\"Timestamp\"</span>: <span class=\"hljs-number\">1574109732004</span>,\n    <span class=\"hljs-attr\">\"CloudWatchMetrics\"</span>: [\n      {\n        <span class=\"hljs-attr\">\"Namespace\"</span>: <span class=\"hljs-string\">\"lambda-function-metrics\"</span>,\n        <span class=\"hljs-attr\">\"Dimensions\"</span>: [[<span class=\"hljs-string\">\"functionVersion\"</span>]],\n        <span class=\"hljs-attr\">\"Metrics\"</span>: [\n          {\n            <span class=\"hljs-attr\">\"Name\"</span>: <span class=\"hljs-string\">\"time\"</span>,\n            <span class=\"hljs-attr\">\"Unit\"</span>: <span class=\"hljs-string\">\"Milliseconds\"</span>,\n            <span class=\"hljs-attr\">\"StorageResolution\"</span>: <span class=\"hljs-number\">60</span>\n          }\n        ]\n      }\n    ]\n  },\n  <span class=\"hljs-attr\">\"functionVersion\"</span>: <span class=\"hljs-string\">\"$LATEST\"</span>,\n  <span class=\"hljs-attr\">\"time\"</span>: <span class=\"hljs-number\">100</span>,\n  <span class=\"hljs-attr\">\"requestId\"</span>: <span class=\"hljs-string\">\"989ffbf8-9ace-4817-a57c-e4dd734019ee\"</span>\n}\n</code></pre>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html\">Refer to this documentation for detailed specification on EMF</a></p>\n</blockquote>\n<h2 id=\"heading-sending-custom-metrics-to-cloudwatch\">Sending Custom Metrics to CloudWatch</h2>\n<p>We use AWS Lambda Powertool to send custom metrics to CloudWatch. Using the <code>@aws-lambda-powertools/metrics</code> library, you can use the <code>Metrics</code> class provided by the library. Here is an example of how to send a custom metric to CloudWatch using <code>@aws-lambda-powertools/metrics</code>:</p>\n<pre><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> { Metrics, MetricUnits } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@aws-lambda-powertools/metrics\"</span>;\n\n<span class=\"hljs-keyword\">const</span> metrics = <span class=\"hljs-keyword\">new</span> Metrics({\n  <span class=\"hljs-attr\">namespace</span>: <span class=\"hljs-string\">\"hashnode\"</span>,\n  <span class=\"hljs-attr\">serviceName</span>: <span class=\"hljs-string\">\"graphql\"</span>,\n});\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> singleMetric = metrics.singleMetric();\n  singleMetric.addDimension(<span class=\"hljs-string\">'origin'</span>, <span class=\"hljs-string\">'app'</span>);\n  singleMetric.addMetric(<span class=\"hljs-string\">'count'</span>, MetricUnits.Count, <span class=\"hljs-number\">1</span>);\n  metrics.publishStoredMetrics();\n};\n</code></pre>\n<p>In the example above, we have defined the custom metric with namespace, dimension and unit. Let's understand them a little better:</p>\n<h3 id=\"heading-1-namespaces\">1. Namespaces</h3>\n<p>A namespace is a container for CloudWatch metrics. We can create multiple namespaces for different metrics and distinguish them from each other. For example, AWS Amplify stores the metrics under <code>AWS/AmplifyHosting</code> namespace.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679914036400/2153463e-88b2-48ee-8a3e-58ea47cfea3f.png\" alt class=\"image--center mx-auto\" /></p>\n<p>In the above example, we are creating a custom namespace <code>hashnode</code> to group all the Hashnode-related metrics. It will look something like this on the console:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679914124331/833ae87c-1c62-4e19-9903-e1f79db701ff.png\" alt class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-2-dimensions\">2. Dimensions</h3>\n<p>A dimension is a name-value pair that help us describe and categorise the metric. Custom dimensions are additional information that helps us filter and group metrics in CloudWatch.<br />In the above example, we are adding a dimension <code>origin</code> to track the origin of a request. This <code>origin</code> dimension can be used to group and filter metrics by the origin of the request. Another example of dimension could be adding <code>stage</code> property, which keeps track of the environment of the request. It can be <code>production</code>, <code>dev</code>, or <code>staging</code> which can further be used for filtering or sorting.<br />It will appear like this in the AWS console:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679980280508/49a0eb8b-cf4d-49e4-87f0-55b0a60d1fea.png\" alt class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-3-units\">3. Units</h3>\n<p>A unit is simply the data type we use as a measure. A unit can be <code>Bytes</code>, <code>Seconds</code>, <code>Microseconds</code>, <code>Count</code> and <code>Percent</code>, etc. In our case, we are using <code>Count</code> as a unit and setting its value to one.</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html\">Complete list of supported units can be found here.</a></p>\n</blockquote>\n<p>The resulting log will look something like this in the embedded metric format:</p>\n<pre><code class=\"lang-json\">{\n    <span class=\"hljs-attr\">\"_aws\"</span>: {\n        <span class=\"hljs-attr\">\"Timestamp\"</span>: <span class=\"hljs-number\">1679312949002</span>,\n        <span class=\"hljs-attr\">\"CloudWatchMetrics\"</span>: [\n            {\n                <span class=\"hljs-attr\">\"Namespace\"</span>: <span class=\"hljs-string\">\"hashnode\"</span>,\n                <span class=\"hljs-attr\">\"Dimensions\"</span>: [\n                    [\n                        <span class=\"hljs-string\">\"origin\"</span>\n                    ]\n                ],\n                <span class=\"hljs-attr\">\"Metrics\"</span>: [\n                    {\n                        <span class=\"hljs-attr\">\"Name\"</span>: <span class=\"hljs-string\">\"count\"</span>,\n                        <span class=\"hljs-attr\">\"Unit\"</span>: <span class=\"hljs-string\">\"Count\"</span>\n                    }\n                ]\n            }\n        ]\n    },\n    <span class=\"hljs-attr\">\"service\"</span>: <span class=\"hljs-string\">\"graphql\"</span>,\n    <span class=\"hljs-attr\">\"order\"</span>: <span class=\"hljs-number\">1</span>\n}\n</code></pre>\n<h2 id=\"heading-how-to-check-custom-metrics-on-cloudwatch\">How to Check Custom Metrics on CloudWatch</h2>\n<p>Once we are done with adding custom metrics, we can head over to CloudWatch to check the logs. Go to <a target=\"_blank\" href=\"https://us-east-1.console.aws.amazon.com/cloudwatch/home?region=us-east-1#metricsV2:graph=~()\">the metrics overview</a> in CloudWatch and find the custom namespace we just added.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679312473318/9fb3fab6-6645-4e94-b960-f8c6a0799621.png\" alt class=\"image--center mx-auto\" /></p>\n<p>If you click on the namespaces, you will see your metrics.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1679915022589/35fccffe-b78d-49f4-9509-d6db2f064242.png\" alt class=\"image--center mx-auto\" /></p>\n<h2 id=\"heading-how-we-are-using-custom-metrics-at-hashnode\">How We Are Using Custom Metrics at Hashnode</h2>\n<p>At Hashnode, we use custom metrics in multiple ways. Let's delve into some of these metrics and explore them thoroughly.</p>\n<h3 id=\"heading-tracking-origins-of-graphql-requests\">Tracking Origins of GraphQL Requests</h3>\n<p>We use GraphQL APIs at Hashnode, which are utilized by multiple apps, including the community front, the blog front, and the mobile app. Knowing the origin of these requests is essential to allocate resources accordingly. Custom Metrics help us identify the number of requests originating per app.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680765732583/d629e77a-dbf8-4b6c-a412-4400a7546510.png\" alt=\"Table of API origin, stage and count organised by origin\" class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-tracking-application-version-and-os-for-mobile-app\">Tracking Application Version and OS for Mobile App</h3>\n<p>We use custom metrics to track usage by each application version and OS for Hashnode mobile app. Multiple active mobile app versions can be installed on different devices on different platforms. Custom Metrics have proven invaluable in providing great insight into the mobile app user base.</p>\n<h3 id=\"heading-tracking-errors-via-error-code\">Tracking Errors via Error Code</h3>\n<p>We use custom metrics to record errors by error codes and rearrange them for easy monitoring. We can get insights about errors thrown per app/lambda categorized by the error code.<br />Metrics associated with error codes allow us to have precise control over what occurs during an incident. For instance, we can associate a 5xx error code with an AWS alarm that can heighten the issue and notify the team during downtime. Refer to the next section for more info on how to use alarms with metrics.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680765483642/8d9b5cf1-3d5f-4c53-8ccb-7236d053aec7.png\" alt=\"Table of API and Metrics organised by error code\" class=\"image--center mx-auto\" /></p>\n<h3 id=\"heading-using-data-to-set-alarms\">Using Data to Set Alarms</h3>\n<p>We utilize the historical data of the metric when monitoring errors by error code, and set up alarms to notify us when it surpasses a certain threshold.<br />For example, we define threshold as <code>\"Errors &gt;= 1 for 1 datapoints within 1 minute\"</code> under conditions while creating an alarm. This will ensure that the associated action is triggered when the threshold is reached.<br />The action can be enabled to send one or more notifications via SNS informing the person on-call.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1680765777862/7d348157-8bd3-4df9-8dbf-e9cf10c67959.png\" alt=\"Screenshot showing usage of Metrics to set alarms under conditions and enable actions\" class=\"image--center mx-auto\" /></p>\n<h2 id=\"heading-conclusion\">Conclusion</h2>\n<p>Adding custom metrics to your serverless application is essential for monitoring and optimizing its performance. Embedded Metric Format provides an easy way to send logs and extract custom metrics to CloudWatch for monitoring. We also learned how we utilize custom metrics at hashnode.</p>\n<p>Do let us know if this article was helpful in the comments.</p>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://blog.awsfundamentals.com/optimize-your-application-monitoring-with-cloudwatch-custom-metrics\">Checkout this article for a more detailed guide on Custom Metrics</a>.</p>\n</blockquote>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1680672912724/f670a27e-3267-4bed-9f05-500df64cfbc9.png"}}},"__N_SSG":true}