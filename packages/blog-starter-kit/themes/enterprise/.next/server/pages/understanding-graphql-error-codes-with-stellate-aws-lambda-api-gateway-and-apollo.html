<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>From Chaos to Clarity: Understanding GraphQL Error Codes with Stellate, AWS Lambda, API Gateway, and Apollo | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/understanding-graphql-error-codes-with-stellate-aws-lambda-api-gateway-and-apollo"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1676972950688/8f04a52c-e667-49e3-92d4-480f990013f6.png"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">From Chaos to Clarity: Understanding GraphQL Error Codes with Stellate, AWS Lambda, API Gateway, and Apollo</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg" class="w-10 h-10 rounded-full" alt="Sandro Volpicella"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Sandro Volpicella</div></div><time dateTime="2023-02-21T06:58:35.770Z">February 20, 2023</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for From Chaos to Clarity: Understanding GraphQL Error Codes with Stellate, AWS Lambda, API Gateway, and Apollo" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1676964092528%2F216d132a-88bd-44b8-a263-9001cb3fdc4b.png&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>GraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like</p>
<ul>
<li><p><strong>200</strong> OK</p>
</li>
<li><p><strong>400</strong> Bad Request</p>
</li>
<li><p><strong>500</strong> Server Error</p>
</li>
</ul>
<p>It often happens that an error happened even if we received a 200 status code.</p>
<p>This blog post is about <strong>the internals of how Hashnode</strong> uses error codes for debugging and understanding the system. This is also for you my fellow Hashnode colleagues 🤗</p>
<p>This post is <strong>not a complete guide</strong> to GraphQL error metrics. Each framework handles it a bit differently and I am not considering myself an expert in each of them.</p>
<h2 id="heading-hashnodes-architecture-stellate-api-gateway-lambda-apollo">Hashnode's Architecture - Stellate, API Gateway, Lambda, Apollo</h2>
<p>To be able to understand how everything interacts I first give you an introduction to our internal Hashnode Architecture.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676451250250/bee89246-4aa7-482b-a731-776d3b96b89f.png" alt="Hashnode's API Infrastructure" class="image--center mx-auto" /></p>
<p>We have a serverless-first mindset. That means everywhere where it makes sense we use serverless services. We don't want to build &amp; manage infrastructure ourselves.</p>
<p>Our API consists of the following services:</p>
<ul>
<li><p><strong>API Gateway</strong> with AWS Lambda as the main API</p>
</li>
<li><p><strong>Apollo Server</strong> as the GraphQL server</p>
</li>
<li><p><a target="_blank" href="https://stellate.co"><strong>Stellate</strong></a> <strong>CDN</strong> as an Edge Cache, Analytics, and Error Software</p>
</li>
</ul>
<p>To cache our responses on the edge we use <a target="_blank" href="http://stellate.co">Stellate</a>. Stellate gives your GraphQL API superpowers! Automatic alerts, analytics, rate limits, and much more.</p>
<p>In between sits an <strong>HTTP API Gateway</strong>. API Gateway integrates with Lambda. It forwards each request and sends it to the Lambda function. Lambda creates the Apollo Handler on each invocation (for new containers) and fulfills the request.</p>
<p>API Gateway and Lambda have both <strong>status codes</strong>. This is where it gets interesting.</p>
<ul>
<li><p><strong>API Gateway Status Code:</strong> This is the status code of the receiver of this API (i.e. Stellate) that receives</p>
</li>
<li><p><strong>Lambda Integration Status Code</strong>: This is the status code API Gateway receives</p>
</li>
</ul>
<p>This is not necessarily the same status code! There is even a third response status code, which is the response code <strong>by Stellate</strong>. Most of the time (almost always) this mirrors the status code of the API Gateway.</p>
<p>By using Stellate we were now also aware of all the different error codes our API consumers received.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1675431258965/7d951c8f-0c81-4819-9cc4-f797e5e6bf70.png" alt="Different Status Codes by Stellate" class="image--center mx-auto" /></p>
<p>That's the reason for this blog post. Let's dive a bit deeper into the errors GraphQL returns to you.</p>
<h2 id="heading-an-overview-of-http-status-codes">An Overview of HTTP Status Codes</h2>
<p>GraphQL is still a typical REST call. You make a POST call to an endpoint and you will receive an HTTP response. This response can have several status codes.</p>
<p>Let's first look over the status codes <strong>briefly</strong>, then focus on some detailed examples and see how Stellate, API Gateway, and Lambda react.</p>
<h3 id="heading-200-ok-or-is-it">200 - OK, or Is It? 🤔</h3>
<p>200 in HTTP means the request was <strong>successful</strong>. This is one of the <strong>confusing codes</strong> in GraphQL.</p>
<p>200 doesn't tell that no error happened. It only means that the request was successful. You still need to check your actual response to see if an error was returned. If an error in your GraphQL API happened it will be visible by having an <code>GRAPHQL_ERROR_CODE</code> in the response body.</p>
<h3 id="heading-400-bad-request">400 - Bad Request</h3>
<p>GraphQL APIs are based on a schema. Our schema for a publication for example is the following:</p>
<pre><code class="lang-graphql">  <span class="hljs-keyword">type</span> Publication <span class="hljs-keyword">implements</span> Node {
    <span class="hljs-symbol">id:</span> ID!
    <span class="hljs-symbol">title:</span> String!
    <span class="hljs-punctuation">...
</span>}
</code></pre>
<p>If you want to access a field that is not implemented in this schema you get an error code 400 - <code>GRAPHQL_VALIDATION_FAILED</code>. 400 in general are validation errors.</p>
<h3 id="heading-500-server-error">500 - Server Error</h3>
<p>500 still means server errors. 500 are still <strong>bad errors</strong>. That means you need to check them. They should not happen. But be aware. Understanding where the error actually appeared can be quite a challenge in the beginning.</p>
<p>500 is a <strong>server error</strong> but what is our server in the architecture? Is it the lambda handler? The Apollo Handler, or anything in between?</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1675433481488/6d7b62a8-c1f5-4a5c-bf75-e2c0e25dd263.png" class="image--center mx-auto" /></p>
<p>The Lambda function has two components:</p>
<ol>
<li><p><strong>Lambda Function</strong>: This is everything that happens <strong>before</strong> the Apollo server starts, e.g. connecting to the DB, fetching secrets, etc.</p>
</li>
<li><p><strong>Apollo Handler</strong>: This is the Apollo server handling requests.</p>
</li>
</ol>
<p>500 <strong>in our architecture</strong> means there is something wrong with the <strong>Lambda function</strong> itself. This doesn't mean something is wrong with the <strong>Apollo Handler</strong> but with the <strong>Lambda Function</strong>. We will see both examples in the example section.</p>
<h2 id="heading-real-scenarios-lets-see-some-examples">Real Scenarios - Let's see some Examples</h2>
<p>Okay, so far the theory. I hope you are still with me. Let's now dig a bit deeper and understand some example scenarios.</p>
<h3 id="heading-successful-request-the-happy-path">Successful Request - The Happy Path 🤗</h3>
<p>A user sends a correct query, for example, this one:</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">query</span> {
    publication(<span class="hljs-symbol">host:</span><span class="hljs-string">"jannikwempe.hashnode.net"</span>) {
        id
        author {
            name
        }
    }
}
</code></pre>
<p>Stellate receives this query, and forwards it to API Gateway, API Gateway creates the event and invokes the Lambda function. Lambda queries the database and sends the response back to API Gateway. This is how everything comes together.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1675433832056/18008a34-cca8-4a08-9d4b-31d12cd72c4d.png" class="image--center mx-auto" /></p>
<p>All states are 200 and everything is fine.</p>
<p>Let's see the example in Postman:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676452245755/1f25e958-80f4-43b8-b51a-5f8245e31802.png" class="image--center mx-auto" /></p>
<p>We receive the response we expect with the status code we expect 👍🏽</p>
<h3 id="heading-error-in-apollo-handler-200-not-ok">Error in Apollo Handler - 200 NOT OK ❌</h3>
<p>Now let's see an example of the mysterious 200 response with an error.</p>
<p>We mock an error by throwing an error from <strong>the Apollo Handler</strong>. Remember, Apollo Handler != Lambda Handler necessarily.</p>
<p>In the Lambda Handler function we create the Apollo Handler like that:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> serverHandler: Handler&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt; = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
...
  <span class="hljs-keyword">return</span> server.createHandler()
...
};
</code></pre>
<p>Everything that happens within the <code>server</code> will be an error <strong>within the handler.</strong> To mock this behavior I've added a <code>throw new Error()</code> somewhere in querying a publication.</p>
<p>The result looks like that:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1675433894562/98f1d799-6b8d-4a85-870a-c4b414d6d85f.png" class="image--center mx-auto" /></p>
<p>If we are now calling the same query we see the following result:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676452532352/e31f41da-641a-40ba-afe7-bdaa4e94cb18.png" class="image--center mx-auto" /></p>
<p>For us, this was new. Even for an <strong>undefined</strong> error and a clear <strong>server error,</strong> the API responds with a 200 response code. The actual error code is in the response and maps on the error code <code>INTERNAL_SERVER_ERROR</code>. You can define this behavior of course.</p>
<p>That is where Stellate is doing a great Job. Without the need of creating any extra logic, Stellate shows us the error in their Error Dashboard:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676452754438/87919f94-7b20-478f-b84b-c23eb6102a78.png" class="image--center mx-auto" /></p>
<p><strong>Learning from this scenario:</strong> You need to have alerts on 200 response codes like <code>INTERNAL_SERVER_ERRORS</code> as well.</p>
<h3 id="heading-server-error-for-real-gt-500">Server Error, for Real -&gt; 500</h3>
<p>The next scenario we look at is a proper server error. This time not the Apollo Handler but the <strong>Lambda Function itself</strong> throws an undefined error.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676453590617/d9d8f0eb-6e51-4eae-b2ed-600717bcf222.png" class="image--center mx-auto" /></p>
<p>The Lambda function is defined as everything that happens <strong>before</strong> the Apollo server is created. In our scenario, this is mainly connecting to our database and caching the connection in the Lambda context. We are doing this by using the amazing <a target="_blank" href="https://middy.js.org/">middy middleware library</a>.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676453319426/a0176449-4ad3-49d4-bf5c-1b6ef4c78dbf.png" class="image--center mx-auto" /></p>
<p>I introduced an error by throwing an undefined error in the middleware that connects to the DB.</p>
<p>Let's see what it looks like in Postman:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676453490262/0f6b1e64-5758-4baf-94da-0f153f712c29.png" class="image--center mx-auto" /></p>
<p>Ah, this time we get a proper 500 error code! Which makes sense of course. No GraphQL server started so there is no way to parse errors in a different way than a normal REST API.</p>
<p>In Stellate it looks like that:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676453669536/f3c5d744-ed8f-4499-9bc8-ba2e22f5471e.png" class="image--center mx-auto" /></p>
<p><strong>Learning from this scenario:</strong> A 500 error means there is something wrong with the underlying "infrastructure" which is your Lambda function. This makes debugging a whole lot easier.</p>
<h3 id="heading-get-request-on-stellate-vs-directly-on-api-gateway">GET Request on Stellate vs. directly on API Gateway</h3>
<p>GraphQL only uses the HTTP Method <strong>POST</strong> for serving data. As a company with our scale, we see many people trying out our internal APIs as well and trying to come through 🕵🏽</p>
<p>Since we'd like to understand how our system behaves in different scenarios we also looked at that one.</p>
<p>If you send a GET request to the Stellate endpoint you will get the following response: 204 - No Content</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676454196106/01a6de93-a381-48fe-b2fc-688b4ed62f99.png" class="image--center mx-auto" /></p>
<p>Interestingly enough, if you send the same request <strong>directly to the API Gateway</strong> you will get a 400 response code.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676454225263/42cdda69-97de-4adc-be3d-b587b3c9501d.png" class="image--center mx-auto" /></p>
<p>The main important thing. Requests like that shouldn't even be able to enter your API.</p>
<p><strong>Learning from this scenario:</strong> Understand that some response codes behave differently on Stellate and on API GW.</p>
<h3 id="heading-validation-errors">Validation Errors</h3>
<p>Now we will look at some validation errors, i.e. 400 error codes. A validation error means that there is something wrong with your query or mutation. While you get 400 as a response code you will also get a GraphQL error code in your response.</p>
<h4 id="heading-access-invalid-field">Access Invalid Field</h4>
<p>Let's start by trying to access a field that doesn't exist.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676454571665/62ddeb0d-3327-40b1-b4b4-dec4b559f510.png" class="image--center mx-auto" /></p>
<p>I try to send the following query to our API:</p>
<pre><code class="lang-graphql">{
   publication(<span class="hljs-symbol">host:</span><span class="hljs-string">"jannikwempe.hashnode.net"</span>) {
       id
       bla
   }
}
</code></pre>
<p>This will result in a response code 400 -&gt; validation failing.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676465439853/f42eea63-4e8f-4197-b92b-ed06be943c8c.png" class="image--center mx-auto" /></p>
<p>We receive the error <code>GRAPHQL_VALIDATION_FAILED</code>. So far so good.</p>
<h4 id="heading-type-check-fails">Type Check Fails</h4>
<p>Something similar happens if you provide the wrong type. Instead of passing the <code>username</code> as a string, I've added the <code>username</code> as a number here.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676465586589/88cc6908-bf70-4d28-9179-04978ba314d3.png" class="image--center mx-auto" /></p>
<p>This will also result in the following response</p>
<pre><code class="lang-json">{
    <span class="hljs-attr">"errors"</span>: [
        {
            <span class="hljs-attr">"message"</span>: <span class="hljs-string">"String cannot represent a non string value: 123"</span>,
            <span class="hljs-attr">"extensions"</span>: {
                <span class="hljs-attr">"code"</span>: <span class="hljs-string">"GRAPHQL_VALIDATION_FAILED"</span>,
            }
        }
    ]
}
</code></pre>
<h4 id="heading-400-but-a-server-error">400 but a server error</h4>
<p>One error that took some while for us to understand was the following one:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676465758320/d59330d4-2a2f-456e-ac2a-d3a7974f7856.png" class="image--center mx-auto" /></p>
<p>In Stellate we received lots of error messages with the response code 400. But the actual GraphQL error code was <code>INTERNAL_SERVER_ERROR</code>.</p>
<p>So what now? Validation error because of the response code 400? Or an internal server error? But why isn't that a 200 error then like in the first examples?</p>
<p>By taking a closer look we saw that none of these exceptions had a query attached. By trying to reproduce it we saw that some people are trying out to send empty queries to our API. This results in a server error with the response code 400.</p>
<p>Cases like these can be adjusted manually in Apollo. But by default, it behaves like that.</p>
<p><strong>Learning from this scenario:</strong> Understand that the GraphQL error code is the most important piece to understand. In this case, <code>INTERNAL_SERVER_ERROR</code> is an expected code and nothing is wrong with your server.</p>
<h3 id="heading-playground-deactivated-403-vs-400">Playground deactivated - 403 vs. 400</h3>
<p>One last error we faced a lot at times is a 403 error from Stellate:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676466176458/4281a5e9-abbe-42da-98a7-4cae155225c7.png" class="image--center mx-auto" /></p>
<p>This error indicates that somebody is doing a <code>GET</code> request on our API. But when I tried to reproduce that I got a <code>204 - No Content</code> like seen above. It took some time to understand that this error message results if somebody tries to access a disabled GraphQL playground. When I try to access the <strong>Stellate Playground</strong> I get a 403 Forbidden error.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676466433979/2249a5b1-5b88-43dd-8888-ffb16e4a4ffb.png" class="image--center mx-auto" /></p>
<p><strong>But</strong> if I try to access the GraphQL Playground directly in Apollo and it is deactivated I get a 400 error.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1676466476500/83e0ad24-9a4a-4dbe-b440-9f337fa79c8c.png" class="image--center mx-auto" /></p>
<p>This is nothing major. It is still important for us to understand the differences. With that, we are able to act on real 403 issues.</p>
<h2 id="heading-summary">Summary</h2>
<p>In summary, it is really important to understand the ins and outs of your API. Stellate makes our lives much easier by automatically parsing GraphQL error codes and showing the resulting response codes. In the end, everything is dependent on the implementation of your GraphQL server.</p>
<p>To be able to act quickly on incidents or abnormal behavior it is critical to understand what each error code and error message actually means. Many errors are expected. Especially in cases like:</p>
<ul>
<li><p>Unauthenticated access</p>
</li>
<li><p>Validation Errors</p>
</li>
</ul>
<p>But there are also many cases where they are not expected.</p>
<p>We have created several alarms and in special cases also an automated generation of Incidents (👋🏽 Better Uptime) so that we are able to act quickly on all upcoming incidents.</p>
<p>Thanks for sticking with me, see you soon 👋🏽</p>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"understanding-graphql-error-codes-with-stellate-aws-lambda-api-gateway-and-apollo","url":"https://engineering.hashnode.com/understanding-graphql-error-codes-with-stellate-aws-lambda-api-gateway-and-apollo","brief":"GraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like\n\n200 OK\n\n400 Bad Request\n\n500 Server Error\n\n\nIt often happens that an error happened even if we received a 200 status code.\nThis blog pos...","title":"From Chaos to Clarity: Understanding GraphQL Error Codes with Stellate, AWS Lambda, API Gateway, and Apollo","publishedAt":"2023-02-21T06:58:35.770Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1676964092528/216d132a-88bd-44b8-a263-9001cb3fdc4b.png"},"author":{"name":"Sandro Volpicella","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg"},"id":"63f46b9b4cd7a287eab5c0c7","content":{"markdown":"GraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like\n\n* **200** OK\n    \n* **400** Bad Request\n    \n* **500** Server Error\n    \n\nIt often happens that an error happened even if we received a 200 status code.\n\nThis blog post is about **the internals of how Hashnode** uses error codes for debugging and understanding the system. This is also for you my fellow Hashnode colleagues 🤗\n\nThis post is **not a complete guide** to GraphQL error metrics. Each framework handles it a bit differently and I am not considering myself an expert in each of them.\n\n## Hashnode's Architecture - Stellate, API Gateway, Lambda, Apollo\n\nTo be able to understand how everything interacts I first give you an introduction to our internal Hashnode Architecture.\n\n![Hashnode's API Infrastructure](https://cdn.hashnode.com/res/hashnode/image/upload/v1676451250250/bee89246-4aa7-482b-a731-776d3b96b89f.png align=\"center\")\n\nWe have a serverless-first mindset. That means everywhere where it makes sense we use serverless services. We don't want to build \u0026 manage infrastructure ourselves.\n\nOur API consists of the following services:\n\n* **API Gateway** with AWS Lambda as the main API\n    \n* **Apollo Server** as the GraphQL server\n    \n* [**Stellate**](https://stellate.co) **CDN** as an Edge Cache, Analytics, and Error Software\n    \n\nTo cache our responses on the edge we use [Stellate](http://stellate.co). Stellate gives your GraphQL API superpowers! Automatic alerts, analytics, rate limits, and much more.\n\nIn between sits an **HTTP API Gateway**. API Gateway integrates with Lambda. It forwards each request and sends it to the Lambda function. Lambda creates the Apollo Handler on each invocation (for new containers) and fulfills the request.\n\nAPI Gateway and Lambda have both **status codes**. This is where it gets interesting.\n\n* **API Gateway Status Code:** This is the status code of the receiver of this API (i.e. Stellate) that receives\n    \n* **Lambda Integration Status Code**: This is the status code API Gateway receives\n    \n\nThis is not necessarily the same status code! There is even a third response status code, which is the response code **by Stellate**. Most of the time (almost always) this mirrors the status code of the API Gateway.\n\nBy using Stellate we were now also aware of all the different error codes our API consumers received.\n\n![Different Status Codes by Stellate](https://cdn.hashnode.com/res/hashnode/image/upload/v1675431258965/7d951c8f-0c81-4819-9cc4-f797e5e6bf70.png align=\"center\")\n\nThat's the reason for this blog post. Let's dive a bit deeper into the errors GraphQL returns to you.\n\n## An Overview of HTTP Status Codes\n\nGraphQL is still a typical REST call. You make a POST call to an endpoint and you will receive an HTTP response. This response can have several status codes.\n\nLet's first look over the status codes **briefly**, then focus on some detailed examples and see how Stellate, API Gateway, and Lambda react.\n\n### 200 - OK, or Is It? 🤔\n\n200 in HTTP means the request was **successful**. This is one of the **confusing codes** in GraphQL.\n\n200 doesn't tell that no error happened. It only means that the request was successful. You still need to check your actual response to see if an error was returned. If an error in your GraphQL API happened it will be visible by having an `GRAPHQL_ERROR_CODE` in the response body.\n\n### 400 - Bad Request\n\nGraphQL APIs are based on a schema. Our schema for a publication for example is the following:\n\n```graphql\n  type Publication implements Node {\n    id: ID!\n    title: String!\n    ...\n}\n```\n\nIf you want to access a field that is not implemented in this schema you get an error code 400 - `GRAPHQL_VALIDATION_FAILED`. 400 in general are validation errors.\n\n### 500 - Server Error\n\n500 still means server errors. 500 are still **bad errors**. That means you need to check them. They should not happen. But be aware. Understanding where the error actually appeared can be quite a challenge in the beginning.\n\n500 is a **server error** but what is our server in the architecture? Is it the lambda handler? The Apollo Handler, or anything in between?\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1675433481488/6d7b62a8-c1f5-4a5c-bf75-e2c0e25dd263.png align=\"center\")\n\nThe Lambda function has two components:\n\n1. **Lambda Function**: This is everything that happens **before** the Apollo server starts, e.g. connecting to the DB, fetching secrets, etc.\n    \n2. **Apollo Handler**: This is the Apollo server handling requests.\n    \n\n500 **in our architecture** means there is something wrong with the **Lambda function** itself. This doesn't mean something is wrong with the **Apollo Handler** but with the **Lambda Function**. We will see both examples in the example section.\n\n## Real Scenarios - Let's see some Examples\n\nOkay, so far the theory. I hope you are still with me. Let's now dig a bit deeper and understand some example scenarios.\n\n### Successful Request - The Happy Path 🤗\n\nA user sends a correct query, for example, this one:\n\n```graphql\nquery {\n    publication(host:\"jannikwempe.hashnode.net\") {\n        id\n        author {\n            name\n        }\n    }\n}\n```\n\nStellate receives this query, and forwards it to API Gateway, API Gateway creates the event and invokes the Lambda function. Lambda queries the database and sends the response back to API Gateway. This is how everything comes together.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1675433832056/18008a34-cca8-4a08-9d4b-31d12cd72c4d.png align=\"center\")\n\nAll states are 200 and everything is fine.\n\nLet's see the example in Postman:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676452245755/1f25e958-80f4-43b8-b51a-5f8245e31802.png align=\"center\")\n\nWe receive the response we expect with the status code we expect 👍🏽\n\n### Error in Apollo Handler - 200 NOT OK ❌\n\nNow let's see an example of the mysterious 200 response with an error.\n\nWe mock an error by throwing an error from **the Apollo Handler**. Remember, Apollo Handler != Lambda Handler necessarily.\n\nIn the Lambda Handler function we create the Apollo Handler like that:\n\n```typescript\nconst serverHandler: Handler\u003cany, any\u003e = (...args) =\u003e {\n...\n  return server.createHandler()\n...\n};\n```\n\nEverything that happens within the `server` will be an error **within the handler.** To mock this behavior I've added a `throw new Error()` somewhere in querying a publication.\n\nThe result looks like that:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1675433894562/98f1d799-6b8d-4a85-870a-c4b414d6d85f.png align=\"center\")\n\nIf we are now calling the same query we see the following result:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676452532352/e31f41da-641a-40ba-afe7-bdaa4e94cb18.png align=\"center\")\n\nFor us, this was new. Even for an **undefined** error and a clear **server error,** the API responds with a 200 response code. The actual error code is in the response and maps on the error code `INTERNAL_SERVER_ERROR`. You can define this behavior of course.\n\nThat is where Stellate is doing a great Job. Without the need of creating any extra logic, Stellate shows us the error in their Error Dashboard:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676452754438/87919f94-7b20-478f-b84b-c23eb6102a78.png align=\"center\")\n\n**Learning from this scenario:** You need to have alerts on 200 response codes like `INTERNAL_SERVER_ERRORS` as well.\n\n### Server Error, for Real -\u0026gt; 500\n\nThe next scenario we look at is a proper server error. This time not the Apollo Handler but the **Lambda Function itself** throws an undefined error.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453590617/d9d8f0eb-6e51-4eae-b2ed-600717bcf222.png align=\"center\")\n\nThe Lambda function is defined as everything that happens **before** the Apollo server is created. In our scenario, this is mainly connecting to our database and caching the connection in the Lambda context. We are doing this by using the amazing [middy middleware library](https://middy.js.org/).\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453319426/a0176449-4ad3-49d4-bf5c-1b6ef4c78dbf.png align=\"center\")\n\nI introduced an error by throwing an undefined error in the middleware that connects to the DB.\n\nLet's see what it looks like in Postman:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453490262/0f6b1e64-5758-4baf-94da-0f153f712c29.png align=\"center\")\n\nAh, this time we get a proper 500 error code! Which makes sense of course. No GraphQL server started so there is no way to parse errors in a different way than a normal REST API.\n\nIn Stellate it looks like that:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676453669536/f3c5d744-ed8f-4499-9bc8-ba2e22f5471e.png align=\"center\")\n\n**Learning from this scenario:** A 500 error means there is something wrong with the underlying \"infrastructure\" which is your Lambda function. This makes debugging a whole lot easier.\n\n### GET Request on Stellate vs. directly on API Gateway\n\nGraphQL only uses the HTTP Method **POST** for serving data. As a company with our scale, we see many people trying out our internal APIs as well and trying to come through 🕵🏽\n\nSince we'd like to understand how our system behaves in different scenarios we also looked at that one.\n\nIf you send a GET request to the Stellate endpoint you will get the following response: 204 - No Content\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676454196106/01a6de93-a381-48fe-b2fc-688b4ed62f99.png align=\"center\")\n\nInterestingly enough, if you send the same request **directly to the API Gateway** you will get a 400 response code.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676454225263/42cdda69-97de-4adc-be3d-b587b3c9501d.png align=\"center\")\n\nThe main important thing. Requests like that shouldn't even be able to enter your API.\n\n**Learning from this scenario:** Understand that some response codes behave differently on Stellate and on API GW.\n\n### Validation Errors\n\nNow we will look at some validation errors, i.e. 400 error codes. A validation error means that there is something wrong with your query or mutation. While you get 400 as a response code you will also get a GraphQL error code in your response.\n\n#### Access Invalid Field\n\nLet's start by trying to access a field that doesn't exist.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676454571665/62ddeb0d-3327-40b1-b4b4-dec4b559f510.png align=\"center\")\n\nI try to send the following query to our API:\n\n```graphql\n{\n   publication(host:\"jannikwempe.hashnode.net\") {\n       id\n       bla\n   }\n}\n```\n\nThis will result in a response code 400 -\u0026gt; validation failing.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676465439853/f42eea63-4e8f-4197-b92b-ed06be943c8c.png align=\"center\")\n\nWe receive the error `GRAPHQL_VALIDATION_FAILED`. So far so good.\n\n#### Type Check Fails\n\nSomething similar happens if you provide the wrong type. Instead of passing the `username` as a string, I've added the `username` as a number here.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676465586589/88cc6908-bf70-4d28-9179-04978ba314d3.png align=\"center\")\n\nThis will also result in the following response\n\n```json\n{\n    \"errors\": [\n        {\n            \"message\": \"String cannot represent a non string value: 123\",\n            \"extensions\": {\n                \"code\": \"GRAPHQL_VALIDATION_FAILED\",\n            }\n        }\n    ]\n}\n```\n\n#### 400 but a server error\n\nOne error that took some while for us to understand was the following one:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676465758320/d59330d4-2a2f-456e-ac2a-d3a7974f7856.png align=\"center\")\n\nIn Stellate we received lots of error messages with the response code 400. But the actual GraphQL error code was `INTERNAL_SERVER_ERROR`.\n\nSo what now? Validation error because of the response code 400? Or an internal server error? But why isn't that a 200 error then like in the first examples?\n\nBy taking a closer look we saw that none of these exceptions had a query attached. By trying to reproduce it we saw that some people are trying out to send empty queries to our API. This results in a server error with the response code 400.\n\nCases like these can be adjusted manually in Apollo. But by default, it behaves like that.\n\n**Learning from this scenario:** Understand that the GraphQL error code is the most important piece to understand. In this case, `INTERNAL_SERVER_ERROR` is an expected code and nothing is wrong with your server.\n\n### Playground deactivated - 403 vs. 400\n\nOne last error we faced a lot at times is a 403 error from Stellate:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676466176458/4281a5e9-abbe-42da-98a7-4cae155225c7.png align=\"center\")\n\nThis error indicates that somebody is doing a `GET` request on our API. But when I tried to reproduce that I got a `204 - No Content` like seen above. It took some time to understand that this error message results if somebody tries to access a disabled GraphQL playground. When I try to access the **Stellate Playground** I get a 403 Forbidden error.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676466433979/2249a5b1-5b88-43dd-8888-ffb16e4a4ffb.png align=\"center\")\n\n**But** if I try to access the GraphQL Playground directly in Apollo and it is deactivated I get a 400 error.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1676466476500/83e0ad24-9a4a-4dbe-b440-9f337fa79c8c.png align=\"center\")\n\nThis is nothing major. It is still important for us to understand the differences. With that, we are able to act on real 403 issues.\n\n## Summary\n\nIn summary, it is really important to understand the ins and outs of your API. Stellate makes our lives much easier by automatically parsing GraphQL error codes and showing the resulting response codes. In the end, everything is dependent on the implementation of your GraphQL server.\n\nTo be able to act quickly on incidents or abnormal behavior it is critical to understand what each error code and error message actually means. Many errors are expected. Especially in cases like:\n\n* Unauthenticated access\n    \n* Validation Errors\n    \n\nBut there are also many cases where they are not expected.\n\nWe have created several alarms and in special cases also an automated generation of Incidents (👋🏽 Better Uptime) so that we are able to act quickly on all upcoming incidents.\n\nThanks for sticking with me, see you soon 👋🏽","html":"\u003cp\u003eGraphQL handles error codes a bit differently compared to REST Apis. While we still get HTTP response codes like\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e200\u003c/strong\u003e OK\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e400\u003c/strong\u003e Bad Request\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e500\u003c/strong\u003e Server Error\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt often happens that an error happened even if we received a 200 status code.\u003c/p\u003e\n\u003cp\u003eThis blog post is about \u003cstrong\u003ethe internals of how Hashnode\u003c/strong\u003e uses error codes for debugging and understanding the system. This is also for you my fellow Hashnode colleagues 🤗\u003c/p\u003e\n\u003cp\u003eThis post is \u003cstrong\u003enot a complete guide\u003c/strong\u003e to GraphQL error metrics. Each framework handles it a bit differently and I am not considering myself an expert in each of them.\u003c/p\u003e\n\u003ch2 id=\"heading-hashnodes-architecture-stellate-api-gateway-lambda-apollo\"\u003eHashnode's Architecture - Stellate, API Gateway, Lambda, Apollo\u003c/h2\u003e\n\u003cp\u003eTo be able to understand how everything interacts I first give you an introduction to our internal Hashnode Architecture.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676451250250/bee89246-4aa7-482b-a731-776d3b96b89f.png\" alt=\"Hashnode's API Infrastructure\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eWe have a serverless-first mindset. That means everywhere where it makes sense we use serverless services. We don't want to build \u0026amp; manage infrastructure ourselves.\u003c/p\u003e\n\u003cp\u003eOur API consists of the following services:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAPI Gateway\u003c/strong\u003e with AWS Lambda as the main API\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eApollo Server\u003c/strong\u003e as the GraphQL server\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://stellate.co\"\u003e\u003cstrong\u003eStellate\u003c/strong\u003e\u003c/a\u003e \u003cstrong\u003eCDN\u003c/strong\u003e as an Edge Cache, Analytics, and Error Software\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo cache our responses on the edge we use \u003ca target=\"_blank\" href=\"http://stellate.co\"\u003eStellate\u003c/a\u003e. Stellate gives your GraphQL API superpowers! Automatic alerts, analytics, rate limits, and much more.\u003c/p\u003e\n\u003cp\u003eIn between sits an \u003cstrong\u003eHTTP API Gateway\u003c/strong\u003e. API Gateway integrates with Lambda. It forwards each request and sends it to the Lambda function. Lambda creates the Apollo Handler on each invocation (for new containers) and fulfills the request.\u003c/p\u003e\n\u003cp\u003eAPI Gateway and Lambda have both \u003cstrong\u003estatus codes\u003c/strong\u003e. This is where it gets interesting.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAPI Gateway Status Code:\u003c/strong\u003e This is the status code of the receiver of this API (i.e. Stellate) that receives\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eLambda Integration Status Code\u003c/strong\u003e: This is the status code API Gateway receives\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is not necessarily the same status code! There is even a third response status code, which is the response code \u003cstrong\u003eby Stellate\u003c/strong\u003e. Most of the time (almost always) this mirrors the status code of the API Gateway.\u003c/p\u003e\n\u003cp\u003eBy using Stellate we were now also aware of all the different error codes our API consumers received.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675431258965/7d951c8f-0c81-4819-9cc4-f797e5e6bf70.png\" alt=\"Different Status Codes by Stellate\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThat's the reason for this blog post. Let's dive a bit deeper into the errors GraphQL returns to you.\u003c/p\u003e\n\u003ch2 id=\"heading-an-overview-of-http-status-codes\"\u003eAn Overview of HTTP Status Codes\u003c/h2\u003e\n\u003cp\u003eGraphQL is still a typical REST call. You make a POST call to an endpoint and you will receive an HTTP response. This response can have several status codes.\u003c/p\u003e\n\u003cp\u003eLet's first look over the status codes \u003cstrong\u003ebriefly\u003c/strong\u003e, then focus on some detailed examples and see how Stellate, API Gateway, and Lambda react.\u003c/p\u003e\n\u003ch3 id=\"heading-200-ok-or-is-it\"\u003e200 - OK, or Is It? 🤔\u003c/h3\u003e\n\u003cp\u003e200 in HTTP means the request was \u003cstrong\u003esuccessful\u003c/strong\u003e. This is one of the \u003cstrong\u003econfusing codes\u003c/strong\u003e in GraphQL.\u003c/p\u003e\n\u003cp\u003e200 doesn't tell that no error happened. It only means that the request was successful. You still need to check your actual response to see if an error was returned. If an error in your GraphQL API happened it will be visible by having an \u003ccode\u003eGRAPHQL_ERROR_CODE\u003c/code\u003e in the response body.\u003c/p\u003e\n\u003ch3 id=\"heading-400-bad-request\"\u003e400 - Bad Request\u003c/h3\u003e\n\u003cp\u003eGraphQL APIs are based on a schema. Our schema for a publication for example is the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e  \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Publication \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e Node {\n    \u003cspan class=\"hljs-symbol\"\u003eid:\u003c/span\u003e ID!\n    \u003cspan class=\"hljs-symbol\"\u003etitle:\u003c/span\u003e String!\n    \u003cspan class=\"hljs-punctuation\"\u003e...\n\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you want to access a field that is not implemented in this schema you get an error code 400 - \u003ccode\u003eGRAPHQL_VALIDATION_FAILED\u003c/code\u003e. 400 in general are validation errors.\u003c/p\u003e\n\u003ch3 id=\"heading-500-server-error\"\u003e500 - Server Error\u003c/h3\u003e\n\u003cp\u003e500 still means server errors. 500 are still \u003cstrong\u003ebad errors\u003c/strong\u003e. That means you need to check them. They should not happen. But be aware. Understanding where the error actually appeared can be quite a challenge in the beginning.\u003c/p\u003e\n\u003cp\u003e500 is a \u003cstrong\u003eserver error\u003c/strong\u003e but what is our server in the architecture? Is it the lambda handler? The Apollo Handler, or anything in between?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675433481488/6d7b62a8-c1f5-4a5c-bf75-e2c0e25dd263.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThe Lambda function has two components:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eLambda Function\u003c/strong\u003e: This is everything that happens \u003cstrong\u003ebefore\u003c/strong\u003e the Apollo server starts, e.g. connecting to the DB, fetching secrets, etc.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eApollo Handler\u003c/strong\u003e: This is the Apollo server handling requests.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e500 \u003cstrong\u003ein our architecture\u003c/strong\u003e means there is something wrong with the \u003cstrong\u003eLambda function\u003c/strong\u003e itself. This doesn't mean something is wrong with the \u003cstrong\u003eApollo Handler\u003c/strong\u003e but with the \u003cstrong\u003eLambda Function\u003c/strong\u003e. We will see both examples in the example section.\u003c/p\u003e\n\u003ch2 id=\"heading-real-scenarios-lets-see-some-examples\"\u003eReal Scenarios - Let's see some Examples\u003c/h2\u003e\n\u003cp\u003eOkay, so far the theory. I hope you are still with me. Let's now dig a bit deeper and understand some example scenarios.\u003c/p\u003e\n\u003ch3 id=\"heading-successful-request-the-happy-path\"\u003eSuccessful Request - The Happy Path 🤗\u003c/h3\u003e\n\u003cp\u003eA user sends a correct query, for example, this one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003equery\u003c/span\u003e {\n    publication(\u003cspan class=\"hljs-symbol\"\u003ehost:\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"jannikwempe.hashnode.net\"\u003c/span\u003e) {\n        id\n        author {\n            name\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStellate receives this query, and forwards it to API Gateway, API Gateway creates the event and invokes the Lambda function. Lambda queries the database and sends the response back to API Gateway. This is how everything comes together.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675433832056/18008a34-cca8-4a08-9d4b-31d12cd72c4d.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eAll states are 200 and everything is fine.\u003c/p\u003e\n\u003cp\u003eLet's see the example in Postman:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676452245755/1f25e958-80f4-43b8-b51a-5f8245e31802.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eWe receive the response we expect with the status code we expect 👍🏽\u003c/p\u003e\n\u003ch3 id=\"heading-error-in-apollo-handler-200-not-ok\"\u003eError in Apollo Handler - 200 NOT OK ❌\u003c/h3\u003e\n\u003cp\u003eNow let's see an example of the mysterious 200 response with an error.\u003c/p\u003e\n\u003cp\u003eWe mock an error by throwing an error from \u003cstrong\u003ethe Apollo Handler\u003c/strong\u003e. Remember, Apollo Handler != Lambda Handler necessarily.\u003c/p\u003e\n\u003cp\u003eIn the Lambda Handler function we create the Apollo Handler like that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e serverHandler: Handler\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt; = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n...\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e server.createHandler()\n...\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEverything that happens within the \u003ccode\u003eserver\u003c/code\u003e will be an error \u003cstrong\u003ewithin the handler.\u003c/strong\u003e To mock this behavior I've added a \u003ccode\u003ethrow new Error()\u003c/code\u003e somewhere in querying a publication.\u003c/p\u003e\n\u003cp\u003eThe result looks like that:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1675433894562/98f1d799-6b8d-4a85-870a-c4b414d6d85f.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIf we are now calling the same query we see the following result:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676452532352/e31f41da-641a-40ba-afe7-bdaa4e94cb18.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eFor us, this was new. Even for an \u003cstrong\u003eundefined\u003c/strong\u003e error and a clear \u003cstrong\u003eserver error,\u003c/strong\u003e the API responds with a 200 response code. The actual error code is in the response and maps on the error code \u003ccode\u003eINTERNAL_SERVER_ERROR\u003c/code\u003e. You can define this behavior of course.\u003c/p\u003e\n\u003cp\u003eThat is where Stellate is doing a great Job. Without the need of creating any extra logic, Stellate shows us the error in their Error Dashboard:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676452754438/87919f94-7b20-478f-b84b-c23eb6102a78.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLearning from this scenario:\u003c/strong\u003e You need to have alerts on 200 response codes like \u003ccode\u003eINTERNAL_SERVER_ERRORS\u003c/code\u003e as well.\u003c/p\u003e\n\u003ch3 id=\"heading-server-error-for-real-andgt-500\"\u003eServer Error, for Real -\u0026gt; 500\u003c/h3\u003e\n\u003cp\u003eThe next scenario we look at is a proper server error. This time not the Apollo Handler but the \u003cstrong\u003eLambda Function itself\u003c/strong\u003e throws an undefined error.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453590617/d9d8f0eb-6e51-4eae-b2ed-600717bcf222.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThe Lambda function is defined as everything that happens \u003cstrong\u003ebefore\u003c/strong\u003e the Apollo server is created. In our scenario, this is mainly connecting to our database and caching the connection in the Lambda context. We are doing this by using the amazing \u003ca target=\"_blank\" href=\"https://middy.js.org/\"\u003emiddy middleware library\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453319426/a0176449-4ad3-49d4-bf5c-1b6ef4c78dbf.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eI introduced an error by throwing an undefined error in the middleware that connects to the DB.\u003c/p\u003e\n\u003cp\u003eLet's see what it looks like in Postman:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453490262/0f6b1e64-5758-4baf-94da-0f153f712c29.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eAh, this time we get a proper 500 error code! Which makes sense of course. No GraphQL server started so there is no way to parse errors in a different way than a normal REST API.\u003c/p\u003e\n\u003cp\u003eIn Stellate it looks like that:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676453669536/f3c5d744-ed8f-4499-9bc8-ba2e22f5471e.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLearning from this scenario:\u003c/strong\u003e A 500 error means there is something wrong with the underlying \"infrastructure\" which is your Lambda function. This makes debugging a whole lot easier.\u003c/p\u003e\n\u003ch3 id=\"heading-get-request-on-stellate-vs-directly-on-api-gateway\"\u003eGET Request on Stellate vs. directly on API Gateway\u003c/h3\u003e\n\u003cp\u003eGraphQL only uses the HTTP Method \u003cstrong\u003ePOST\u003c/strong\u003e for serving data. As a company with our scale, we see many people trying out our internal APIs as well and trying to come through 🕵🏽\u003c/p\u003e\n\u003cp\u003eSince we'd like to understand how our system behaves in different scenarios we also looked at that one.\u003c/p\u003e\n\u003cp\u003eIf you send a GET request to the Stellate endpoint you will get the following response: 204 - No Content\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676454196106/01a6de93-a381-48fe-b2fc-688b4ed62f99.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eInterestingly enough, if you send the same request \u003cstrong\u003edirectly to the API Gateway\u003c/strong\u003e you will get a 400 response code.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676454225263/42cdda69-97de-4adc-be3d-b587b3c9501d.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThe main important thing. Requests like that shouldn't even be able to enter your API.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLearning from this scenario:\u003c/strong\u003e Understand that some response codes behave differently on Stellate and on API GW.\u003c/p\u003e\n\u003ch3 id=\"heading-validation-errors\"\u003eValidation Errors\u003c/h3\u003e\n\u003cp\u003eNow we will look at some validation errors, i.e. 400 error codes. A validation error means that there is something wrong with your query or mutation. While you get 400 as a response code you will also get a GraphQL error code in your response.\u003c/p\u003e\n\u003ch4 id=\"heading-access-invalid-field\"\u003eAccess Invalid Field\u003c/h4\u003e\n\u003cp\u003eLet's start by trying to access a field that doesn't exist.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676454571665/62ddeb0d-3327-40b1-b4b4-dec4b559f510.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eI try to send the following query to our API:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e{\n   publication(\u003cspan class=\"hljs-symbol\"\u003ehost:\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"jannikwempe.hashnode.net\"\u003c/span\u003e) {\n       id\n       bla\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will result in a response code 400 -\u0026gt; validation failing.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676465439853/f42eea63-4e8f-4197-b92b-ed06be943c8c.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eWe receive the error \u003ccode\u003eGRAPHQL_VALIDATION_FAILED\u003c/code\u003e. So far so good.\u003c/p\u003e\n\u003ch4 id=\"heading-type-check-fails\"\u003eType Check Fails\u003c/h4\u003e\n\u003cp\u003eSomething similar happens if you provide the wrong type. Instead of passing the \u003ccode\u003eusername\u003c/code\u003e as a string, I've added the \u003ccode\u003eusername\u003c/code\u003e as a number here.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676465586589/88cc6908-bf70-4d28-9179-04978ba314d3.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThis will also result in the following response\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-json\"\u003e{\n    \u003cspan class=\"hljs-attr\"\u003e\"errors\"\u003c/span\u003e: [\n        {\n            \u003cspan class=\"hljs-attr\"\u003e\"message\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"String cannot represent a non string value: 123\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003e\"extensions\"\u003c/span\u003e: {\n                \u003cspan class=\"hljs-attr\"\u003e\"code\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"GRAPHQL_VALIDATION_FAILED\"\u003c/span\u003e,\n            }\n        }\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"heading-400-but-a-server-error\"\u003e400 but a server error\u003c/h4\u003e\n\u003cp\u003eOne error that took some while for us to understand was the following one:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676465758320/d59330d4-2a2f-456e-ac2a-d3a7974f7856.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eIn Stellate we received lots of error messages with the response code 400. But the actual GraphQL error code was \u003ccode\u003eINTERNAL_SERVER_ERROR\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo what now? Validation error because of the response code 400? Or an internal server error? But why isn't that a 200 error then like in the first examples?\u003c/p\u003e\n\u003cp\u003eBy taking a closer look we saw that none of these exceptions had a query attached. By trying to reproduce it we saw that some people are trying out to send empty queries to our API. This results in a server error with the response code 400.\u003c/p\u003e\n\u003cp\u003eCases like these can be adjusted manually in Apollo. But by default, it behaves like that.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLearning from this scenario:\u003c/strong\u003e Understand that the GraphQL error code is the most important piece to understand. In this case, \u003ccode\u003eINTERNAL_SERVER_ERROR\u003c/code\u003e is an expected code and nothing is wrong with your server.\u003c/p\u003e\n\u003ch3 id=\"heading-playground-deactivated-403-vs-400\"\u003ePlayground deactivated - 403 vs. 400\u003c/h3\u003e\n\u003cp\u003eOne last error we faced a lot at times is a 403 error from Stellate:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676466176458/4281a5e9-abbe-42da-98a7-4cae155225c7.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThis error indicates that somebody is doing a \u003ccode\u003eGET\u003c/code\u003e request on our API. But when I tried to reproduce that I got a \u003ccode\u003e204 - No Content\u003c/code\u003e like seen above. It took some time to understand that this error message results if somebody tries to access a disabled GraphQL playground. When I try to access the \u003cstrong\u003eStellate Playground\u003c/strong\u003e I get a 403 Forbidden error.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676466433979/2249a5b1-5b88-43dd-8888-ffb16e4a4ffb.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBut\u003c/strong\u003e if I try to access the GraphQL Playground directly in Apollo and it is deactivated I get a 400 error.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1676466476500/83e0ad24-9a4a-4dbe-b440-9f337fa79c8c.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eThis is nothing major. It is still important for us to understand the differences. With that, we are able to act on real 403 issues.\u003c/p\u003e\n\u003ch2 id=\"heading-summary\"\u003eSummary\u003c/h2\u003e\n\u003cp\u003eIn summary, it is really important to understand the ins and outs of your API. Stellate makes our lives much easier by automatically parsing GraphQL error codes and showing the resulting response codes. In the end, everything is dependent on the implementation of your GraphQL server.\u003c/p\u003e\n\u003cp\u003eTo be able to act quickly on incidents or abnormal behavior it is critical to understand what each error code and error message actually means. Many errors are expected. Especially in cases like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eUnauthenticated access\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eValidation Errors\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut there are also many cases where they are not expected.\u003c/p\u003e\n\u003cp\u003eWe have created several alarms and in special cases also an automated generation of Incidents (👋🏽 Better Uptime) so that we are able to act quickly on all upcoming incidents.\u003c/p\u003e\n\u003cp\u003eThanks for sticking with me, see you soon 👋🏽\u003c/p\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1676972950688/8f04a52c-e667-49e3-92d4-480f990013f6.png"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"understanding-graphql-error-codes-with-stellate-aws-lambda-api-gateway-and-apollo"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>