{"pageProps":{"post":{"slug":"the-art-of-feed-curating-our-approach-to-generating-personalized-feeds-that-match-users-interests","url":"https://engineering.hashnode.com/the-art-of-feed-curating-our-approach-to-generating-personalized-feeds-that-match-users-interests","brief":"Feeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on hot ranking algorithms. Over time, we noticed that users struggle to ...","title":"The art of feed curating: Our approach to generating personalized feeds that match users' interests","publishedAt":"2023-09-05T12:53:57.776Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1693400608045/24b21141-0ceb-4827-a510-1f3dfee5e41f.jpeg"},"author":{"name":"Florian Fuchs","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1675085454170/766f4dd9-9fba-4aa7-b141-ff62bba7eafe.jpeg"},"id":"64f724e54ae4dfa2e3d4d440","content":{"markdown":"Feeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on [hot ranking algorithms.](https://saturncloud.io/blog/how-are-reddit-and-hacker-news-ranking-algorithms-used/#how-hot-ranking-works) Over time, we noticed that users struggle to find the content they are genuinely interested in on our platform. This is why we have decided to power up our feed game with personalized feeds üéâ\n\n### Why are personalized feeds such a big deal? ü§î\n\nWhen you visit a community platform, you want to see content that speaks to you. That's where personalized feeds come in! Instead of a generic feed, personalized feeds focus on what the user finds interesting and valuable. They do this by looking at your past interactions, interests, and other factors to serve up content that's right up your alley üéØ\n\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">üí°</div>\n<div data-node-type=\"callout-text\">Personalized feeds at Hashnode focus on what YOU find interesting!</div>\n</div>\n\nAs a result, users get an enjoyable and engaging experience. Personalized feeds help to keep users happy and active by catering to their preferences and interests.\n\nLet's explore how we implemented personalized feeds at Hashnode üöÄ\n\n## Personalized feeds for different users ‚Äì let‚Äôs see the result\n\nLet's examine the concept of personalization. From a user's standpoint, assuming that the feed will differ for each individual is reasonable. When we query our feed endpoint for two distinct users, we obtain the following results:\n\n![Comparing Feeds - Result for a User](https://cdn.hashnode.com/res/hashnode/image/upload/v1693294681441/869135e2-d7db-4ed0-b81c-faaa6fb54f22.gif align=\"center\")\n\n---\n\n![Comparing Feeds - Result for a User](https://cdn.hashnode.com/res/hashnode/image/upload/v1693294707867/3593c39f-2463-4067-98d0-79a61dfeb390.gif align=\"center\")\n\nThe users follow different tags and engage with Hashnode in unique ways. The outcome? A feed that is tailored to each user.  \nIf you want to see this in action, visit [our Homepage](https://hashnode.com/).\n\nLet's see how we have built this experience from an engineering perspective üëÄ\n\n## How to generate personalized feeds without machine learning?\n\nFor most platforms, machine learning is the go-to approach to calculate and personalize stuff. These techniques and algorithms have existed for a long time and are rooted in the early e-commerce systems to recommend other stuff that you may find interesting.  \nPlatforms like Facebook, Twitter, and Instagram have shown machine learning models can be effective when trained with enough and correct data.\n\n![a robot sitting on top of a wooden bench](https://images.unsplash.com/photo-1620712943543-bcc4688e7485?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1000&q=80 align=\"left\")\n\nAt Hashnode, we decided initially not to go the machine learning route for our personalized feeds. Although incorporating machine learning into our platform is a long-term objective, we have opted for an alternative approach in the interim.\n\nStarting with an ML approach is challenging. You need to have some knowledge about creating machine learning models and pipelines. You need to integrate ML into your existing platform. Multiple options are available: either go with self-hosting and self-creating/training your models or use a service where you can train models by feeding them data. The one point that stuck out was that you must understand your data and what you want to achieve with the model.\n\nWe decided to go with a ranking-based approach, as we wanted to verify assumptions we already had about our content and get out a better algorithm as fast as possible. To generate personalized feeds without machine learning, we have developed our own unique recipe for feed generation. This method considers various aspects and user behavior patterns that we believe will be most beneficial in ranking posts for each user. By carefully considering multiple factors, we can curate a feed that caters to our users' specific interests and needs.\n\n![a diagram of algorithm with different inputs to generate personalized feeds](https://cdn.hashnode.com/res/hashnode/image/upload/v1692887045099/9eca6989-c052-43bb-846b-a64b06fabbed.png align=\"center\")\n\nGoing with this route gives us the leverage to understand the influence different weights and data points have on the quality of our feed. It enables us to provide a more customized experience for our community members and continually refine and improve our feed generation process. Resulting in a faster delivery of even more relevant and captivating content as we gather more data and insights on user preferences and behavior.\n\nIn conclusion, while machine learning and AI algorithms are powerful tools for generating personalized feeds, traditional techniques can still be employed to create a tailored content experience.\n\nLet's look at what we use to develop a personalized feed for a user ü´£\n\n## Which data is relevant for feed calculation?\n\n![different inputs that are considered while calculating a personalized feed for a user ](https://cdn.hashnode.com/res/hashnode/image/upload/v1692886298254/fe479a1d-0835-458b-b399-14b1cb9acb65.png align=\"center\")\n\nTo effectively personalize feeds and generate accurate content rankings for each user, it is crucial to consider several pieces of data that can provide valuable insights into their preferences and behavior. These data points include:\n\n**User-specific:**\n\n* Followed Tags: The tags a user follows indicate their topics of interest. Content with matching tags should be prioritized higher.\n    \n* Following the Author/Blog: A user who follows an author or blog will likely enjoy that content source. Content from followed authors/blogs should be weighted more heavily.\n    \n* Reading History: What articles a user has read in the past shows their preferred content types and subjects. Similar new content should be ranked higher.\n    \n\n**Community-specific**:\n\n* Likes: If an article has received many likes from the community, it is likely high quality and relevant to some users.\n    \n* Comments: More engagement in comments also indicates relevance and popularity.\n    \n* Views: Higher-viewed content is generally more relevant to more users.\n    \n* Featured: Featured articles are chosen for their relevance and quality.\n    \n* Recency: Newer content is likely fresher and more timely. Furthermore, this boosts newly published content and freshens up the feed.\n    \n\n**Blog-specific**:\n\n* Pro Account: Pro on a blog can indicate that the authors use Hashnode on a more sophisticated level and leverage features such as Hashnode AI, which allows them to generate even more high-quality content.\n    \n* Custom Domain: Custom domains indicate authors leveraging Hashnode to build their brand and publish high-quality content.\n    \n\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">üí°</div>\n<div data-node-type=\"callout-text\">The above list shows roughly the importance of the weights in a declining order. The main focus lies on the User-specific weights, whereas the following categories have less and less influence on the score.</div>\n</div>\n\n## Ranking posts to generate personalized feeds\n\nNow, it's time to look at how weights are calculated and how they influence the score of a post within a user's feed. üßë‚Äçüíª\n\nThe User-specific weights are rather straightforward. We can check if the user is following the Author/Blog, the following tags added to the post, and if the article is from an author in the reading history of the user:\n\n```typescript\n  const followingScore = usersUserIsFollowing.includes(\n    post.author\n  )\n   ? FOLLOW_WEIGHT\n   : 0;\n\n  const readingHistoryScore = postsAuthorsUserHasViewed.includes(\n     post.author\n   )\n    ? READING_HISTORY_WEIGHT\n    : 0;\n\n   const tagScore = calculateTagWeights(\n     tagsUserIsFollowing,\n     post.tags\n   );\n\n   const userSpecificScore = followingScore \n                              + readingHistoryScore\n                              + tagScore;\n```\n\nFor the Community-specific weights, this is a little bit more difficult. We could go with a straightforward approach by deciding a weight for a single like and multiplying this with the likes this post has received, but the chance to over-boost a post becomes very high when going this route. Furthermore, this would not only result in potential over-boosts and decrease the relevance for the user, but it would also result in a non-uniform distribution of likes. Let's take a look at an example. Assuming two posts and a weight of 2 for each, like:\n\n$$10(likes) * 2 = 20$$\n\nand\n\n$$100(likes) * 2 = 200$$\n\n‚û°Ô∏è There is no way to compare these two as the values are too far apart.\n\nThe solution we came up with is twofold:\n\n* Normalize likes, views, and comments\n    \n* Treat the weight for these parameters as the maximum a post can receive. For this, we need to update how we calculate the weight.\n    \n\nThe formula can then look relatively easy. Let's retake a look at the likes for a post:\n\n```typescript\n// Baseline value, everything over 1000 likes will recive the\n// full score for the likes weight. Everything below will be fracitonal\n// For 1000 as basline this will be 3\nconst MAX_LIKE = Math.log10(1000);\n\n// For 10 likes this will be 1\n// For 100 likes this will be 2\nconst postLikes = Math.log10(post.likes)\n\n// Assuming 10 likes will result in: 1 * 2 / 3 = 0.66\n// Assuming 100 likes will result in: 2 * 2 /3 = 1.33\nconst scoreForLikes = (post.likes * LIKES_WEIGHT) / MAX_LIKE;\n\n// Check if the score is greater than the LIKES_WEIGHT\n// Yes -> use LIKES_WEIGHT\n// No -> use the calculated score \nconst actualLikeScore = scoreForLikes > LIKES_WEIGHT ? LIKES_WEIGHT : scoreForLikes\n```\n\nAs we can see in the above snippet, this way of calculating the scores will ensure that:\n\n* An article with many likes is not over-boosted\n    \n* The score does not exceed the weight we set as a maximum\n    \n* The values are more evenly distributed, comparing `20` to `200` (`10` times) vs. `0.66` to `1.33` (roughly `2` times)\n    \n\nThis is done for all the Community-specific weights except the featured flag, which can be easily added by checking if the post is featured on Hashnode.\n\nOn the other hand, Recency also needs a specific logic to give us a desired score so we do not overboost newly published articles.\n\n```typescript\nconst getDateFactorForFeed = (date: Date) => {\n  // Consider the last 30 days in hours\n  const recentTimeFrame = 720;\n\n// Divide the recent weight by the time frime to get the points \n// each hour will recive\n// e.g. 5 / 720 = 0.0069444444\n  const pointsPerHour = RECENT_WEIGHT / recentTimeFrame;\n\n// Calculate the difference in hours between now and the publish date\n// of the article \n  const difference = dayjs().diff(dayjs(date), 'hours');\n\n// The weight should not be negative. \n  const weight = Math.max(recentTimeFrame - difference, 0);\n\n// Multiple the resulting weight with the points for each hour\n// weight = 0 => 0 * 0.0069444444 = 0\n// weight = 720 => 720 * 0.0069444444 = 5\n  return weight * pointsPerHour;\n};\n```\n\nWith this calculation, the maximum value recency can receive will always be `RECENT_WEIGHT`.\n\nLastly, the Write-specific weights are calculated similarly to User-specific weights by checking if the Blog has connected a custom domain or is subscribed to Hashnode Pro.\n\nThe overall score calculation for the specific post adds up all our values, and we have a score for the post üöÄ\n\n## How we keep your feed fresh all the time\n\nAfter the initial testing, we noticed that the feed displays more relevant content but does not refresh as frequently as we would like.\n\n**How to make the feed highly dynamic and present fresh content on every visit?ü§î**\n\nThere are multiple possible solutions to do this, but we decided to explore damping. We don't want to harshly penalize articles by removing them from feeds. With damping, posts receive a slight reduction in their score if they have already been presented to the user. Moreover, this allows them to reappear in the feed and be noticed by the user. To ensure fair treatment for all articles, we have decided on the following rules:\n\n* The damping is based on the page an article is presented on\n    \n* As the number of pages increases, the damping of articles on those pages decreases.\n    \n* We will only implement damping for the first five pages, ensuring we do not inadvertently exclude any articles beyond that point.\n    \n\nAfter 24 hours, we remove all damping effects from a user's feed, allowing each post to potentially resurface in the upper positions.\n\nIn combination with the score calculation algorithm, this has a very nice effect:\n\n\n<div style={{ maxWidth: \"100%\", margin: \"0 auto\" }}>\n  <iframe\n    src=\"https://veed.io/embed/530d4a96-da87-4436-9a34-9cf2ec1b0efc\"\n    width=\"100%\"\n    height=\"504\"\n    style={{ border: \"none\" }}\n    allowFullScreen\n  />\n</div>\n\n## Next plans for the personalized feeds on hashnode\n\nNow that we have created an algorithm and prepared the groundwork, what comes next for our new personalized feed?\n\nI assume you guessed it right:\n\n%[https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif] \n\nInitially, we only wanted to verify our assumptions about content and how to create a feed that engages users and shows high-quality and highly relevant articles from our Platform.\n\nAs you can imagine, the calculation is expensive from a computational point of view. We need to gather the latest posts from our platform, collect data for the user, and calculate the scores for each post before we can serve them. It is also not as straightforward as it would be with a following feed. There, we could cache everything and append new posts on the top of the cache to be served on a request to the feed.\n\nIn the case of a personalized feed, we need to have the user metadata at hand to correctly assign a score to the article for the user based on the algorithm.\n\nGuess what? We've developed a nice solution that I'll dive into in another article! But here's a little sneak peek: We're pre-calculating the personalized feed for all our active users on the platform! This way, we can slash peak loads on our service and serve the feed at lightning-fast speeds! üöÄüí•üèéÔ∏è\n\nUntil the next one,\n\nCheers üôå","html":"<p>Feeds are an essential part of every social network. The same applies here at Hashnode. Until now, we have used a very basic and generic algorithm to generate feeds mainly based on <a target=\"_blank\" href=\"https://saturncloud.io/blog/how-are-reddit-and-hacker-news-ranking-algorithms-used/#how-hot-ranking-works\">hot ranking algorithms.</a> Over time, we noticed that users struggle to find the content they are genuinely interested in on our platform. This is why we have decided to power up our feed game with personalized feeds üéâ</p>\n<h3 id=\"heading-why-are-personalized-feeds-such-a-big-deal\">Why are personalized feeds such a big deal? ü§î</h3>\n<p>When you visit a community platform, you want to see content that speaks to you. That's where personalized feeds come in! Instead of a generic feed, personalized feeds focus on what the user finds interesting and valuable. They do this by looking at your past interactions, interests, and other factors to serve up content that's right up your alley üéØ</p>\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">üí°</div>\n<div data-node-type=\"callout-text\">Personalized feeds at Hashnode focus on what YOU find interesting!</div>\n</div>\n\n<p>As a result, users get an enjoyable and engaging experience. Personalized feeds help to keep users happy and active by catering to their preferences and interests.</p>\n<p>Let's explore how we implemented personalized feeds at Hashnode üöÄ</p>\n<h2 id=\"heading-personalized-feeds-for-different-users-lets-see-the-result\">Personalized feeds for different users ‚Äì let‚Äôs see the result</h2>\n<p>Let's examine the concept of personalization. From a user's standpoint, assuming that the feed will differ for each individual is reasonable. When we query our feed endpoint for two distinct users, we obtain the following results:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1693294681441/869135e2-d7db-4ed0-b81c-faaa6fb54f22.gif\" alt=\"Comparing Feeds - Result for a User\" class=\"image--center mx-auto\" /></p>\n<hr />\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1693294707867/3593c39f-2463-4067-98d0-79a61dfeb390.gif\" alt=\"Comparing Feeds - Result for a User\" class=\"image--center mx-auto\" /></p>\n<p>The users follow different tags and engage with Hashnode in unique ways. The outcome? A feed that is tailored to each user.<br />If you want to see this in action, visit <a target=\"_blank\" href=\"https://hashnode.com/\">our Homepage</a>.</p>\n<p>Let's see how we have built this experience from an engineering perspective üëÄ</p>\n<h2 id=\"heading-how-to-generate-personalized-feeds-without-machine-learning\">How to generate personalized feeds without machine learning?</h2>\n<p>For most platforms, machine learning is the go-to approach to calculate and personalize stuff. These techniques and algorithms have existed for a long time and are rooted in the early e-commerce systems to recommend other stuff that you may find interesting.<br />Platforms like Facebook, Twitter, and Instagram have shown machine learning models can be effective when trained with enough and correct data.</p>\n<p><img src=\"https://images.unsplash.com/photo-1620712943543-bcc4688e7485?ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80\" alt=\"a robot sitting on top of a wooden bench\" /></p>\n<p>At Hashnode, we decided initially not to go the machine learning route for our personalized feeds. Although incorporating machine learning into our platform is a long-term objective, we have opted for an alternative approach in the interim.</p>\n<p>Starting with an ML approach is challenging. You need to have some knowledge about creating machine learning models and pipelines. You need to integrate ML into your existing platform. Multiple options are available: either go with self-hosting and self-creating/training your models or use a service where you can train models by feeding them data. The one point that stuck out was that you must understand your data and what you want to achieve with the model.</p>\n<p>We decided to go with a ranking-based approach, as we wanted to verify assumptions we already had about our content and get out a better algorithm as fast as possible. To generate personalized feeds without machine learning, we have developed our own unique recipe for feed generation. This method considers various aspects and user behavior patterns that we believe will be most beneficial in ranking posts for each user. By carefully considering multiple factors, we can curate a feed that caters to our users' specific interests and needs.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1692887045099/9eca6989-c052-43bb-846b-a64b06fabbed.png\" alt=\"a diagram of algorithm with different inputs to generate personalized feeds\" class=\"image--center mx-auto\" /></p>\n<p>Going with this route gives us the leverage to understand the influence different weights and data points have on the quality of our feed. It enables us to provide a more customized experience for our community members and continually refine and improve our feed generation process. Resulting in a faster delivery of even more relevant and captivating content as we gather more data and insights on user preferences and behavior.</p>\n<p>In conclusion, while machine learning and AI algorithms are powerful tools for generating personalized feeds, traditional techniques can still be employed to create a tailored content experience.</p>\n<p>Let's look at what we use to develop a personalized feed for a user ü´£</p>\n<h2 id=\"heading-which-data-is-relevant-for-feed-calculation\">Which data is relevant for feed calculation?</h2>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1692886298254/fe479a1d-0835-458b-b399-14b1cb9acb65.png\" alt=\"different inputs that are considered while calculating a personalized feed for a user \" class=\"image--center mx-auto\" /></p>\n<p>To effectively personalize feeds and generate accurate content rankings for each user, it is crucial to consider several pieces of data that can provide valuable insights into their preferences and behavior. These data points include:</p>\n<p><strong>User-specific:</strong></p>\n<ul>\n<li><p>Followed Tags: The tags a user follows indicate their topics of interest. Content with matching tags should be prioritized higher.</p>\n</li>\n<li><p>Following the Author/Blog: A user who follows an author or blog will likely enjoy that content source. Content from followed authors/blogs should be weighted more heavily.</p>\n</li>\n<li><p>Reading History: What articles a user has read in the past shows their preferred content types and subjects. Similar new content should be ranked higher.</p>\n</li>\n</ul>\n<p><strong>Community-specific</strong>:</p>\n<ul>\n<li><p>Likes: If an article has received many likes from the community, it is likely high quality and relevant to some users.</p>\n</li>\n<li><p>Comments: More engagement in comments also indicates relevance and popularity.</p>\n</li>\n<li><p>Views: Higher-viewed content is generally more relevant to more users.</p>\n</li>\n<li><p>Featured: Featured articles are chosen for their relevance and quality.</p>\n</li>\n<li><p>Recency: Newer content is likely fresher and more timely. Furthermore, this boosts newly published content and freshens up the feed.</p>\n</li>\n</ul>\n<p><strong>Blog-specific</strong>:</p>\n<ul>\n<li><p>Pro Account: Pro on a blog can indicate that the authors use Hashnode on a more sophisticated level and leverage features such as Hashnode AI, which allows them to generate even more high-quality content.</p>\n</li>\n<li><p>Custom Domain: Custom domains indicate authors leveraging Hashnode to build their brand and publish high-quality content.</p>\n</li>\n</ul>\n<div data-node-type=\"callout\">\n<div data-node-type=\"callout-emoji\">üí°</div>\n<div data-node-type=\"callout-text\">The above list shows roughly the importance of the weights in a declining order. The main focus lies on the User-specific weights, whereas the following categories have less and less influence on the score.</div>\n</div>\n\n<h2 id=\"heading-ranking-posts-to-generate-personalized-feeds\">Ranking posts to generate personalized feeds</h2>\n<p>Now, it's time to look at how weights are calculated and how they influence the score of a post within a user's feed. üßë‚Äçüíª</p>\n<p>The User-specific weights are rather straightforward. We can check if the user is following the Author/Blog, the following tags added to the post, and if the article is from an author in the reading history of the user:</p>\n<pre><code class=\"lang-typescript\">  <span class=\"hljs-keyword\">const</span> followingScore = usersUserIsFollowing.includes(\n    post.author\n  )\n   ? FOLLOW_WEIGHT\n   : <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-keyword\">const</span> readingHistoryScore = postsAuthorsUserHasViewed.includes(\n     post.author\n   )\n    ? READING_HISTORY_WEIGHT\n    : <span class=\"hljs-number\">0</span>;\n\n   <span class=\"hljs-keyword\">const</span> tagScore = calculateTagWeights(\n     tagsUserIsFollowing,\n     post.tags\n   );\n\n   <span class=\"hljs-keyword\">const</span> userSpecificScore = followingScore \n                              + readingHistoryScore\n                              + tagScore;\n</code></pre>\n<p>For the Community-specific weights, this is a little bit more difficult. We could go with a straightforward approach by deciding a weight for a single like and multiplying this with the likes this post has received, but the chance to over-boost a post becomes very high when going this route. Furthermore, this would not only result in potential over-boosts and decrease the relevance for the user, but it would also result in a non-uniform distribution of likes. Let's take a look at an example. Assuming two posts and a weight of 2 for each, like:</p>\n<p>$$10(likes) * 2 = 20$$</p><p>and</p>\n<p>$$100(likes) * 2 = 200$$</p><p>‚û°Ô∏è There is no way to compare these two as the values are too far apart.</p>\n<p>The solution we came up with is twofold:</p>\n<ul>\n<li><p>Normalize likes, views, and comments</p>\n</li>\n<li><p>Treat the weight for these parameters as the maximum a post can receive. For this, we need to update how we calculate the weight.</p>\n</li>\n</ul>\n<p>The formula can then look relatively easy. Let's retake a look at the likes for a post:</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// Baseline value, everything over 1000 likes will recive the</span>\n<span class=\"hljs-comment\">// full score for the likes weight. Everything below will be fracitonal</span>\n<span class=\"hljs-comment\">// For 1000 as basline this will be 3</span>\n<span class=\"hljs-keyword\">const</span> MAX_LIKE = <span class=\"hljs-built_in\">Math</span>.log10(<span class=\"hljs-number\">1000</span>);\n\n<span class=\"hljs-comment\">// For 10 likes this will be 1</span>\n<span class=\"hljs-comment\">// For 100 likes this will be 2</span>\n<span class=\"hljs-keyword\">const</span> postLikes = <span class=\"hljs-built_in\">Math</span>.log10(post.likes)\n\n<span class=\"hljs-comment\">// Assuming 10 likes will result in: 1 * 2 / 3 = 0.66</span>\n<span class=\"hljs-comment\">// Assuming 100 likes will result in: 2 * 2 /3 = 1.33</span>\n<span class=\"hljs-keyword\">const</span> scoreForLikes = (post.likes * LIKES_WEIGHT) / MAX_LIKE;\n\n<span class=\"hljs-comment\">// Check if the score is greater than the LIKES_WEIGHT</span>\n<span class=\"hljs-comment\">// Yes -&gt; use LIKES_WEIGHT</span>\n<span class=\"hljs-comment\">// No -&gt; use the calculated score </span>\n<span class=\"hljs-keyword\">const</span> actualLikeScore = scoreForLikes &gt; LIKES_WEIGHT ? LIKES_WEIGHT : scoreForLikes\n</code></pre>\n<p>As we can see in the above snippet, this way of calculating the scores will ensure that:</p>\n<ul>\n<li><p>An article with many likes is not over-boosted</p>\n</li>\n<li><p>The score does not exceed the weight we set as a maximum</p>\n</li>\n<li><p>The values are more evenly distributed, comparing <code>20</code> to <code>200</code> (<code>10</code> times) vs. <code>0.66</code> to <code>1.33</code> (roughly <code>2</code> times)</p>\n</li>\n</ul>\n<p>This is done for all the Community-specific weights except the featured flag, which can be easily added by checking if the post is featured on Hashnode.</p>\n<p>On the other hand, Recency also needs a specific logic to give us a desired score so we do not overboost newly published articles.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> getDateFactorForFeed = <span class=\"hljs-function\">(<span class=\"hljs-params\">date: <span class=\"hljs-built_in\">Date</span></span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// Consider the last 30 days in hours</span>\n  <span class=\"hljs-keyword\">const</span> recentTimeFrame = <span class=\"hljs-number\">720</span>;\n\n<span class=\"hljs-comment\">// Divide the recent weight by the time frime to get the points </span>\n<span class=\"hljs-comment\">// each hour will recive</span>\n<span class=\"hljs-comment\">// e.g. 5 / 720 = 0.0069444444</span>\n  <span class=\"hljs-keyword\">const</span> pointsPerHour = RECENT_WEIGHT / recentTimeFrame;\n\n<span class=\"hljs-comment\">// Calculate the difference in hours between now and the publish date</span>\n<span class=\"hljs-comment\">// of the article </span>\n  <span class=\"hljs-keyword\">const</span> difference = dayjs().diff(dayjs(date), <span class=\"hljs-string\">'hours'</span>);\n\n<span class=\"hljs-comment\">// The weight should not be negative. </span>\n  <span class=\"hljs-keyword\">const</span> weight = <span class=\"hljs-built_in\">Math</span>.max(recentTimeFrame - difference, <span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-comment\">// Multiple the resulting weight with the points for each hour</span>\n<span class=\"hljs-comment\">// weight = 0 =&gt; 0 * 0.0069444444 = 0</span>\n<span class=\"hljs-comment\">// weight = 720 =&gt; 720 * 0.0069444444 = 5</span>\n  <span class=\"hljs-keyword\">return</span> weight * pointsPerHour;\n};\n</code></pre>\n<p>With this calculation, the maximum value recency can receive will always be <code>RECENT_WEIGHT</code>.</p>\n<p>Lastly, the Write-specific weights are calculated similarly to User-specific weights by checking if the Blog has connected a custom domain or is subscribed to Hashnode Pro.</p>\n<p>The overall score calculation for the specific post adds up all our values, and we have a score for the post üöÄ</p>\n<h2 id=\"heading-how-we-keep-your-feed-fresh-all-the-time\">How we keep your feed fresh all the time</h2>\n<p>After the initial testing, we noticed that the feed displays more relevant content but does not refresh as frequently as we would like.</p>\n<p><strong>How to make the feed highly dynamic and present fresh content on every visit?ü§î</strong></p>\n<p>There are multiple possible solutions to do this, but we decided to explore damping. We don't want to harshly penalize articles by removing them from feeds. With damping, posts receive a slight reduction in their score if they have already been presented to the user. Moreover, this allows them to reappear in the feed and be noticed by the user. To ensure fair treatment for all articles, we have decided on the following rules:</p>\n<ul>\n<li><p>The damping is based on the page an article is presented on</p>\n</li>\n<li><p>As the number of pages increases, the damping of articles on those pages decreases.</p>\n</li>\n<li><p>We will only implement damping for the first five pages, ensuring we do not inadvertently exclude any articles beyond that point.</p>\n</li>\n</ul>\n<p>After 24 hours, we remove all damping effects from a user's feed, allowing each post to potentially resurface in the upper positions.</p>\n<p>In combination with the score calculation algorithm, this has a very nice effect:</p>\n<div>\n  <iframe src=\"https://veed.io/embed/530d4a96-da87-4436-9a34-9cf2ec1b0efc\" width=\"100%\" height=\"504\">\n</iframe></div>\n\n<h2 id=\"heading-next-plans-for-the-personalized-feeds-on-hashnode\">Next plans for the personalized feeds on hashnode</h2>\n<p>Now that we have created an algorithm and prepared the groundwork, what comes next for our new personalized feed?</p>\n<p>I assume you guessed it right:</p>\n<div class=\"embed-wrapper\"><div class=\"embed-loading\"><div class=\"loadingRow\"></div><div class=\"loadingRow\"></div></div><a class=\"embed-card\" href=\"https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif\">https://media.giphy.com/media/sGQczHZ49ICQTTXacn/giphy.gif</a></div>\n<p> </p>\n<p>Initially, we only wanted to verify our assumptions about content and how to create a feed that engages users and shows high-quality and highly relevant articles from our Platform.</p>\n<p>As you can imagine, the calculation is expensive from a computational point of view. We need to gather the latest posts from our platform, collect data for the user, and calculate the scores for each post before we can serve them. It is also not as straightforward as it would be with a following feed. There, we could cache everything and append new posts on the top of the cache to be served on a request to the feed.</p>\n<p>In the case of a personalized feed, we need to have the user metadata at hand to correctly assign a score to the article for the user based on the algorithm.</p>\n<p>Guess what? We've developed a nice solution that I'll dive into in another article! But here's a little sneak peek: We're pre-calculating the personalized feed for all our active users on the platform! This way, we can slash peak loads on our service and serve the feed at lightning-fast speeds! üöÄüí•üèéÔ∏è</p>\n<p>Until the next one,</p>\n<p>Cheers üôå</p>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1693400623549/fb200935-78c6-42d1-bb7f-96b3bac6a128.jpeg"}}},"__N_SSG":true}