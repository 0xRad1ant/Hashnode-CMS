<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>Introducing Amazon EventBridge: Building Serverless Event-Driven Architectures with AWS | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/aws-eventbridge-intro"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1671013503443/INGnCMjJb.png"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">Introducing Amazon EventBridge: Building Serverless Event-Driven Architectures with AWS</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg" class="w-10 h-10 rounded-full" alt="Sandro Volpicella"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Sandro Volpicella</div></div><time dateTime="2022-12-14T10:31:48.085Z">December 14, 2022</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for Introducing Amazon EventBridge: Building Serverless Event-Driven Architectures with AWS" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1671013477321%2FsquQtugN5.png&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>This is part 3 of our series: <strong>How we build EDA at Hashnode on AWS.</strong></p>
<p>In part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.</p>
<h2 id="heading-what-is-eventbridge">What is EventBridge</h2>
<p>Amazon EventBridge is a service to build serverless event-driven architectures. It was launched in 2019. Formerly it was part of the CloudWatch Service and was called CloudWatch Events.</p>
<p>EventBridge allows you to build EDA and integrate it with many AWS services. Each AWS Account has a default event bus. This event bus receives all events from internal AWS Services like ECS, EC2, or Lambda.</p>
<p>Additionally, EventBridge partners with many third-party SaaS tools such as MongoDB, Zendesk, or Shopify. This makes the integration even easier.</p>
<h2 id="heading-components">Components</h2>
<p>Amazon EventBridge has several components. Let's go through the components one by one and see what their functionality is.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1662711481911/-07JByTwJ.png" alt="Amazon EventBridge Components" class="image--center mx-auto" /></p>
<h3 id="heading-event-bus">Event Bus</h3>
<p>One of the main components of EventBridge is an event bus. You send all events from your event producer to an event bus.</p>
<p>Each AWS account has a default event bus. This default event bus receives events from within AWS.</p>
<p>Examples of these events are:</p>
<ul>
<li><p>EC2 instance was created</p>
</li>
<li><p>ECS task state changed</p>
</li>
<li><p>EventBridge schema changed</p>
</li>
</ul>
<p>You can also create a custom event bus. You can send any kind of event you want to the custom event bus.</p>
<p>Partner events (Auth0, MongoDB, etc.) are creating their own custom event bus.</p>
<h3 id="heading-rule">Rule</h3>
<p>The second component is the event rule.</p>
<p>EventBridge allows you to create rules. A rule belongs to an event bus. The rule defines in which cases the event will be sent to the consumers.</p>
<p>The rule has an event pattern. This is one of the core functionalities and strengths of EventBridge. The rule matches <strong>the whole message body</strong>.</p>
<p>An incoming event is a JSON object. You can match any key-value pair in this JSON object.</p>
<p>If a rule matches the event will be forwarded to a <strong>target</strong>.</p>
<p>Here are some examples of things you can match:</p>
<ul>
<li><p>Value is null: <code>"data":[null]</code></p>
</li>
<li><p>Value is empty: <code>"data":[""]</code></p>
</li>
<li><p>Value equals something <code>"name": ["Sandro"]</code></p>
</li>
</ul>
<p>There are many more operators <a target="_blank" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html">available</a>.</p>
<p>For our example above, the rule is the following:</p>
<pre><code class="lang-json">{
  <span class="hljs-attr">"detail-type"</span>: [<span class="hljs-string">"postPublished"</span>],
  <span class="hljs-attr">"source"</span>: [<span class="hljs-string">"hashnode.api"</span>],
  <span class="hljs-attr">"detail"</span>: {
    <span class="hljs-attr">"data"</span>: {
      <span class="hljs-attr">"publication"</span>: {
        <span class="hljs-attr">"audioBlogEnabled"</span>: [ <span class="hljs-literal">true</span> ]
      }
    }
  }
}
</code></pre>
<p>Only events that look like that will be matched by the rule:</p>
<pre><code class="lang-JSON">{
    <span class="hljs-attr">"detail-type"</span>: <span class="hljs-string">"postPublished"</span>,
    <span class="hljs-attr">"source"</span>: <span class="hljs-string">"hashnode.api"</span>,
    <span class="hljs-attr">"detail"</span>: {
        <span class="hljs-attr">"data"</span>: {
            <span class="hljs-attr">"publication"</span>: {
                <span class="hljs-attr">"audioBlogEnabled"</span>: <span class="hljs-literal">true</span>
            }
        }
    }
}
</code></pre>
<p>If <code>audioBlogEnabled</code> is <code>false</code> or missing the rule won't match and therefore, no target will be called.</p>
<p>What happens if a rule matches? The event will be pushed to its <strong>targets</strong>.</p>
<h3 id="heading-target">Target</h3>
<p>A target is the subscriber of an event rule. There are many target types available in EventBridge. Some of the most important ones are:</p>
<ul>
<li><p>Lambda</p>
</li>
<li><p>SNS Topic</p>
</li>
<li><p>SQS Queue</p>
</li>
<li><p>Step Functions</p>
</li>
<li><p>API Destinations</p>
</li>
</ul>
<p>You can see a list of all supported targets <a target="_blank" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html">here</a>.</p>
<p>Once the rule matches the target will be invoked and the rule will be sent to this target.</p>
<h2 id="heading-cron-jobs">Cron Jobs</h2>
<p>Cron jobs are regularly executed scripts. EventBridge allows you to run jobs at regular intervals. A cron job can either be defined by a schedule like <code>run every minute</code> or by the cron syntax, for example, <code>0 10 * * ? *</code>.</p>
<p>EventBridge calls the target in this interval. Cron jobs live on the default event bus.</p>
<h2 id="heading-archive-amp-replay">Archive &amp; Replay</h2>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1666603891263/ZnT3GmvGl.png" alt="Archive and Replay in EventBridge" /></p>
<p>A really nice feature that was already mentioned in the last post is <strong>Archive &amp; Replay</strong>.</p>
<p>If you enable the archive functionality, EventBridge will create an archive of <strong>all events that are sent to this event bus</strong>. This comes in super handy when you introduced a bug and want to run all events again.</p>
<p>Also, this is pretty useful for using production workloads in a development environment.</p>
<p>With the replay functionality, you can define a start and end time from when the events should be replayed and on which event bus.</p>
<h2 id="heading-schema-bindings">Schema Bindings</h2>
<p>EventBridge allows you to activate a schema discovery. The schema discovery can then go ahead and create type bindings <strong>automatically for you</strong>. For example, you can activate schema discovery for your event bus. Then send events to this bus and finally, generate TypeScript types.</p>
<p>While this idea is really nice it has some drawbacks so we cannot use it right now at Hashnode. For example, it is not really possible to use optional fields.</p>
<p>This is why I won't dive deeper into this topic.</p>
<h2 id="heading-target-lambda">Target Lambda</h2>
<p>There are many ways to execute your business logic in a target attached to an EventBridge rule. We chose Lambda as the main target for all of our targets.</p>
<p>One alternative was the usage of SQS between EventBridge and Lambda. While the SQS &amp; Lambda approach can be useful for tasks that require a more complicated retry logic, for our case a simple lambda function with Destinations is much easier to implement.</p>
<p>Lambda functions which are called asynchronously also have an SQS in the background. AWS takes care of that.</p>
<p>Failed messages can still be sent to a custom DLQ.</p>
<p>We will show you in one of the next posts how we handle retries and failures in detail.</p>
<h2 id="heading-final-words">Final Words</h2>
<p>This is our introduction to EventBridge and the last one of our basic posts.</p>
<p>Now we will dive deeper into the actual implementation and some nitty-gritty of this architecture.</p>
<p>Posts that will follow soon are:</p>
<ul>
<li><p>Failures &amp; Retries with EventBridge, Lambda, and Destinations</p>
</li>
<li><p>How to validate incoming events with Middy &amp; ZOD</p>
</li>
<li><p>Integration tests with EventBridge</p>
</li>
</ul>
<p>Stay tuned 🤘</p>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"aws-eventbridge-intro","url":"https://engineering.hashnode.com/aws-eventbridge-intro","brief":"This is part 3 of our series: How we build EDA at Hashnode on AWS.\nIn part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.\nWhat is EventBri...","title":"Introducing Amazon EventBridge: Building Serverless Event-Driven Architectures with AWS","publishedAt":"2022-12-14T10:31:48.085Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1671013477321/squQtugN5.png"},"author":{"name":"Sandro Volpicella","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1627027343841/bT6HIivZm.jpeg"},"id":"6399a61430a84696a5937a5a","content":{"markdown":"This is part 3 of our series: **How we build EDA at Hashnode on AWS.**\n\nIn part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.\n\n## What is EventBridge\n\nAmazon EventBridge is a service to build serverless event-driven architectures. It was launched in 2019. Formerly it was part of the CloudWatch Service and was called CloudWatch Events.\n\nEventBridge allows you to build EDA and integrate it with many AWS services. Each AWS Account has a default event bus. This event bus receives all events from internal AWS Services like ECS, EC2, or Lambda.\n\nAdditionally, EventBridge partners with many third-party SaaS tools such as MongoDB, Zendesk, or Shopify. This makes the integration even easier.\n\n## Components\n\nAmazon EventBridge has several components. Let's go through the components one by one and see what their functionality is.\n\n![Amazon EventBridge Components](https://cdn.hashnode.com/res/hashnode/image/upload/v1662711481911/-07JByTwJ.png align=\"center\")\n\n### Event Bus\n\nOne of the main components of EventBridge is an event bus. You send all events from your event producer to an event bus.\n\nEach AWS account has a default event bus. This default event bus receives events from within AWS.\n\nExamples of these events are:\n\n*   EC2 instance was created\n    \n*   ECS task state changed\n    \n*   EventBridge schema changed\n    \n\nYou can also create a custom event bus. You can send any kind of event you want to the custom event bus.\n\nPartner events (Auth0, MongoDB, etc.) are creating their own custom event bus.\n\n### Rule\n\nThe second component is the event rule.\n\nEventBridge allows you to create rules. A rule belongs to an event bus. The rule defines in which cases the event will be sent to the consumers.\n\nThe rule has an event pattern. This is one of the core functionalities and strengths of EventBridge. The rule matches **the whole message body**.\n\nAn incoming event is a JSON object. You can match any key-value pair in this JSON object.\n\nIf a rule matches the event will be forwarded to a **target**.\n\nHere are some examples of things you can match:\n\n*   Value is null: `\"data\":[null]`\n    \n*   Value is empty: `\"data\":[\"\"]`\n    \n*   Value equals something `\"name\": [\"Sandro\"]`\n    \n\nThere are many more operators [available](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html).\n\nFor our example above, the rule is the following:\n\n```json\n{\n  \"detail-type\": [\"postPublished\"],\n  \"source\": [\"hashnode.api\"],\n  \"detail\": {\n    \"data\": {\n      \"publication\": {\n        \"audioBlogEnabled\": [ true ]\n      }\n    }\n  }\n}\n```\n\nOnly events that look like that will be matched by the rule:\n\n```JSON\n{\n    \"detail-type\": \"postPublished\",\n    \"source\": \"hashnode.api\",\n    \"detail\": {\n        \"data\": {\n            \"publication\": {\n                \"audioBlogEnabled\": true\n            }\n        }\n    }\n}\n```\n\nIf `audioBlogEnabled` is `false` or missing the rule won't match and therefore, no target will be called.\n\nWhat happens if a rule matches? The event will be pushed to its **targets**.\n\n### Target\n\nA target is the subscriber of an event rule. There are many target types available in EventBridge. Some of the most important ones are:\n\n*   Lambda\n    \n*   SNS Topic\n    \n*   SQS Queue\n    \n*   Step Functions\n    \n*   API Destinations\n    \n\nYou can see a list of all supported targets [here](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html).\n\nOnce the rule matches the target will be invoked and the rule will be sent to this target.\n\n## Cron Jobs\n\nCron jobs are regularly executed scripts. EventBridge allows you to run jobs at regular intervals. A cron job can either be defined by a schedule like `run every minute` or by the cron syntax, for example, `0 10 * * ? *`.\n\nEventBridge calls the target in this interval. Cron jobs live on the default event bus.\n\n## Archive \u0026 Replay\n\n![Archive and Replay in EventBridge](https://cdn.hashnode.com/res/hashnode/image/upload/v1666603891263/ZnT3GmvGl.png align=\"left\")\n\nA really nice feature that was already mentioned in the last post is **Archive \u0026 Replay**.\n\nIf you enable the archive functionality, EventBridge will create an archive of **all events that are sent to this event bus**. This comes in super handy when you introduced a bug and want to run all events again.\n\nAlso, this is pretty useful for using production workloads in a development environment.\n\nWith the replay functionality, you can define a start and end time from when the events should be replayed and on which event bus.\n\n## Schema Bindings\n\nEventBridge allows you to activate a schema discovery. The schema discovery can then go ahead and create type bindings **automatically for you**. For example, you can activate schema discovery for your event bus. Then send events to this bus and finally, generate TypeScript types.\n\nWhile this idea is really nice it has some drawbacks so we cannot use it right now at Hashnode. For example, it is not really possible to use optional fields.\n\nThis is why I won't dive deeper into this topic.\n\n## Target Lambda\n\nThere are many ways to execute your business logic in a target attached to an EventBridge rule. We chose Lambda as the main target for all of our targets.\n\nOne alternative was the usage of SQS between EventBridge and Lambda. While the SQS \u0026 Lambda approach can be useful for tasks that require a more complicated retry logic, for our case a simple lambda function with Destinations is much easier to implement.\n\nLambda functions which are called asynchronously also have an SQS in the background. AWS takes care of that.\n\nFailed messages can still be sent to a custom DLQ.\n\nWe will show you in one of the next posts how we handle retries and failures in detail.\n\n## Final Words\n\nThis is our introduction to EventBridge and the last one of our basic posts.\n\nNow we will dive deeper into the actual implementation and some nitty-gritty of this architecture.\n\nPosts that will follow soon are:\n\n*   Failures \u0026 Retries with EventBridge, Lambda, and Destinations\n    \n*   How to validate incoming events with Middy \u0026 ZOD\n    \n*   Integration tests with EventBridge\n    \n\nStay tuned 🤘","html":"\u003cp\u003eThis is part 3 of our series: \u003cstrong\u003eHow we build EDA at Hashnode on AWS.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn part 2 we decided to use Amazon EventBridge as our main service to build the Event-Driven Architecture (EDA). Part 3 covers the basic functionality of EventBridge.\u003c/p\u003e\n\u003ch2 id=\"heading-what-is-eventbridge\"\u003eWhat is EventBridge\u003c/h2\u003e\n\u003cp\u003eAmazon EventBridge is a service to build serverless event-driven architectures. It was launched in 2019. Formerly it was part of the CloudWatch Service and was called CloudWatch Events.\u003c/p\u003e\n\u003cp\u003eEventBridge allows you to build EDA and integrate it with many AWS services. Each AWS Account has a default event bus. This event bus receives all events from internal AWS Services like ECS, EC2, or Lambda.\u003c/p\u003e\n\u003cp\u003eAdditionally, EventBridge partners with many third-party SaaS tools such as MongoDB, Zendesk, or Shopify. This makes the integration even easier.\u003c/p\u003e\n\u003ch2 id=\"heading-components\"\u003eComponents\u003c/h2\u003e\n\u003cp\u003eAmazon EventBridge has several components. Let's go through the components one by one and see what their functionality is.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1662711481911/-07JByTwJ.png\" alt=\"Amazon EventBridge Components\" class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"heading-event-bus\"\u003eEvent Bus\u003c/h3\u003e\n\u003cp\u003eOne of the main components of EventBridge is an event bus. You send all events from your event producer to an event bus.\u003c/p\u003e\n\u003cp\u003eEach AWS account has a default event bus. This default event bus receives events from within AWS.\u003c/p\u003e\n\u003cp\u003eExamples of these events are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eEC2 instance was created\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eECS task state changed\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eEventBridge schema changed\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can also create a custom event bus. You can send any kind of event you want to the custom event bus.\u003c/p\u003e\n\u003cp\u003ePartner events (Auth0, MongoDB, etc.) are creating their own custom event bus.\u003c/p\u003e\n\u003ch3 id=\"heading-rule\"\u003eRule\u003c/h3\u003e\n\u003cp\u003eThe second component is the event rule.\u003c/p\u003e\n\u003cp\u003eEventBridge allows you to create rules. A rule belongs to an event bus. The rule defines in which cases the event will be sent to the consumers.\u003c/p\u003e\n\u003cp\u003eThe rule has an event pattern. This is one of the core functionalities and strengths of EventBridge. The rule matches \u003cstrong\u003ethe whole message body\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eAn incoming event is a JSON object. You can match any key-value pair in this JSON object.\u003c/p\u003e\n\u003cp\u003eIf a rule matches the event will be forwarded to a \u003cstrong\u003etarget\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eHere are some examples of things you can match:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eValue is null: \u003ccode\u003e\"data\":[null]\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eValue is empty: \u003ccode\u003e\"data\":[\"\"]\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eValue equals something \u003ccode\u003e\"name\": [\"Sandro\"]\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are many more operators \u003ca target=\"_blank\" href=\"https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html\"\u003eavailable\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor our example above, the rule is the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-json\"\u003e{\n  \u003cspan class=\"hljs-attr\"\u003e\"detail-type\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"postPublished\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003e\"source\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"hashnode.api\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003e\"detail\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003e\"data\"\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003e\"publication\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003e\"audioBlogEnabled\"\u003c/span\u003e: [ \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e ]\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnly events that look like that will be matched by the rule:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-JSON\"\u003e{\n    \u003cspan class=\"hljs-attr\"\u003e\"detail-type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"postPublished\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"source\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"hashnode.api\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003e\"detail\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003e\"data\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-attr\"\u003e\"publication\"\u003c/span\u003e: {\n                \u003cspan class=\"hljs-attr\"\u003e\"audioBlogEnabled\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003eaudioBlogEnabled\u003c/code\u003e is \u003ccode\u003efalse\u003c/code\u003e or missing the rule won't match and therefore, no target will be called.\u003c/p\u003e\n\u003cp\u003eWhat happens if a rule matches? The event will be pushed to its \u003cstrong\u003etargets\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"heading-target\"\u003eTarget\u003c/h3\u003e\n\u003cp\u003eA target is the subscriber of an event rule. There are many target types available in EventBridge. Some of the most important ones are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eLambda\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eSNS Topic\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eSQS Queue\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStep Functions\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAPI Destinations\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can see a list of all supported targets \u003ca target=\"_blank\" href=\"https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOnce the rule matches the target will be invoked and the rule will be sent to this target.\u003c/p\u003e\n\u003ch2 id=\"heading-cron-jobs\"\u003eCron Jobs\u003c/h2\u003e\n\u003cp\u003eCron jobs are regularly executed scripts. EventBridge allows you to run jobs at regular intervals. A cron job can either be defined by a schedule like \u003ccode\u003erun every minute\u003c/code\u003e or by the cron syntax, for example, \u003ccode\u003e0 10 * * ? *\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eEventBridge calls the target in this interval. Cron jobs live on the default event bus.\u003c/p\u003e\n\u003ch2 id=\"heading-archive-amp-replay\"\u003eArchive \u0026amp; Replay\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1666603891263/ZnT3GmvGl.png\" alt=\"Archive and Replay in EventBridge\" /\u003e\u003c/p\u003e\n\u003cp\u003eA really nice feature that was already mentioned in the last post is \u003cstrong\u003eArchive \u0026amp; Replay\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIf you enable the archive functionality, EventBridge will create an archive of \u003cstrong\u003eall events that are sent to this event bus\u003c/strong\u003e. This comes in super handy when you introduced a bug and want to run all events again.\u003c/p\u003e\n\u003cp\u003eAlso, this is pretty useful for using production workloads in a development environment.\u003c/p\u003e\n\u003cp\u003eWith the replay functionality, you can define a start and end time from when the events should be replayed and on which event bus.\u003c/p\u003e\n\u003ch2 id=\"heading-schema-bindings\"\u003eSchema Bindings\u003c/h2\u003e\n\u003cp\u003eEventBridge allows you to activate a schema discovery. The schema discovery can then go ahead and create type bindings \u003cstrong\u003eautomatically for you\u003c/strong\u003e. For example, you can activate schema discovery for your event bus. Then send events to this bus and finally, generate TypeScript types.\u003c/p\u003e\n\u003cp\u003eWhile this idea is really nice it has some drawbacks so we cannot use it right now at Hashnode. For example, it is not really possible to use optional fields.\u003c/p\u003e\n\u003cp\u003eThis is why I won't dive deeper into this topic.\u003c/p\u003e\n\u003ch2 id=\"heading-target-lambda\"\u003eTarget Lambda\u003c/h2\u003e\n\u003cp\u003eThere are many ways to execute your business logic in a target attached to an EventBridge rule. We chose Lambda as the main target for all of our targets.\u003c/p\u003e\n\u003cp\u003eOne alternative was the usage of SQS between EventBridge and Lambda. While the SQS \u0026amp; Lambda approach can be useful for tasks that require a more complicated retry logic, for our case a simple lambda function with Destinations is much easier to implement.\u003c/p\u003e\n\u003cp\u003eLambda functions which are called asynchronously also have an SQS in the background. AWS takes care of that.\u003c/p\u003e\n\u003cp\u003eFailed messages can still be sent to a custom DLQ.\u003c/p\u003e\n\u003cp\u003eWe will show you in one of the next posts how we handle retries and failures in detail.\u003c/p\u003e\n\u003ch2 id=\"heading-final-words\"\u003eFinal Words\u003c/h2\u003e\n\u003cp\u003eThis is our introduction to EventBridge and the last one of our basic posts.\u003c/p\u003e\n\u003cp\u003eNow we will dive deeper into the actual implementation and some nitty-gritty of this architecture.\u003c/p\u003e\n\u003cp\u003ePosts that will follow soon are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eFailures \u0026amp; Retries with EventBridge, Lambda, and Destinations\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eHow to validate incoming events with Middy \u0026amp; ZOD\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIntegration tests with EventBridge\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned 🤘\u003c/p\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1671013503443/INGnCMjJb.png"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"aws-eventbridge-intro"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>